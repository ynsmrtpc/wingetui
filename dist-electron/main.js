var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
import { screen, ipcMain, app, BrowserWindow } from "electron";
import { createRequire } from "node:module";
import { fileURLToPath } from "node:url";
import path$3 from "node:path";
import os$a, { platform } from "os";
import require$$1$2 from "fs";
import require$$2$1 from "path";
import require$$1$1, { exec as exec$h, spawn as spawn$1 } from "child_process";
import require$$4$1, { promisify as promisify$1 } from "util";
import require$$5$1 from "https";
import require$$6$1 from "http";
import require$$0$2 from "net";
import require$$0$3 from "buffer";
import require$$1$3 from "string_decoder";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lib$1 = {};
const version = "5.25.11";
const require$$0$1 = {
  version
};
var util$j = {};
const os$9 = os$a;
const fs$a = require$$1$2;
const path$2 = require$$2$1;
const spawn = require$$1$1.spawn;
const exec$g = require$$1$1.exec;
const execSync$b = require$$1$1.execSync;
const util$i = require$$4$1;
let _platform$h = process.platform;
const _linux$g = _platform$h === "linux" || _platform$h === "android";
const _darwin$g = _platform$h === "darwin";
const _windows$h = _platform$h === "win32";
const _freebsd$f = _platform$h === "freebsd";
const _openbsd$f = _platform$h === "openbsd";
const _netbsd$f = _platform$h === "netbsd";
let _cores = 0;
let wmicPath = "";
let codepage = "";
let _smartMonToolsInstalled = null;
let _rpi_cpuinfo = null;
const WINDIR = process.env.WINDIR || "C:\\Windows";
let _psChild;
let _psResult = "";
let _psCmds = [];
let _psPersistent = false;
let _powerShell = "";
const _psToUTF8 = "$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ";
const _psCmdStart = "--###START###--";
const _psError = "--ERROR--";
const _psCmdSeperator = "--###ENDCMD###--";
const _psIdSeperator = "--##ID##--";
const execOptsWin = {
  windowsHide: true,
  maxBuffer: 1024 * 2e4,
  encoding: "UTF-8",
  env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
};
const execOptsLinux = {
  maxBuffer: 1024 * 2e4,
  encoding: "UTF-8",
  stdio: ["pipe", "pipe", "ignore"]
};
function toInt(value) {
  let result2 = parseInt(value, 10);
  if (isNaN(result2)) {
    result2 = 0;
  }
  return result2;
}
function splitByNumber(str) {
  let numberStarted = false;
  let num = "";
  let cpart = "";
  for (const c of str) {
    if (c >= "0" && c <= "9" || numberStarted) {
      numberStarted = true;
      num += c;
    } else {
      cpart += c;
    }
  }
  return [cpart, num];
}
const stringObj = new String();
const stringReplace = new String().replace;
const stringToLower = new String().toLowerCase;
const stringToString = new String().toString;
const stringSubstr = new String().substr;
const stringSubstring = new String().substring;
const stringTrim = new String().trim;
const stringStartWith = new String().startsWith;
const mathMin = Math.min;
function isFunction(functionToCheck) {
  let getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function unique(obj) {
  let uniques = [];
  let stringify = {};
  for (let i = 0; i < obj.length; i++) {
    let keys = Object.keys(obj[i]);
    keys.sort(function(a, b) {
      return a - b;
    });
    let str = "";
    for (let j = 0; j < keys.length; j++) {
      str += JSON.stringify(keys[j]);
      str += JSON.stringify(obj[i][keys[j]]);
    }
    if (!{}.hasOwnProperty.call(stringify, str)) {
      uniques.push(obj[i]);
      stringify[str] = true;
    }
  }
  return uniques;
}
function sortByKey(array, keys) {
  return array.sort(function(a, b) {
    let x = "";
    let y = "";
    keys.forEach(function(key2) {
      x = x + a[key2];
      y = y + b[key2];
    });
    return x < y ? -1 : x > y ? 1 : 0;
  });
}
function cores() {
  if (_cores === 0) {
    _cores = os$9.cpus().length;
  }
  return _cores;
}
function getValue(lines, property, separator, trimmed, lineMatch) {
  separator = separator || ":";
  property = property.toLowerCase();
  trimmed = trimmed || false;
  lineMatch = lineMatch || false;
  let result2 = "";
  lines.some((line) => {
    let lineLower = line.toLowerCase().replace(/\t/g, "");
    if (trimmed) {
      lineLower = lineLower.trim();
    }
    if (lineLower.startsWith(property) && (lineMatch ? lineLower.match(property + separator) || lineLower.match(property + " " + separator) : true)) {
      const parts = trimmed ? line.trim().split(separator) : line.split(separator);
      if (parts.length >= 2) {
        parts.shift();
        result2 = parts.join(separator).trim();
        return true;
      }
    }
  });
  return result2;
}
function decodeEscapeSequence(str, base) {
  base = base || 16;
  return str.replace(/\\x([0-9A-Fa-f]{2})/g, function() {
    return String.fromCharCode(parseInt(arguments[1], base));
  });
}
function detectSplit(str) {
  let seperator = "";
  let part = 0;
  str.split("").forEach((element) => {
    if (element >= "0" && element <= "9") {
      if (part === 1) {
        part++;
      }
    } else {
      if (part === 0) {
        part++;
      }
      if (part === 1) {
        seperator += element;
      }
    }
  });
  return seperator;
}
function parseTime(t, pmDesignator) {
  pmDesignator = pmDesignator || "";
  t = t.toUpperCase();
  let hour = 0;
  let min = 0;
  let splitter = detectSplit(t);
  let parts = t.split(splitter);
  if (parts.length >= 2) {
    if (parts[2]) {
      parts[1] += parts[2];
    }
    let isPM = parts[1] && parts[1].toLowerCase().indexOf("pm") > -1 || parts[1].toLowerCase().indexOf("p.m.") > -1 || parts[1].toLowerCase().indexOf("p. m.") > -1 || parts[1].toLowerCase().indexOf("n") > -1 || parts[1].toLowerCase().indexOf("ch") > -1 || parts[1].toLowerCase().indexOf("Ã¶s") > -1 || pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1;
    hour = parseInt(parts[0], 10);
    min = parseInt(parts[1], 10);
    hour = isPM && hour < 12 ? hour + 12 : hour;
    return ("0" + hour).substr(-2) + ":" + ("0" + min).substr(-2);
  }
}
function parseDateTime(dt, culture) {
  const result2 = {
    date: "",
    time: ""
  };
  culture = culture || {};
  let dateFormat = (culture.dateFormat || "").toLowerCase();
  let pmDesignator = culture.pmDesignator || "";
  const parts = dt.split(" ");
  if (parts[0]) {
    if (parts[0].indexOf("/") >= 0) {
      const dtparts = parts[0].split("/");
      if (dtparts.length === 3) {
        if (dtparts[0].length === 4) {
          result2.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
        } else if (dtparts[2].length === 2) {
          if (dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) {
            result2.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
          } else {
            result2.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
          }
        } else {
          const isEN = dt.toLowerCase().indexOf("pm") > -1 || dt.toLowerCase().indexOf("p.m.") > -1 || dt.toLowerCase().indexOf("p. m.") > -1 || dt.toLowerCase().indexOf("am") > -1 || dt.toLowerCase().indexOf("a.m.") > -1 || dt.toLowerCase().indexOf("a. m.") > -1;
          if ((isEN || dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) && dateFormat.indexOf("dd/") !== 0) {
            result2.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
          } else {
            result2.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
          }
        }
      }
    }
    if (parts[0].indexOf(".") >= 0) {
      const dtparts = parts[0].split(".");
      if (dtparts.length === 3) {
        if (dateFormat.indexOf(".d.") > -1 || dateFormat.indexOf(".dd.") > -1) {
          result2.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
        } else {
          result2.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
        }
      }
    }
    if (parts[0].indexOf("-") >= 0) {
      const dtparts = parts[0].split("-");
      if (dtparts.length === 3) {
        result2.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
      }
    }
  }
  if (parts[1]) {
    parts.shift();
    let time2 = parts.join(" ");
    result2.time = parseTime(time2, pmDesignator);
  }
  return result2;
}
function parseHead(head, rights) {
  let space = rights > 0;
  let count = 1;
  let from = 0;
  let to = 0;
  let result2 = [];
  for (let i = 0; i < head.length; i++) {
    if (count <= rights) {
      if (/\s/.test(head[i]) && !space) {
        to = i - 1;
        result2.push({
          from,
          to: to + 1,
          cap: head.substring(from, to + 1)
        });
        from = to + 2;
        count++;
      }
      space = head[i] === " ";
    } else {
      if (!/\s/.test(head[i]) && space) {
        to = i - 1;
        if (from < to) {
          result2.push({
            from,
            to,
            cap: head.substring(from, to)
          });
        }
        from = to + 1;
        count++;
      }
      space = head[i] === " ";
    }
  }
  to = 5e3;
  result2.push({
    from,
    to,
    cap: head.substring(from, to)
  });
  let len = result2.length;
  for (let i = 0; i < len; i++) {
    if (result2[i].cap.replace(/\s/g, "").length === 0) {
      if (i + 1 < len) {
        result2[i].to = result2[i + 1].to;
        result2[i].cap = result2[i].cap + result2[i + 1].cap;
        result2.splice(i + 1, 1);
        len = len - 1;
      }
    }
  }
  return result2;
}
function findObjectByKey(array, key2, value) {
  for (let i = 0; i < array.length; i++) {
    if (array[i][key2] === value) {
      return i;
    }
  }
  return -1;
}
function getPowershell() {
  _powerShell = "powershell.exe";
  if (_windows$h) {
    const defaultPath = `${WINDIR}\\system32\\WindowsPowerShell\\v1.0\\powershell.exe`;
    if (fs$a.existsSync(defaultPath)) {
      _powerShell = defaultPath;
    }
  }
}
function getWmic() {
  if (os$9.type() === "Windows_NT" && !wmicPath) {
    wmicPath = WINDIR + "\\system32\\wbem\\wmic.exe";
    if (!fs$a.existsSync(wmicPath)) {
      try {
        const wmicPathArray = execSync$b("WHERE WMIC", execOptsWin).toString().split("\r\n");
        if (wmicPathArray && wmicPathArray.length) {
          wmicPath = wmicPathArray[0];
        } else {
          wmicPath = "wmic";
        }
      } catch (e) {
        wmicPath = "wmic";
      }
    }
  }
  return wmicPath;
}
function wmic(command) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      try {
        powerShell(getWmic() + " " + command).then((stdout) => {
          resolve(stdout, "");
        });
      } catch (e) {
        resolve("", e);
      }
    });
  });
}
function getVboxmanage() {
  return _windows$h ? `"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\VBoxManage.exe"` : "vboxmanage";
}
function powerShellProceedResults(data) {
  let id = "";
  let parts;
  let res = "";
  if (data.indexOf(_psCmdStart) >= 0) {
    parts = data.split(_psCmdStart);
    const parts2 = parts[1].split(_psIdSeperator);
    id = parts2[0];
    if (parts2.length > 1) {
      data = parts2.slice(1).join(_psIdSeperator);
    }
  }
  if (data.indexOf(_psCmdSeperator) >= 0) {
    parts = data.split(_psCmdSeperator);
    res = parts[0];
  }
  let remove = -1;
  for (let i = 0; i < _psCmds.length; i++) {
    if (_psCmds[i].id === id) {
      remove = i;
      _psCmds[i].callback(res);
    }
  }
  if (remove >= 0) {
    _psCmds.splice(remove, 1);
  }
}
function powerShellStart() {
  if (!_psChild) {
    _psChild = spawn(_powerShell, ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-Command", "-"], {
      stdio: "pipe",
      windowsHide: true,
      maxBuffer: 1024 * 2e4,
      encoding: "UTF-8",
      env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
    });
    if (_psChild && _psChild.pid) {
      _psPersistent = true;
      _psChild.stdout.on("data", function(data) {
        _psResult = _psResult + data.toString("utf8");
        if (data.indexOf(_psCmdSeperator) >= 0) {
          powerShellProceedResults(_psResult);
          _psResult = "";
        }
      });
      _psChild.stderr.on("data", function() {
        powerShellProceedResults(_psResult + _psError);
      });
      _psChild.on("error", function() {
        powerShellProceedResults(_psResult + _psError);
      });
      _psChild.on("close", function() {
        if (_psChild) {
          _psChild.kill();
        }
      });
    }
  }
}
function powerShellRelease() {
  try {
    if (_psChild) {
      _psChild.stdin.write("exit" + os$9.EOL);
      _psChild.stdin.end();
      _psPersistent = false;
    }
  } catch (e) {
    if (_psChild) {
      _psChild.kill();
    }
  }
  _psChild = null;
}
function powerShell(cmd) {
  if (_psPersistent) {
    const id = Math.random().toString(36).substring(2, 12);
    return new Promise((resolve) => {
      process.nextTick(() => {
        function callback(data) {
          resolve(data);
        }
        _psCmds.push({
          id,
          cmd,
          callback,
          start: /* @__PURE__ */ new Date()
        });
        try {
          if (_psChild && _psChild.pid) {
            _psChild.stdin.write(_psToUTF8 + "echo " + _psCmdStart + id + _psIdSeperator + "; " + os$9.EOL + cmd + os$9.EOL + "echo " + _psCmdSeperator + os$9.EOL);
          }
        } catch (e) {
          resolve("");
        }
      });
    });
  } else {
    let result2 = "";
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          const child = spawn(_powerShell, ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-ExecutionPolicy", "Unrestricted", "-Command", "-"], {
            stdio: "pipe",
            windowsHide: true,
            maxBuffer: 1024 * 2e4,
            encoding: "UTF-8",
            env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
          });
          if (child && !child.pid) {
            child.on("error", function() {
              resolve(result2);
            });
          }
          if (child && child.pid) {
            child.stdout.on("data", function(data) {
              result2 = result2 + data.toString("utf8");
            });
            child.stderr.on("data", function() {
              child.kill();
              resolve(result2);
            });
            child.on("close", function() {
              child.kill();
              resolve(result2);
            });
            child.on("error", function() {
              child.kill();
              resolve(result2);
            });
            try {
              child.stdin.write(_psToUTF8 + cmd + os$9.EOL);
              child.stdin.write("exit" + os$9.EOL);
              child.stdin.end();
            } catch (e) {
              child.kill();
              resolve(result2);
            }
          } else {
            resolve(result2);
          }
        } catch (e) {
          resolve(result2);
        }
      });
    });
  }
}
function execSafe(cmd, args, options) {
  let result2 = "";
  options = options || {};
  return new Promise((resolve) => {
    process.nextTick(() => {
      try {
        const child = spawn(cmd, args, options);
        if (child && !child.pid) {
          child.on("error", function() {
            resolve(result2);
          });
        }
        if (child && child.pid) {
          child.stdout.on("data", function(data) {
            result2 += data.toString();
          });
          child.on("close", function() {
            child.kill();
            resolve(result2);
          });
          child.on("error", function() {
            child.kill();
            resolve(result2);
          });
        } else {
          resolve(result2);
        }
      } catch (e) {
        resolve(result2);
      }
    });
  });
}
function getCodepage() {
  if (_windows$h) {
    if (!codepage) {
      try {
        const stdout = execSync$b("chcp", execOptsWin);
        const lines = stdout.toString().split("\r\n");
        const parts = lines[0].split(":");
        codepage = parts.length > 1 ? parts[1].replace(".", "").trim() : "";
      } catch (err) {
        codepage = "437";
      }
    }
    return codepage;
  }
  if (_linux$g || _darwin$g || _freebsd$f || _openbsd$f || _netbsd$f) {
    if (!codepage) {
      try {
        const stdout = execSync$b("echo $LANG", execOptsLinux);
        const lines = stdout.toString().split("\r\n");
        const parts = lines[0].split(".");
        codepage = parts.length > 1 ? parts[1].trim() : "";
        if (!codepage) {
          codepage = "UTF-8";
        }
      } catch (err) {
        codepage = "UTF-8";
      }
    }
    return codepage;
  }
}
function smartMonToolsInstalled() {
  if (_smartMonToolsInstalled !== null) {
    return _smartMonToolsInstalled;
  }
  _smartMonToolsInstalled = false;
  if (_windows$h) {
    try {
      const pathArray = execSync$b("WHERE smartctl 2>nul", execOptsWin).toString().split("\r\n");
      if (pathArray && pathArray.length) {
        _smartMonToolsInstalled = pathArray[0].indexOf(":\\") >= 0;
      } else {
        _smartMonToolsInstalled = false;
      }
    } catch (e) {
      _smartMonToolsInstalled = false;
    }
  }
  if (_linux$g || _darwin$g || _freebsd$f || _openbsd$f || _netbsd$f) {
    try {
      const pathArray = execSync$b("which smartctl 2>/dev/null", execOptsLinux).toString().split("\r\n");
      _smartMonToolsInstalled = pathArray.length > 0;
    } catch (e) {
      util$i.noop();
    }
  }
  return _smartMonToolsInstalled;
}
function isRaspberry(cpuinfo) {
  const PI_MODEL_NO = [
    "BCM2708",
    "BCM2709",
    "BCM2710",
    "BCM2711",
    "BCM2712",
    "BCM2835",
    "BCM2836",
    "BCM2837",
    "BCM2837B0"
  ];
  if (_rpi_cpuinfo !== null) {
    cpuinfo = _rpi_cpuinfo;
  } else if (cpuinfo === void 0) {
    try {
      cpuinfo = fs$a.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
      _rpi_cpuinfo = cpuinfo;
    } catch (e) {
      return false;
    }
  }
  const hardware = getValue(cpuinfo, "hardware");
  const model = getValue(cpuinfo, "model");
  return hardware && PI_MODEL_NO.indexOf(hardware) > -1 || model && model.indexOf("Raspberry Pi") > -1;
}
function isRaspbian() {
  let osrelease = [];
  try {
    osrelease = fs$a.readFileSync("/etc/os-release", { encoding: "utf8" }).toString().split("\n");
  } catch (e) {
    return false;
  }
  const id = getValue(osrelease, "id", "=");
  return id && id.indexOf("raspbian") > -1;
}
function execWin(cmd, opts, callback) {
  if (!callback) {
    callback = opts;
    opts = execOptsWin;
  }
  let newCmd = "chcp 65001 > nul && cmd /C " + cmd + " && chcp " + codepage + " > nul";
  exec$g(newCmd, opts, function(error, stdout) {
    callback(error, stdout);
  });
}
function darwinXcodeExists() {
  const cmdLineToolsExists = fs$a.existsSync("/Library/Developer/CommandLineTools/usr/bin/");
  const xcodeAppExists = fs$a.existsSync("/Applications/Xcode.app/Contents/Developer/Tools");
  const xcodeExists = fs$a.existsSync("/Library/Developer/Xcode/");
  return cmdLineToolsExists || xcodeExists || xcodeAppExists;
}
function nanoSeconds() {
  const time2 = process.hrtime();
  if (!Array.isArray(time2) || time2.length !== 2) {
    return 0;
  }
  return +time2[0] * 1e9 + +time2[1];
}
function countUniqueLines(lines, startingWith) {
  startingWith = startingWith || "";
  const uniqueLines = [];
  lines.forEach((line) => {
    if (line.startsWith(startingWith)) {
      if (uniqueLines.indexOf(line) === -1) {
        uniqueLines.push(line);
      }
    }
  });
  return uniqueLines.length;
}
function countLines(lines, startingWith) {
  startingWith = startingWith || "";
  const uniqueLines = [];
  lines.forEach((line) => {
    if (line.startsWith(startingWith)) {
      uniqueLines.push(line);
    }
  });
  return uniqueLines.length;
}
function sanitizeShellString(str, strict) {
  if (typeof strict === "undefined") {
    strict = false;
  }
  const s = str || "";
  let result2 = "";
  const l = mathMin(s.length, 2e3);
  for (let i = 0; i <= l; i++) {
    if (!(s[i] === void 0 || s[i] === ">" || s[i] === "<" || s[i] === "*" || s[i] === "?" || s[i] === "[" || s[i] === "]" || s[i] === "|" || s[i] === "Ë" || s[i] === "$" || s[i] === ";" || s[i] === "&" || s[i] === "]" || s[i] === "#" || s[i] === "\\" || s[i] === "	" || s[i] === "\n" || s[i] === "\r" || s[i] === "'" || s[i] === "`" || s[i] === '"' || s[i].length > 1 || strict && s[i] === "(" || strict && s[i] === ")" || strict && s[i] === "@" || strict && s[i] === " " || strict && s[i] == "{" || strict && s[i] == ";" || strict && s[i] == "}")) {
      result2 = result2 + s[i];
    }
  }
  return result2;
}
function isPrototypePolluted() {
  const s = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let notPolluted = true;
  let st = "";
  try {
    st.__proto__.replace = stringReplace;
    st.__proto__.toLowerCase = stringToLower;
    st.__proto__.toString = stringToString;
    st.__proto__.substr = stringSubstr;
    st.__proto__.substring = stringSubstring;
    st.__proto__.trim = stringTrim;
    st.__proto__.startsWith = stringStartWith;
  } catch (e) {
    Object.setPrototypeOf(st, stringObj);
  }
  notPolluted = notPolluted || s.length !== 62;
  const ms = Date.now();
  if (typeof ms === "number" && ms > 16e11) {
    const l = ms % 100 + 15;
    for (let i = 0; i < l; i++) {
      const r = Math.random() * 61.99999999 + 1;
      const rs = parseInt(Math.floor(r).toString(), 10);
      const rs2 = parseInt(r.toString().split(".")[0], 10);
      const q = Math.random() * 61.99999999 + 1;
      const qs = parseInt(Math.floor(q).toString(), 10);
      const qs2 = parseInt(q.toString().split(".")[0], 10);
      notPolluted = notPolluted && r !== q;
      notPolluted = notPolluted && rs === rs2 && qs === qs2;
      st += s[rs - 1];
    }
    notPolluted = notPolluted && st.length === l;
    let p = Math.random() * l * 0.9999999999;
    let stm = st.substr(0, p) + " " + st.substr(p, 2e3);
    try {
      stm.__proto__.replace = stringReplace;
    } catch (e) {
      Object.setPrototypeOf(stm, stringObj);
    }
    let sto = stm.replace(/ /g, "");
    notPolluted = notPolluted && st === sto;
    p = Math.random() * l * 0.9999999999;
    stm = st.substr(0, p) + "{" + st.substr(p, 2e3);
    sto = stm.replace(/{/g, "");
    notPolluted = notPolluted && st === sto;
    p = Math.random() * l * 0.9999999999;
    stm = st.substr(0, p) + "*" + st.substr(p, 2e3);
    sto = stm.replace(/\*/g, "");
    notPolluted = notPolluted && st === sto;
    p = Math.random() * l * 0.9999999999;
    stm = st.substr(0, p) + "$" + st.substr(p, 2e3);
    sto = stm.replace(/\$/g, "");
    notPolluted = notPolluted && st === sto;
    const stl = st.toLowerCase();
    notPolluted = notPolluted && stl.length === l && stl[l - 1] && !stl[l];
    for (let i = 0; i < l; i++) {
      const s1 = st[i];
      try {
        s1.__proto__.toLowerCase = stringToLower;
      } catch (e) {
        Object.setPrototypeOf(st, stringObj);
      }
      const s2 = stl ? stl[i] : "";
      const s1l = s1.toLowerCase();
      notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !s1l[1];
    }
  }
  return !notPolluted;
}
function hex2bin(hex) {
  return ("00000000" + parseInt(hex, 16).toString(2)).substr(-8);
}
function getFilesInPath(source) {
  const lstatSync = fs$a.lstatSync;
  const readdirSync = fs$a.readdirSync;
  const join = path$2.join;
  function isDirectory(source2) {
    return lstatSync(source2).isDirectory();
  }
  function isFile(source2) {
    return lstatSync(source2).isFile();
  }
  function getDirectories(source2) {
    return readdirSync(source2).map(function(name) {
      return join(source2, name);
    }).filter(isDirectory);
  }
  function getFiles(source2) {
    return readdirSync(source2).map(function(name) {
      return join(source2, name);
    }).filter(isFile);
  }
  function getFilesRecursively(source2) {
    try {
      let dirs = getDirectories(source2);
      let files = dirs.map(function(dir) {
        return getFilesRecursively(dir);
      }).reduce(function(a, b) {
        return a.concat(b);
      }, []);
      return files.concat(getFiles(source2));
    } catch (e) {
      return [];
    }
  }
  if (fs$a.existsSync(source)) {
    return getFilesRecursively(source);
  } else {
    return [];
  }
}
function decodePiCpuinfo(lines) {
  if (_rpi_cpuinfo === null) {
    _rpi_cpuinfo = lines;
  } else if (lines === void 0) {
    lines = _rpi_cpuinfo;
  }
  const oldRevisionCodes = {
    "0002": {
      type: "B",
      revision: "1.0",
      memory: 256,
      manufacturer: "Egoman",
      processor: "BCM2835"
    },
    "0003": {
      type: "B",
      revision: "1.0",
      memory: 256,
      manufacturer: "Egoman",
      processor: "BCM2835"
    },
    "0004": {
      type: "B",
      revision: "2.0",
      memory: 256,
      manufacturer: "Sony UK",
      processor: "BCM2835"
    },
    "0005": {
      type: "B",
      revision: "2.0",
      memory: 256,
      manufacturer: "Qisda",
      processor: "BCM2835"
    },
    "0006": {
      type: "B",
      revision: "2.0",
      memory: 256,
      manufacturer: "Egoman",
      processor: "BCM2835"
    },
    "0007": {
      type: "A",
      revision: "2.0",
      memory: 256,
      manufacturer: "Egoman",
      processor: "BCM2835"
    },
    "0008": {
      type: "A",
      revision: "2.0",
      memory: 256,
      manufacturer: "Sony UK",
      processor: "BCM2835"
    },
    "0009": {
      type: "A",
      revision: "2.0",
      memory: 256,
      manufacturer: "Qisda",
      processor: "BCM2835"
    },
    "000d": {
      type: "B",
      revision: "2.0",
      memory: 512,
      manufacturer: "Egoman",
      processor: "BCM2835"
    },
    "000e": {
      type: "B",
      revision: "2.0",
      memory: 512,
      manufacturer: "Sony UK",
      processor: "BCM2835"
    },
    "000f": {
      type: "B",
      revision: "2.0",
      memory: 512,
      manufacturer: "Egoman",
      processor: "BCM2835"
    },
    "0010": {
      type: "B+",
      revision: "1.2",
      memory: 512,
      manufacturer: "Sony UK",
      processor: "BCM2835"
    },
    "0011": {
      type: "CM1",
      revision: "1.0",
      memory: 512,
      manufacturer: "Sony UK",
      processor: "BCM2835"
    },
    "0012": {
      type: "A+",
      revision: "1.1",
      memory: 256,
      manufacturer: "Sony UK",
      processor: "BCM2835"
    },
    "0013": {
      type: "B+",
      revision: "1.2",
      memory: 512,
      manufacturer: "Embest",
      processor: "BCM2835"
    },
    "0014": {
      type: "CM1",
      revision: "1.0",
      memory: 512,
      manufacturer: "Embest",
      processor: "BCM2835"
    },
    "0015": {
      type: "A+",
      revision: "1.1",
      memory: 256,
      manufacturer: "512MB	Embest",
      processor: "BCM2835"
    }
  };
  const processorList = [
    "BCM2835",
    "BCM2836",
    "BCM2837",
    "BCM2711",
    "BCM2712"
  ];
  const manufacturerList = [
    "Sony UK",
    "Egoman",
    "Embest",
    "Sony Japan",
    "Embest",
    "Stadium"
  ];
  const typeList = {
    "00": "A",
    "01": "B",
    "02": "A+",
    "03": "B+",
    "04": "2B",
    "05": "Alpha (early prototype)",
    "06": "CM1",
    "08": "3B",
    "09": "Zero",
    "0a": "CM3",
    "0c": "Zero W",
    "0d": "3B+",
    "0e": "3A+",
    "0f": "Internal use only",
    "10": "CM3+",
    "11": "4B",
    "12": "Zero 2 W",
    "13": "400",
    "14": "CM4",
    "15": "CM4S",
    "16": "Internal use only",
    "17": "5",
    "18": "CM5",
    "19": "500",
    "1a": "CM5 Lite"
  };
  const revisionCode = getValue(lines, "revision", ":", true);
  const model = getValue(lines, "model:", ":", true);
  const serial = getValue(lines, "serial", ":", true);
  let result2 = {};
  if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {
    result2 = {
      model,
      serial,
      revisionCode,
      memory: oldRevisionCodes[revisionCode].memory,
      manufacturer: oldRevisionCodes[revisionCode].manufacturer,
      processor: oldRevisionCodes[revisionCode].processor,
      type: oldRevisionCodes[revisionCode].type,
      revision: oldRevisionCodes[revisionCode].revision
    };
  } else {
    const revision = ("00000000" + getValue(lines, "revision", ":", true).toLowerCase()).substr(-8);
    const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;
    const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];
    const processor = processorList[parseInt(revision.substr(4, 1), 10)];
    const typeCode = revision.substr(5, 2);
    result2 = {
      model,
      serial,
      revisionCode,
      memory: 256 * Math.pow(2, memSizeCode),
      manufacturer,
      processor,
      type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : "",
      revision: "1." + revision.substr(7, 1)
    };
  }
  return result2;
}
function getRpiGpu(cpuinfo) {
  if (_rpi_cpuinfo === null && cpuinfo !== void 0) {
    _rpi_cpuinfo = cpuinfo;
  } else if (cpuinfo === void 0 && _rpi_cpuinfo !== null) {
    cpuinfo = _rpi_cpuinfo;
  } else {
    try {
      cpuinfo = fs$a.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
      _rpi_cpuinfo = cpuinfo;
    } catch (e) {
      return false;
    }
  }
  const rpi = decodePiCpuinfo(cpuinfo);
  if (rpi.type === "4B" || rpi.type === "CM4" || rpi.type === "CM4S" || rpi.type === "400") {
    return "VideoCore VI";
  }
  if (rpi.type === "5" || rpi.type === "500") {
    return "VideoCore VII";
  }
  return "VideoCore IV";
}
function promiseAll(promises) {
  const resolvingPromises = promises.map(function(promise) {
    return new Promise(function(resolve) {
      let payload = new Array(2);
      promise.then(function(result2) {
        payload[0] = result2;
      }).catch(function(error) {
        payload[1] = error;
      }).then(function() {
        resolve(payload);
      });
    });
  });
  const errors = [];
  const results = [];
  return Promise.all(resolvingPromises).then(function(items) {
    items.forEach(function(payload) {
      if (payload[1]) {
        errors.push(payload[1]);
        results.push(null);
      } else {
        errors.push(null);
        results.push(payload[0]);
      }
    });
    return {
      errors,
      results
    };
  });
}
function promisify(nodeStyleFunction) {
  return function() {
    const args = Array.prototype.slice.call(arguments);
    return new Promise(function(resolve, reject) {
      args.push(function(err, data) {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
      nodeStyleFunction.apply(null, args);
    });
  };
}
function promisifySave(nodeStyleFunction) {
  return function() {
    const args = Array.prototype.slice.call(arguments);
    return new Promise(function(resolve) {
      args.push(function(err, data) {
        resolve(data);
      });
      nodeStyleFunction.apply(null, args);
    });
  };
}
function linuxVersion() {
  let result2 = "";
  if (_linux$g) {
    try {
      result2 = execSync$b("uname -v", execOptsLinux).toString();
    } catch (e) {
      result2 = "";
    }
  }
  return result2;
}
function plistParser(xmlStr) {
  const tags = ["array", "dict", "key", "string", "integer", "date", "real", "data", "boolean", "arrayEmpty"];
  const startStr = "<plist version";
  let pos = xmlStr.indexOf(startStr);
  let len = xmlStr.length;
  while (xmlStr[pos] !== ">" && pos < len) {
    pos++;
  }
  let depth = 0;
  let inTagStart = false;
  let inTagContent = false;
  let inTagEnd = false;
  let metaData = [{ tagStart: "", tagEnd: "", tagContent: "", key: "", data: null }];
  let c = "";
  let cn = xmlStr[pos];
  while (pos < len) {
    c = cn;
    if (pos + 1 < len) {
      cn = xmlStr[pos + 1];
    }
    if (c === "<") {
      inTagContent = false;
      if (cn === "/") {
        inTagEnd = true;
      } else if (metaData[depth].tagStart) {
        metaData[depth].tagContent = "";
        if (!metaData[depth].data) {
          metaData[depth].data = metaData[depth].tagStart === "array" ? [] : {};
        }
        depth++;
        metaData.push({ tagStart: "", tagEnd: "", tagContent: "", key: null, data: null });
        inTagStart = true;
        inTagContent = false;
      } else if (!inTagStart) {
        inTagStart = true;
      }
    } else if (c === ">") {
      if (metaData[depth].tagStart === "true/") {
        inTagStart = false;
        inTagEnd = true;
        metaData[depth].tagStart = "";
        metaData[depth].tagEnd = "/boolean";
        metaData[depth].data = true;
      }
      if (metaData[depth].tagStart === "false/") {
        inTagStart = false;
        inTagEnd = true;
        metaData[depth].tagStart = "";
        metaData[depth].tagEnd = "/boolean";
        metaData[depth].data = false;
      }
      if (metaData[depth].tagStart === "array/") {
        inTagStart = false;
        inTagEnd = true;
        metaData[depth].tagStart = "";
        metaData[depth].tagEnd = "/arrayEmpty";
        metaData[depth].data = [];
      }
      if (inTagContent) {
        inTagContent = false;
      }
      if (inTagStart) {
        inTagStart = false;
        inTagContent = true;
        if (metaData[depth].tagStart === "array") {
          metaData[depth].data = [];
        }
        if (metaData[depth].tagStart === "dict") {
          metaData[depth].data = {};
        }
      }
      if (inTagEnd) {
        inTagEnd = false;
        if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {
          if (metaData[depth].tagEnd === "/dict" || metaData[depth].tagEnd === "/array") {
            if (depth > 1 && metaData[depth - 2].tagStart === "array") {
              metaData[depth - 2].data.push(metaData[depth - 1].data);
            }
            if (depth > 1 && metaData[depth - 2].tagStart === "dict") {
              metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;
            }
            depth--;
            metaData.pop();
            metaData[depth].tagContent = "";
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "";
          } else {
            if (metaData[depth].tagEnd === "/key" && metaData[depth].tagContent) {
              metaData[depth].key = metaData[depth].tagContent;
            } else {
              if (metaData[depth].tagEnd === "/real" && metaData[depth].tagContent) {
                metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0;
              }
              if (metaData[depth].tagEnd === "/integer" && metaData[depth].tagContent) {
                metaData[depth].data = parseInt(metaData[depth].tagContent) || 0;
              }
              if (metaData[depth].tagEnd === "/string" && metaData[depth].tagContent) {
                metaData[depth].data = metaData[depth].tagContent || "";
              }
              if (metaData[depth].tagEnd === "/boolean") {
                metaData[depth].data = metaData[depth].tagContent || false;
              }
              if (metaData[depth].tagEnd === "/arrayEmpty") {
                metaData[depth].data = metaData[depth].tagContent || [];
              }
              if (depth > 0 && metaData[depth - 1].tagStart === "array") {
                metaData[depth - 1].data.push(metaData[depth].data);
              }
              if (depth > 0 && metaData[depth - 1].tagStart === "dict") {
                metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data;
              }
            }
            metaData[depth].tagContent = "";
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "";
          }
        }
        metaData[depth].tagEnd = "";
        inTagStart = false;
        inTagContent = false;
      }
    } else {
      if (inTagStart) {
        metaData[depth].tagStart += c;
      }
      if (inTagEnd) {
        metaData[depth].tagEnd += c;
      }
      if (inTagContent) {
        metaData[depth].tagContent += c;
      }
    }
    pos++;
  }
  return metaData[0].data;
}
function strIsNumeric(str) {
  return typeof str === "string" && !isNaN(str) && !isNaN(parseFloat(str));
}
function plistReader(output) {
  const lines = output.split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].indexOf(" = ") >= 0) {
      const lineParts = lines[i].split(" = ");
      lineParts[0] = lineParts[0].trim();
      if (!lineParts[0].startsWith('"')) {
        lineParts[0] = '"' + lineParts[0] + '"';
      }
      lineParts[1] = lineParts[1].trim();
      if (lineParts[1].indexOf('"') === -1 && lineParts[1].endsWith(";")) {
        const valueString = lineParts[1].substring(0, lineParts[1].length - 1);
        if (!strIsNumeric(valueString)) {
          lineParts[1] = `"${valueString}";`;
        }
      }
      if (lineParts[1].indexOf('"') >= 0 && lineParts[1].endsWith(";")) {
        const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/"/g, "");
        if (strIsNumeric(valueString)) {
          lineParts[1] = `${valueString};`;
        }
      }
      lines[i] = lineParts.join(" : ");
    }
    lines[i] = lines[i].replace(/\(/g, "[").replace(/\)/g, "]").replace(/;/g, ",").trim();
    if (lines[i].startsWith("}") && lines[i - 1] && lines[i - 1].endsWith(",")) {
      lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);
    }
  }
  output = lines.join("");
  let obj = {};
  try {
    obj = JSON.parse(output);
  } catch (e) {
  }
  return obj;
}
function semverCompare(v1, v2) {
  let res = 0;
  const parts1 = v1.split(".");
  const parts2 = v2.split(".");
  if (parts1[0] < parts2[0]) {
    res = 1;
  } else if (parts1[0] > parts2[0]) {
    res = -1;
  } else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {
    if (parts1[1] < parts2[1]) {
      res = 1;
    } else if (parts1[1] > parts2[1]) {
      res = -1;
    } else if (parts1[1] === parts2[1]) {
      if (parts1.length >= 3 && parts2.length >= 3) {
        if (parts1[2] < parts2[2]) {
          res = 1;
        } else if (parts1[2] > parts2[2]) {
          res = -1;
        }
      } else if (parts2.length >= 3) {
        res = 1;
      }
    }
  }
  return res;
}
function getAppleModel(key2) {
  const appleModelIds = [
    {
      key: "Mac15,12",
      name: "MacBook Air",
      size: "13-inch",
      processor: "M3",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac14,15",
      name: "MacBook Air",
      size: "15-inch",
      processor: "M2",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac14,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "M2",
      year: "2022",
      additional: ""
    },
    {
      key: "MacBookAir10,1",
      name: "MacBook Air",
      size: "13-inch",
      processor: "M1",
      year: "2020",
      additional: ""
    },
    {
      key: "MacBookAir9,1",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "2020",
      additional: ""
    },
    {
      key: "MacBookAir8,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacBookAir8,1",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "2018",
      additional: ""
    },
    {
      key: "MacBookAir7,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "2017",
      additional: ""
    },
    {
      key: "MacBookAir7,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Early 2015",
      additional: ""
    },
    {
      key: "MacBookAir7,1",
      name: "MacBook Air",
      size: "11-inch",
      processor: "",
      year: "Early 2015",
      additional: ""
    },
    {
      key: "MacBookAir6,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Early 2014",
      additional: ""
    },
    {
      key: "MacBookAir6,1",
      name: "MacBook Air",
      size: "11-inch",
      processor: "",
      year: "Early 2014",
      additional: ""
    },
    {
      key: "MacBookAir6,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Mid 2013",
      additional: ""
    },
    {
      key: "MacBookAir6,1",
      name: "MacBook Air",
      size: "11-inch",
      processor: "",
      year: "Mid 2013",
      additional: ""
    },
    {
      key: "MacBookAir5,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Mid 2012",
      additional: ""
    },
    {
      key: "MacBookAir5,1",
      name: "MacBook Air",
      size: "11-inch",
      processor: "",
      year: "Mid 2012",
      additional: ""
    },
    {
      key: "MacBookAir4,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Mid 2011",
      additional: ""
    },
    {
      key: "MacBookAir4,1",
      name: "MacBook Air",
      size: "11-inch",
      processor: "",
      year: "Mid 2011",
      additional: ""
    },
    {
      key: "MacBookAir3,2",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Late 2010",
      additional: ""
    },
    {
      key: "MacBookAir3,1",
      name: "MacBook Air",
      size: "11-inch",
      processor: "",
      year: "Late 2010",
      additional: ""
    },
    {
      key: "MacBookAir2,1",
      name: "MacBook Air",
      size: "13-inch",
      processor: "",
      year: "Mid 2009",
      additional: ""
    },
    {
      key: "Mac16,1",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M4",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac16,6",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M4 Pro",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac16,8",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M4 Max",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac16,5",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M4 Pro",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac16,6",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M4 Max",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac15,3",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M3",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac15,6",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M3 Pro",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac15,8",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M3 Pro",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac15,10",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M3 Max",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac15,7",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M3 Pro",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac15,9",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M3 Pro",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac15,11",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M3 Max",
      year: "Nov 2023",
      additional: ""
    },
    {
      key: "Mac14,5",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M2 Max",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,9",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M2 Max",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,6",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M2 Max",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,10",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M2 Max",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,7",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "M2",
      year: "2022",
      additional: ""
    },
    {
      key: "MacBookPro18,3",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M1 Pro",
      year: "2021",
      additional: ""
    },
    {
      key: "MacBookPro18,4",
      name: "MacBook Pro",
      size: "14-inch",
      processor: "M1 Max",
      year: "2021",
      additional: ""
    },
    {
      key: "MacBookPro18,1",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M1 Pro",
      year: "2021",
      additional: ""
    },
    {
      key: "MacBookPro18,2",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "M1 Max",
      year: "2021",
      additional: ""
    },
    {
      key: "MacBookPro17,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "M1",
      year: "2020",
      additional: ""
    },
    {
      key: "MacBookPro16,3",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2020",
      additional: "Two Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro16,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2020",
      additional: "Four Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro16,1",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacBookPro16,4",
      name: "MacBook Pro",
      size: "16-inch",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacBookPro15,3",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacBookPro15,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacBookPro15,1",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacBookPro15,4",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2019",
      additional: "Two Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro15,1",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "2018",
      additional: ""
    },
    {
      key: "MacBookPro15,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2018",
      additional: "Four Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro14,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2017",
      additional: "Two Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro14,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2017",
      additional: "Four Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro14,3",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "2017",
      additional: ""
    },
    {
      key: "MacBookPro13,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2016",
      additional: "Two Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro13,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "2016",
      additional: "Four Thunderbolt 3 ports"
    },
    {
      key: "MacBookPro13,3",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "2016",
      additional: ""
    },
    {
      key: "MacBookPro11,4",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Mid 2015",
      additional: ""
    },
    {
      key: "MacBookPro11,5",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Mid 2015",
      additional: ""
    },
    {
      key: "MacBookPro12,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Early 2015",
      additional: ""
    },
    {
      key: "MacBookPro11,2",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Late 2013",
      additional: ""
    },
    {
      key: "MacBookPro11,3",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Late 2013",
      additional: ""
    },
    {
      key: "MacBookPro11,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Late 2013",
      additional: ""
    },
    {
      key: "MacBookPro10,1",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Mid 2012",
      additional: ""
    },
    {
      key: "MacBookPro10,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Late 2012",
      additional: ""
    },
    {
      key: "MacBookPro9,1",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Mid 2012",
      additional: ""
    },
    {
      key: "MacBookPro9,2",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Mid 2012",
      additional: ""
    },
    {
      key: "MacBookPro8,3",
      name: "MacBook Pro",
      size: "17-inch",
      processor: "",
      year: "Early 2011",
      additional: ""
    },
    {
      key: "MacBookPro8,2",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Early 2011",
      additional: ""
    },
    {
      key: "MacBookPro8,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Early 2011",
      additional: ""
    },
    {
      key: "MacBookPro6,1",
      name: "MacBook Pro",
      size: "17-inch",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "MacBookPro6,2",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "MacBookPro7,1",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "MacBookPro5,2",
      name: "MacBook Pro",
      size: "17-inch",
      processor: "",
      year: "Early 2009",
      additional: ""
    },
    {
      key: "MacBookPro5,3",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Mid 2009",
      additional: ""
    },
    {
      key: "MacBookPro5,5",
      name: "MacBook Pro",
      size: "13-inch",
      processor: "",
      year: "Mid 2009",
      additional: ""
    },
    {
      key: "MacBookPro5,1",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Late 2008",
      additional: ""
    },
    {
      key: "MacBookPro4,1",
      name: "MacBook Pro",
      size: "15-inch",
      processor: "",
      year: "Early 2008",
      additional: ""
    },
    {
      key: "MacBook10,1",
      name: "MacBook",
      size: "12-inch",
      processor: "",
      year: "2017",
      additional: ""
    },
    {
      key: "MacBook9,1",
      name: "MacBook",
      size: "12-inch",
      processor: "",
      year: "Early 2016",
      additional: ""
    },
    {
      key: "MacBook8,1",
      name: "MacBook",
      size: "12-inch",
      processor: "",
      year: "Early 2015",
      additional: ""
    },
    {
      key: "MacBook7,1",
      name: "MacBook",
      size: "13-inch",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "MacBook6,1",
      name: "MacBook",
      size: "13-inch",
      processor: "",
      year: "Late 2009",
      additional: ""
    },
    {
      key: "MacBook5,2",
      name: "MacBook",
      size: "13-inch",
      processor: "",
      year: "Early 2009",
      additional: ""
    },
    {
      key: "Mac14,13",
      name: "Mac Studio",
      size: "",
      processor: "",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,14",
      name: "Mac Studio",
      size: "",
      processor: "",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac13,1",
      name: "Mac Studio",
      size: "",
      processor: "",
      year: "2022",
      additional: ""
    },
    {
      key: "Mac13,2",
      name: "Mac Studio",
      size: "",
      processor: "",
      year: "2022",
      additional: ""
    },
    {
      key: "Mac16,11",
      name: "Mac mini",
      size: "",
      processor: "M4 Pro",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac16,10",
      name: "Mac mini",
      size: "",
      processor: "M4",
      year: "2024",
      additional: ""
    },
    {
      key: "Mac14,3",
      name: "Mac mini",
      size: "",
      processor: "M2",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,12",
      name: "Mac mini",
      size: "",
      processor: "M2 Pro",
      year: "2023",
      additional: ""
    },
    {
      key: "Macmini9,1",
      name: "Mac mini",
      size: "",
      processor: "M1",
      year: "2020",
      additional: ""
    },
    {
      key: "Macmini8,1",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Late 2018",
      additional: ""
    },
    {
      key: "Macmini7,1",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Late 2014",
      additional: ""
    },
    {
      key: "Macmini6,1",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Late 2012",
      additional: ""
    },
    {
      key: "Macmini6,2",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Late 2012",
      additional: ""
    },
    {
      key: "Macmini5,1",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Mid 2011",
      additional: ""
    },
    {
      key: "Macmini5,2",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Mid 2011",
      additional: ""
    },
    {
      key: "Macmini4,1",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "Macmini3,1",
      name: "Mac mini",
      size: "",
      processor: "",
      year: "Early 2009",
      additional: ""
    },
    {
      key: "Mac16,3",
      name: "iMac",
      size: "24-inch",
      processor: "M4",
      year: "2024",
      additional: "Four ports"
    },
    {
      key: "Mac16,2",
      name: "iMac",
      size: "24-inch",
      processor: "M4",
      year: "2024",
      additional: "Two ports"
    },
    {
      key: "Mac15,5",
      name: "iMac",
      size: "24-inch",
      processor: "M3",
      year: "2023",
      additional: "Four ports"
    },
    {
      key: "Mac15,4",
      name: "iMac",
      size: "24-inch",
      processor: "M3",
      year: "2023",
      additional: "Two ports"
    },
    {
      key: "iMac21,1",
      name: "iMac",
      size: "24-inch",
      processor: "M1",
      year: "2021",
      additional: ""
    },
    {
      key: "iMac21,2",
      name: "iMac",
      size: "24-inch",
      processor: "M1",
      year: "2021",
      additional: ""
    },
    {
      key: "iMac20,1",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "2020",
      additional: "Retina 5K"
    },
    {
      key: "iMac20,2",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "2020",
      additional: "Retina 5K"
    },
    {
      key: "iMac19,1",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "2019",
      additional: "Retina 5K"
    },
    {
      key: "iMac19,2",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "2019",
      additional: "Retina 4K"
    },
    {
      key: "iMacPro1,1",
      name: "iMac Pro",
      size: "",
      processor: "",
      year: "2017",
      additional: ""
    },
    {
      key: "iMac18,3",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "2017",
      additional: "Retina 5K"
    },
    {
      key: "iMac18,2",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "2017",
      additional: "Retina 4K"
    },
    {
      key: "iMac18,1",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "2017",
      additional: ""
    },
    {
      key: "iMac17,1",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "Late 2015",
      additional: "Retina 5K"
    },
    {
      key: "iMac16,2",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Late 2015",
      additional: "Retina 4K"
    },
    {
      key: "iMac16,1",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Late 2015",
      additional: ""
    },
    {
      key: "iMac15,1",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "Late 2014",
      additional: "Retina 5K"
    },
    {
      key: "iMac14,4",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Mid 2014",
      additional: ""
    },
    {
      key: "iMac14,2",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "Late 2013",
      additional: ""
    },
    {
      key: "iMac14,1",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Late 2013",
      additional: ""
    },
    {
      key: "iMac13,2",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "Late 2012",
      additional: ""
    },
    {
      key: "iMac13,1",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Late 2012",
      additional: ""
    },
    {
      key: "iMac12,2",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "Mid 2011",
      additional: ""
    },
    {
      key: "iMac12,1",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Mid 2011",
      additional: ""
    },
    {
      key: "iMac11,3",
      name: "iMac",
      size: "27-inch",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "iMac11,2",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "iMac10,1",
      name: "iMac",
      size: "21.5-inch",
      processor: "",
      year: "Late 2009",
      additional: ""
    },
    {
      key: "iMac9,1",
      name: "iMac",
      size: "20-inch",
      processor: "",
      year: "Early 2009",
      additional: ""
    },
    {
      key: "Mac14,8",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "2023",
      additional: ""
    },
    {
      key: "Mac14,8",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "2023",
      additional: "Rack"
    },
    {
      key: "MacPro7,1",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "2019",
      additional: ""
    },
    {
      key: "MacPro7,1",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "2019",
      additional: "Rack"
    },
    {
      key: "MacPro6,1",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "Late 2013",
      additional: ""
    },
    {
      key: "MacPro5,1",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "Mid 2012",
      additional: ""
    },
    {
      key: "MacPro5,1",
      name: "Mac Pro Server",
      size: "",
      processor: "",
      year: "Mid 2012",
      additional: "Server"
    },
    {
      key: "MacPro5,1",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "Mid 2010",
      additional: ""
    },
    {
      key: "MacPro5,1",
      name: "Mac Pro Server",
      size: "",
      processor: "",
      year: "Mid 2010",
      additional: "Server"
    },
    {
      key: "MacPro4,1",
      name: "Mac Pro",
      size: "",
      processor: "",
      year: "Early 2009",
      additional: ""
    }
  ];
  const list = appleModelIds.filter((model) => model.key === key2);
  if (list.length === 0) {
    return {
      key: key2,
      model: "Apple",
      version: "Unknown"
    };
  }
  const features = [];
  if (list[0].size) {
    features.push(list[0].size);
  }
  if (list[0].processor) {
    features.push(list[0].processor);
  }
  if (list[0].year) {
    features.push(list[0].year);
  }
  if (list[0].additional) {
    features.push(list[0].additional);
  }
  return {
    key: key2,
    model: list[0].name,
    version: list[0].name + " (" + features.join(", ") + ")"
  };
}
function checkWebsite(url, timeout = 5e3) {
  const http = url.startsWith("https:") || url.indexOf(":443/") > 0 || url.indexOf(":8443/") > 0 ? require$$5$1 : require$$6$1;
  const t = Date.now();
  return new Promise((resolve) => {
    const request = http.get(url, function(res) {
      res.on("data", () => {
      });
      res.on("end", () => {
        resolve({
          url,
          statusCode: res.statusCode,
          message: res.statusMessage,
          time: Date.now() - t
        });
      });
    }).on("error", function(e) {
      resolve({
        url,
        statusCode: 404,
        message: e.message,
        time: Date.now() - t
      });
    }).setTimeout(timeout, () => {
      request.close();
      resolve({
        url,
        statusCode: 408,
        message: "Request Timeout",
        time: Date.now() - t
      });
    });
  });
}
function cleanString(str) {
  return str.replace(/To Be Filled By O.E.M./g, "");
}
function noop() {
}
util$j.toInt = toInt;
util$j.splitByNumber = splitByNumber;
util$j.execOptsWin = execOptsWin;
util$j.execOptsLinux = execOptsLinux;
util$j.getCodepage = getCodepage;
util$j.execWin = execWin;
util$j.isFunction = isFunction;
util$j.unique = unique;
util$j.sortByKey = sortByKey;
util$j.cores = cores;
util$j.getValue = getValue;
util$j.decodeEscapeSequence = decodeEscapeSequence;
util$j.parseDateTime = parseDateTime;
util$j.parseHead = parseHead;
util$j.findObjectByKey = findObjectByKey;
util$j.getWmic = getWmic;
util$j.wmic = wmic;
util$j.darwinXcodeExists = darwinXcodeExists;
util$j.getVboxmanage = getVboxmanage;
util$j.powerShell = powerShell;
util$j.powerShellStart = powerShellStart;
util$j.powerShellRelease = powerShellRelease;
util$j.execSafe = execSafe;
util$j.nanoSeconds = nanoSeconds;
util$j.countUniqueLines = countUniqueLines;
util$j.countLines = countLines;
util$j.noop = noop;
util$j.isRaspberry = isRaspberry;
util$j.isRaspbian = isRaspbian;
util$j.sanitizeShellString = sanitizeShellString;
util$j.isPrototypePolluted = isPrototypePolluted;
util$j.decodePiCpuinfo = decodePiCpuinfo;
util$j.getRpiGpu = getRpiGpu;
util$j.promiseAll = promiseAll;
util$j.promisify = promisify;
util$j.promisifySave = promisifySave;
util$j.smartMonToolsInstalled = smartMonToolsInstalled;
util$j.linuxVersion = linuxVersion;
util$j.plistParser = plistParser;
util$j.plistReader = plistReader;
util$j.stringObj = stringObj;
util$j.stringReplace = stringReplace;
util$j.stringToLower = stringToLower;
util$j.stringToString = stringToString;
util$j.stringSubstr = stringSubstr;
util$j.stringSubstring = stringSubstring;
util$j.stringTrim = stringTrim;
util$j.stringStartWith = stringStartWith;
util$j.mathMin = mathMin;
util$j.WINDIR = WINDIR;
util$j.getFilesInPath = getFilesInPath;
util$j.semverCompare = semverCompare;
util$j.getAppleModel = getAppleModel;
util$j.checkWebsite = checkWebsite;
util$j.cleanString = cleanString;
util$j.getPowershell = getPowershell;
var system$1 = {};
const fs$9 = require$$1$2;
const os$8 = os$a;
const util$h = util$j;
const exec$f = require$$1$1.exec;
const execSync$a = require$$1$1.execSync;
const execPromise = util$h.promisify(require$$1$1.exec);
let _platform$g = process.platform;
const _linux$f = _platform$g === "linux" || _platform$g === "android";
const _darwin$f = _platform$g === "darwin";
const _windows$g = _platform$g === "win32";
const _freebsd$e = _platform$g === "freebsd";
const _openbsd$e = _platform$g === "openbsd";
const _netbsd$e = _platform$g === "netbsd";
const _sunos$e = _platform$g === "sunos";
function system(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        manufacturer: "",
        model: "Computer",
        version: "",
        serial: "-",
        uuid: "-",
        sku: "-",
        virtual: false
      };
      if (_linux$f || _freebsd$e || _openbsd$e || _netbsd$e) {
        exec$f("export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL", function(error, stdout) {
          let lines = stdout.toString().split("\n");
          result2.manufacturer = cleanDefaults(util$h.getValue(lines, "manufacturer"));
          result2.model = cleanDefaults(util$h.getValue(lines, "product name"));
          result2.version = cleanDefaults(util$h.getValue(lines, "version"));
          result2.serial = cleanDefaults(util$h.getValue(lines, "serial number"));
          result2.uuid = cleanDefaults(util$h.getValue(lines, "uuid")).toLowerCase();
          result2.sku = cleanDefaults(util$h.getValue(lines, "sku number"));
          const cmd = `echo -n "product_name: "; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;
            echo -n "product_serial: "; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;
            echo -n "product_uuid: "; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;
            echo -n "product_version: "; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;
            echo -n "sys_vendor: "; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;
          try {
            lines = execSync$a(cmd, util$h.execOptsLinux).toString().split("\n");
            result2.manufacturer = cleanDefaults(result2.manufacturer === "" ? util$h.getValue(lines, "sys_vendor") : result2.manufacturer);
            result2.model = cleanDefaults(result2.model === "" ? util$h.getValue(lines, "product_name") : result2.model);
            result2.version = cleanDefaults(result2.version === "" ? util$h.getValue(lines, "product_version") : result2.version);
            result2.serial = cleanDefaults(result2.serial === "" ? util$h.getValue(lines, "product_serial") : result2.serial);
            result2.uuid = cleanDefaults(result2.uuid === "" ? util$h.getValue(lines, "product_uuid").toLowerCase() : result2.uuid);
          } catch (e) {
            util$h.noop();
          }
          if (!result2.serial) {
            result2.serial = "-";
          }
          if (!result2.manufacturer) {
            result2.manufacturer = "";
          }
          if (!result2.model) {
            result2.model = "Computer";
          }
          if (!result2.version) {
            result2.version = "";
          }
          if (!result2.sku) {
            result2.sku = "-";
          }
          if (result2.model.toLowerCase() === "virtualbox" || result2.model.toLowerCase() === "kvm" || result2.model.toLowerCase() === "virtual machine" || result2.model.toLowerCase() === "bochs" || result2.model.toLowerCase().startsWith("vmware") || result2.model.toLowerCase().startsWith("droplet")) {
            result2.virtual = true;
            switch (result2.model.toLowerCase()) {
              case "virtualbox":
                result2.virtualHost = "VirtualBox";
                break;
              case "vmware":
                result2.virtualHost = "VMware";
                break;
              case "kvm":
                result2.virtualHost = "KVM";
                break;
              case "bochs":
                result2.virtualHost = "bochs";
                break;
            }
          }
          if (result2.manufacturer.toLowerCase().startsWith("vmware") || result2.manufacturer.toLowerCase() === "xen") {
            result2.virtual = true;
            switch (result2.manufacturer.toLowerCase()) {
              case "vmware":
                result2.virtualHost = "VMware";
                break;
              case "xen":
                result2.virtualHost = "Xen";
                break;
            }
          }
          if (!result2.virtual) {
            try {
              const disksById = execSync$a("ls -1 /dev/disk/by-id/ 2>/dev/null", util$h.execOptsLinux).toString();
              if (disksById.indexOf("_QEMU_") >= 0) {
                result2.virtual = true;
                result2.virtualHost = "QEMU";
              }
              if (disksById.indexOf("_VBOX_") >= 0) {
                result2.virtual = true;
                result2.virtualHost = "VirtualBox";
              }
            } catch (e) {
              util$h.noop();
            }
          }
          if (!result2.virtual && (os$8.release().toLowerCase().indexOf("microsoft") >= 0 || os$8.release().toLowerCase().endsWith("wsl2"))) {
            const kernelVersion = parseFloat(os$8.release().toLowerCase());
            result2.virtual = true;
            result2.manufacturer = "Microsoft";
            result2.model = "WSL";
            result2.version = kernelVersion < 4.19 ? "1" : "2";
          }
          if ((_freebsd$e || _openbsd$e || _netbsd$e) && !result2.virtualHost) {
            try {
              const procInfo = execSync$a("dmidecode -t 4", util$h.execOptsLinux);
              const procLines = procInfo.toString().split("\n");
              const procManufacturer = util$h.getValue(procLines, "manufacturer", ":", true);
              switch (procManufacturer.toLowerCase()) {
                case "virtualbox":
                  result2.virtualHost = "VirtualBox";
                  break;
                case "vmware":
                  result2.virtualHost = "VMware";
                  break;
                case "kvm":
                  result2.virtualHost = "KVM";
                  break;
                case "bochs":
                  result2.virtualHost = "bochs";
                  break;
              }
            } catch (e) {
              util$h.noop();
            }
          }
          if (fs$9.existsSync("/.dockerenv") || fs$9.existsSync("/.dockerinit")) {
            result2.model = "Docker Container";
          }
          try {
            const stdout2 = execSync$a('dmesg 2>/dev/null | grep -iE "virtual|hypervisor" | grep -iE "vmware|qemu|kvm|xen" | grep -viE "Nested Virtualization|/virtual/"');
            let lines2 = stdout2.toString().split("\n");
            if (lines2.length > 0) {
              if (result2.model === "Computer") {
                result2.model = "Virtual machine";
              }
              result2.virtual = true;
              if (stdout2.toString().toLowerCase().indexOf("vmware") >= 0 && !result2.virtualHost) {
                result2.virtualHost = "VMware";
              }
              if (stdout2.toString().toLowerCase().indexOf("qemu") >= 0 && !result2.virtualHost) {
                result2.virtualHost = "QEMU";
              }
              if (stdout2.toString().toLowerCase().indexOf("xen") >= 0 && !result2.virtualHost) {
                result2.virtualHost = "Xen";
              }
              if (stdout2.toString().toLowerCase().indexOf("kvm") >= 0 && !result2.virtualHost) {
                result2.virtualHost = "KVM";
              }
            }
          } catch (e) {
            util$h.noop();
          }
          if (result2.manufacturer === "" && result2.model === "Computer" && result2.version === "") {
            fs$9.readFile("/proc/cpuinfo", function(error2, stdout2) {
              if (!error2) {
                let lines2 = stdout2.toString().split("\n");
                result2.model = util$h.getValue(lines2, "hardware", ":", true).toUpperCase();
                result2.version = util$h.getValue(lines2, "revision", ":", true).toLowerCase();
                result2.serial = util$h.getValue(lines2, "serial", ":", true);
                util$h.getValue(lines2, "model:", ":", true);
                if (util$h.isRaspberry(lines2)) {
                  const rPIRevision = util$h.decodePiCpuinfo(lines2);
                  result2.model = rPIRevision.model;
                  result2.version = rPIRevision.revisionCode;
                  result2.manufacturer = "Raspberry Pi Foundation";
                  result2.raspberry = {
                    manufacturer: rPIRevision.manufacturer,
                    processor: rPIRevision.processor,
                    type: rPIRevision.type,
                    revision: rPIRevision.revision
                  };
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      }
      if (_darwin$f) {
        exec$f("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
            const model = util$h.getAppleModel(util$h.getValue(lines, "model", "=", true));
            result2.manufacturer = util$h.getValue(lines, "manufacturer", "=", true);
            result2.model = model.key;
            result2.type = macOsChassisType(model.version);
            result2.version = model.version;
            result2.serial = util$h.getValue(lines, "ioplatformserialnumber", "=", true);
            result2.uuid = util$h.getValue(lines, "ioplatformuuid", "=", true).toLowerCase();
            result2.sku = util$h.getValue(lines, "board-id", "=", true) || util$h.getValue(lines, "target-sub-type", "=", true);
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$e) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$g) {
        try {
          util$h.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl").then((stdout, error) => {
            if (!error) {
              let lines = stdout.split("\r\n");
              result2.manufacturer = util$h.getValue(lines, "vendor", ":");
              result2.model = util$h.getValue(lines, "name", ":");
              result2.version = util$h.getValue(lines, "version", ":");
              result2.serial = util$h.getValue(lines, "identifyingnumber", ":");
              result2.uuid = util$h.getValue(lines, "uuid", ":").toLowerCase();
              const model = result2.model.toLowerCase();
              if (model === "virtualbox" || model === "kvm" || model === "virtual machine" || model === "bochs" || model.startsWith("vmware") || model.startsWith("qemu") || model.startsWith("parallels")) {
                result2.virtual = true;
                if (model.startsWith("virtualbox")) {
                  result2.virtualHost = "VirtualBox";
                }
                if (model.startsWith("vmware")) {
                  result2.virtualHost = "VMware";
                }
                if (model.startsWith("kvm")) {
                  result2.virtualHost = "KVM";
                }
                if (model.startsWith("bochs")) {
                  result2.virtualHost = "bochs";
                }
                if (model.startsWith("qemu")) {
                  result2.virtualHost = "KVM";
                }
                if (model.startsWith("parallels")) {
                  result2.virtualHost = "Parallels";
                }
              }
              const manufacturer = result2.manufacturer.toLowerCase();
              if (manufacturer.startsWith("vmware") || manufacturer.startsWith("qemu") || manufacturer === "xen" || manufacturer.startsWith("parallels")) {
                result2.virtual = true;
                if (manufacturer.startsWith("vmware")) {
                  result2.virtualHost = "VMware";
                }
                if (manufacturer.startsWith("xen")) {
                  result2.virtualHost = "Xen";
                }
                if (manufacturer.startsWith("qemu")) {
                  result2.virtualHost = "KVM";
                }
                if (manufacturer.startsWith("parallels")) {
                  result2.virtualHost = "Parallels";
                }
              }
              util$h.powerShell('Get-CimInstance MS_Systeminformation -Namespace "root/wmi" | select systemsku | fl ').then((stdout2, error2) => {
                if (!error2) {
                  let lines2 = stdout2.split("\r\n");
                  result2.sku = util$h.getValue(lines2, "systemsku", ":");
                }
                if (!result2.virtual) {
                  util$h.powerShell("Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion").then((stdout3, error3) => {
                    if (!error3) {
                      let lines2 = stdout3.toString();
                      if (lines2.indexOf("VRTUAL") >= 0 || lines2.indexOf("A M I ") >= 0 || lines2.indexOf("VirtualBox") >= 0 || lines2.indexOf("VMWare") >= 0 || lines2.indexOf("Xen") >= 0 || lines2.indexOf("Parallels") >= 0) {
                        result2.virtual = true;
                        if (lines2.indexOf("VirtualBox") >= 0 && !result2.virtualHost) {
                          result2.virtualHost = "VirtualBox";
                        }
                        if (lines2.indexOf("VMware") >= 0 && !result2.virtualHost) {
                          result2.virtualHost = "VMware";
                        }
                        if (lines2.indexOf("Xen") >= 0 && !result2.virtualHost) {
                          result2.virtualHost = "Xen";
                        }
                        if (lines2.indexOf("VRTUAL") >= 0 && !result2.virtualHost) {
                          result2.virtualHost = "Hyper-V";
                        }
                        if (lines2.indexOf("A M I") >= 0 && !result2.virtualHost) {
                          result2.virtualHost = "Virtual PC";
                        }
                        if (lines2.indexOf("Parallels") >= 0 && !result2.virtualHost) {
                          result2.virtualHost = "Parallels";
                        }
                      }
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    } else {
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    }
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
system$1.system = system;
function cleanDefaults(s) {
  const cmpStr = s.toLowerCase();
  if (cmpStr.indexOf("o.e.m.") === -1 && cmpStr.indexOf("default string") === -1 && cmpStr !== "default") {
    return s || "";
  }
  return "";
}
function bios(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        vendor: "",
        version: "",
        releaseDate: "",
        revision: ""
      };
      let cmd = "";
      if (_linux$f || _freebsd$e || _openbsd$e || _netbsd$e) {
        if (process.arch === "arm") {
          cmd = "cat /proc/cpuinfo | grep Serial";
        } else {
          cmd = "export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL";
        }
        exec$f(cmd, function(error, stdout) {
          let lines = stdout.toString().split("\n");
          result2.vendor = util$h.getValue(lines, "Vendor");
          result2.version = util$h.getValue(lines, "Version");
          let datetime = util$h.getValue(lines, "Release Date");
          result2.releaseDate = util$h.parseDateTime(datetime).date;
          result2.revision = util$h.getValue(lines, "BIOS Revision");
          result2.serial = util$h.getValue(lines, "SerialNumber");
          let language = util$h.getValue(lines, "Currently Installed Language").split("|")[0];
          if (language) {
            result2.language = language;
          }
          if (lines.length && stdout.toString().indexOf("Characteristics:") >= 0) {
            const features = [];
            lines.forEach((line) => {
              if (line.indexOf(" is supported") >= 0) {
                const feature = line.split(" is supported")[0].trim();
                features.push(feature);
              }
            });
            result2.features = features;
          }
          const cmd2 = `echo -n "bios_date: "; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;
            echo -n "bios_vendor: "; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;
            echo -n "bios_version: "; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;
          try {
            lines = execSync$a(cmd2, util$h.execOptsLinux).toString().split("\n");
            result2.vendor = !result2.vendor ? util$h.getValue(lines, "bios_vendor") : result2.vendor;
            result2.version = !result2.version ? util$h.getValue(lines, "bios_version") : result2.version;
            datetime = util$h.getValue(lines, "bios_date");
            result2.releaseDate = !result2.releaseDate ? util$h.parseDateTime(datetime).date : result2.releaseDate;
          } catch (e) {
            util$h.noop();
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$f) {
        result2.vendor = "Apple Inc.";
        exec$f(
          "system_profiler SPHardwareDataType -json",
          function(error, stdout) {
            try {
              const hardwareData = JSON.parse(stdout.toString());
              if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {
                let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;
                bootRomVersion = bootRomVersion ? bootRomVersion.split("(")[0].trim() : null;
                result2.version = bootRomVersion;
              }
            } catch (e) {
              util$h.noop();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        );
      }
      if (_sunos$e) {
        result2.vendor = "Sun Microsystems";
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$g) {
        try {
          util$h.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n="ReleaseDate";e={$_.ReleaseDate.ToString("yyyy-MM-dd")}},BuildNumber,SerialNumber,SMBIOSBIOSVersion | fl').then((stdout, error) => {
            if (!error) {
              let lines = stdout.toString().split("\r\n");
              const description = util$h.getValue(lines, "description", ":");
              const version2 = util$h.getValue(lines, "SMBIOSBIOSVersion", ":");
              if (description.indexOf(" Version ") !== -1) {
                result2.vendor = description.split(" Version ")[0].trim();
                result2.version = description.split(" Version ")[1].trim();
              } else if (description.indexOf(" Ver: ") !== -1) {
                result2.vendor = util$h.getValue(lines, "manufacturer", ":");
                result2.version = description.split(" Ver: ")[1].trim();
              } else {
                result2.vendor = util$h.getValue(lines, "manufacturer", ":");
                result2.version = version2 || util$h.getValue(lines, "version", ":");
              }
              result2.releaseDate = util$h.getValue(lines, "releasedate", ":");
              result2.revision = util$h.getValue(lines, "buildnumber", ":");
              result2.serial = cleanDefaults(util$h.getValue(lines, "serialnumber", ":"));
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
system$1.bios = bios;
function baseboard(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        manufacturer: "",
        model: "",
        version: "",
        serial: "-",
        assetTag: "-",
        memMax: null,
        memSlots: null
      };
      let cmd = "";
      if (_linux$f || _freebsd$e || _openbsd$e || _netbsd$e) {
        if (process.arch === "arm") {
          cmd = "cat /proc/cpuinfo | grep Serial";
        } else {
          cmd = "export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL";
        }
        const workload = [];
        workload.push(execPromise(cmd));
        workload.push(execPromise("export LC_ALL=C; dmidecode -t memory 2>/dev/null"));
        util$h.promiseAll(
          workload
        ).then((data) => {
          let lines = data.results[0] ? data.results[0].toString().split("\n") : [""];
          result2.manufacturer = cleanDefaults(util$h.getValue(lines, "Manufacturer"));
          result2.model = cleanDefaults(util$h.getValue(lines, "Product Name"));
          result2.version = cleanDefaults(util$h.getValue(lines, "Version"));
          result2.serial = cleanDefaults(util$h.getValue(lines, "Serial Number"));
          result2.assetTag = cleanDefaults(util$h.getValue(lines, "Asset Tag"));
          const cmd2 = `echo -n "board_asset_tag: "; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;
            echo -n "board_name: "; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;
            echo -n "board_serial: "; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;
            echo -n "board_vendor: "; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;
            echo -n "board_version: "; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;
          try {
            lines = execSync$a(cmd2, util$h.execOptsLinux).toString().split("\n");
            result2.manufacturer = cleanDefaults(!result2.manufacturer ? util$h.getValue(lines, "board_vendor") : result2.manufacturer);
            result2.model = cleanDefaults(!result2.model ? util$h.getValue(lines, "board_name") : result2.model);
            result2.version = cleanDefaults(!result2.version ? util$h.getValue(lines, "board_version") : result2.version);
            result2.serial = cleanDefaults(!result2.serial ? util$h.getValue(lines, "board_serial") : result2.serial);
            result2.assetTag = cleanDefaults(!result2.assetTag ? util$h.getValue(lines, "board_asset_tag") : result2.assetTag);
          } catch (e) {
            util$h.noop();
          }
          lines = data.results[1] ? data.results[1].toString().split("\n") : [""];
          result2.memMax = util$h.toInt(util$h.getValue(lines, "Maximum Capacity")) * 1024 * 1024 * 1024 || null;
          result2.memSlots = util$h.toInt(util$h.getValue(lines, "Number Of Devices")) || null;
          if (util$h.isRaspberry()) {
            const rpi = util$h.decodePiCpuinfo();
            result2.manufacturer = rpi.manufacturer;
            result2.model = "Raspberry Pi";
            result2.serial = rpi.serial;
            result2.version = rpi.type + " - " + rpi.revision;
            result2.memMax = os$8.totalmem();
            result2.memSlots = 0;
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$f) {
        const workload = [];
        workload.push(execPromise("ioreg -c IOPlatformExpertDevice -d 2"));
        workload.push(execPromise("system_profiler SPMemoryDataType"));
        util$h.promiseAll(
          workload
        ).then((data) => {
          let lines = data.results[0] ? data.results[0].toString().replace(/[<>"]/g, "").split("\n") : [""];
          result2.manufacturer = util$h.getValue(lines, "manufacturer", "=", true);
          result2.model = util$h.getValue(lines, "model", "=", true);
          result2.version = util$h.getValue(lines, "version", "=", true);
          result2.serial = util$h.getValue(lines, "ioplatformserialnumber", "=", true);
          result2.assetTag = util$h.getValue(lines, "board-id", "=", true);
          let devices = data.results[1] ? data.results[1].toString().split("        BANK ") : [""];
          if (devices.length === 1) {
            devices = data.results[1] ? data.results[1].toString().split("        DIMM") : [""];
          }
          devices.shift();
          result2.memSlots = devices.length;
          if (os$8.arch() === "arm64") {
            result2.memSlots = 0;
            result2.memMax = os$8.totalmem();
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$e) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$g) {
        try {
          const workload = [];
          const win10plus = parseInt(os$8.release()) >= 10;
          const maxCapacityAttribute = win10plus ? "MaxCapacityEx" : "MaxCapacity";
          workload.push(util$h.powerShell("Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl"));
          workload.push(util$h.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));
          util$h.promiseAll(
            workload
          ).then((data) => {
            let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [""];
            result2.manufacturer = cleanDefaults(util$h.getValue(lines, "manufacturer", ":"));
            result2.model = cleanDefaults(util$h.getValue(lines, "model", ":"));
            if (!result2.model) {
              result2.model = cleanDefaults(util$h.getValue(lines, "product", ":"));
            }
            result2.version = cleanDefaults(util$h.getValue(lines, "version", ":"));
            result2.serial = cleanDefaults(util$h.getValue(lines, "serialnumber", ":"));
            result2.assetTag = cleanDefaults(util$h.getValue(lines, "partnumber", ":"));
            if (!result2.assetTag) {
              result2.assetTag = cleanDefaults(util$h.getValue(lines, "sku", ":"));
            }
            lines = data.results[1] ? data.results[1].toString().split("\r\n") : [""];
            result2.memMax = util$h.toInt(util$h.getValue(lines, maxCapacityAttribute, ":")) * (win10plus ? 1024 : 1) || null;
            result2.memSlots = util$h.toInt(util$h.getValue(lines, "MemoryDevices", ":")) || null;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
system$1.baseboard = baseboard;
function macOsChassisType(model) {
  model = model.toLowerCase();
  if (model.indexOf("macbookair") >= 0 || model.indexOf("macbook air") >= 0) {
    return "Notebook";
  }
  if (model.indexOf("macbookpro") >= 0 || model.indexOf("macbook pro") >= 0) {
    return "Notebook";
  }
  if (model.indexOf("macbook") >= 0) {
    return "Notebook";
  }
  if (model.indexOf("macmini") >= 0 || model.indexOf("mac mini") >= 0) {
    return "Desktop";
  }
  if (model.indexOf("imac") >= 0) {
    return "Desktop";
  }
  if (model.indexOf("macstudio") >= 0 || model.indexOf("mac studio") >= 0) {
    return "Desktop";
  }
  if (model.indexOf("macpro") >= 0 || model.indexOf("mac pro") >= 0) {
    return "Tower";
  }
  return "Other";
}
function chassis(callback) {
  const chassisTypes = [
    "Other",
    "Unknown",
    "Desktop",
    "Low Profile Desktop",
    "Pizza Box",
    "Mini Tower",
    "Tower",
    "Portable",
    "Laptop",
    "Notebook",
    "Hand Held",
    "Docking Station",
    "All in One",
    "Sub Notebook",
    "Space-Saving",
    "Lunch Box",
    "Main System Chassis",
    "Expansion Chassis",
    "SubChassis",
    "Bus Expansion Chassis",
    "Peripheral Chassis",
    "Storage Chassis",
    "Rack Mount Chassis",
    "Sealed-Case PC",
    "Multi-System Chassis",
    "Compact PCI",
    "Advanced TCA",
    "Blade",
    "Blade Enclosure",
    "Tablet",
    "Convertible",
    "Detachable",
    "IoT Gateway ",
    "Embedded PC",
    "Mini PC",
    "Stick PC"
  ];
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        manufacturer: "",
        model: "",
        type: "",
        version: "",
        serial: "-",
        assetTag: "-",
        sku: ""
      };
      if (_linux$f || _freebsd$e || _openbsd$e || _netbsd$e) {
        const cmd = `echo -n "chassis_asset_tag: "; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;
            echo -n "chassis_serial: "; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;
            echo -n "chassis_type: "; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;
            echo -n "chassis_vendor: "; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;
            echo -n "chassis_version: "; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;
        exec$f(cmd, function(error, stdout) {
          let lines = stdout.toString().split("\n");
          result2.manufacturer = cleanDefaults(util$h.getValue(lines, "chassis_vendor"));
          const ctype = parseInt(util$h.getValue(lines, "chassis_type").replace(/\D/g, ""));
          result2.type = cleanDefaults(ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "");
          result2.version = cleanDefaults(util$h.getValue(lines, "chassis_version"));
          result2.serial = cleanDefaults(util$h.getValue(lines, "chassis_serial"));
          result2.assetTag = cleanDefaults(util$h.getValue(lines, "chassis_asset_tag"));
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$f) {
        exec$f("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
            const model = util$h.getAppleModel(util$h.getValue(lines, "model", "=", true));
            result2.manufacturer = util$h.getValue(lines, "manufacturer", "=", true);
            result2.model = model.key;
            result2.type = macOsChassisType(model.model);
            result2.version = model.version;
            result2.serial = util$h.getValue(lines, "ioplatformserialnumber", "=", true);
            result2.assetTag = util$h.getValue(lines, "board-id", "=", true) || util$h.getValue(lines, "target-type", "=", true);
            result2.sku = util$h.getValue(lines, "target-sub-type", "=", true);
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$e) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$g) {
        try {
          util$h.powerShell("Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU,SMBIOSAssetTag | fl").then((stdout, error) => {
            if (!error) {
              let lines = stdout.toString().split("\r\n");
              result2.manufacturer = cleanDefaults(util$h.getValue(lines, "manufacturer", ":"));
              result2.model = cleanDefaults(util$h.getValue(lines, "model", ":"));
              const ctype = parseInt(util$h.getValue(lines, "ChassisTypes", ":").replace(/\D/g, ""));
              result2.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
              result2.version = cleanDefaults(util$h.getValue(lines, "version", ":"));
              result2.serial = cleanDefaults(util$h.getValue(lines, "serialnumber", ":"));
              result2.assetTag = cleanDefaults(util$h.getValue(lines, "partnumber", ":"));
              if (!result2.assetTag) {
                result2.assetTag = cleanDefaults(util$h.getValue(lines, "SMBIOSAssetTag", ":"));
              }
              result2.sku = cleanDefaults(util$h.getValue(lines, "sku", ":"));
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
system$1.chassis = chassis;
var osinfo = {};
const os$7 = os$a;
const fs$8 = require$$1$2;
const util$g = util$j;
const exec$e = require$$1$1.exec;
const execSync$9 = require$$1$1.execSync;
let _platform$f = process.platform;
const _linux$e = _platform$f === "linux" || _platform$f === "android";
const _darwin$e = _platform$f === "darwin";
const _windows$f = _platform$f === "win32";
const _freebsd$d = _platform$f === "freebsd";
const _openbsd$d = _platform$f === "openbsd";
const _netbsd$d = _platform$f === "netbsd";
const _sunos$d = _platform$f === "sunos";
function time() {
  let t = (/* @__PURE__ */ new Date()).toString().split(" ");
  const result2 = {
    current: Date.now(),
    uptime: os$7.uptime(),
    timezone: t.length >= 7 ? t[5] : "",
    timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : t.length >= 7 ? t.slice(6).join(" ").replace(/\(/g, "").replace(/\)/g, "") : ""
  };
  if (_darwin$e || _linux$e) {
    try {
      const stdout = execSync$9("date +%Z && date +%z && ls -l /etc/localtime 2>/dev/null", util$g.execOptsLinux);
      const lines = stdout.toString().split(os$7.EOL);
      if (lines.length > 3 && !lines[0]) {
        lines.shift();
      }
      let timezone = lines[0] || "";
      if (timezone.startsWith("+") || timezone.startsWith("-")) {
        timezone = "GMT";
      }
      return {
        current: Date.now(),
        uptime: os$7.uptime(),
        timezone: lines[1] ? timezone + lines[1] : timezone,
        timezoneName: lines[2] && lines[2].indexOf("/zoneinfo/") > 0 ? lines[2].split("/zoneinfo/")[1] || "" : ""
      };
    } catch (e) {
      util$g.noop();
    }
  }
  return result2;
}
osinfo.time = time;
function getLogoFile(distro) {
  distro = distro || "";
  distro = distro.toLowerCase();
  let result2 = _platform$f;
  if (_windows$f) {
    result2 = "windows";
  } else if (distro.indexOf("mac os") !== -1 || distro.indexOf("macos") !== -1) {
    result2 = "apple";
  } else if (distro.indexOf("arch") !== -1) {
    result2 = "arch";
  } else if (distro.indexOf("cachy") !== -1) {
    result2 = "cachy";
  } else if (distro.indexOf("centos") !== -1) {
    result2 = "centos";
  } else if (distro.indexOf("coreos") !== -1) {
    result2 = "coreos";
  } else if (distro.indexOf("debian") !== -1) {
    result2 = "debian";
  } else if (distro.indexOf("deepin") !== -1) {
    result2 = "deepin";
  } else if (distro.indexOf("elementary") !== -1) {
    result2 = "elementary";
  } else if (distro.indexOf("endeavour") !== -1) {
    result2 = "endeavour";
  } else if (distro.indexOf("fedora") !== -1) {
    result2 = "fedora";
  } else if (distro.indexOf("gentoo") !== -1) {
    result2 = "gentoo";
  } else if (distro.indexOf("mageia") !== -1) {
    result2 = "mageia";
  } else if (distro.indexOf("mandriva") !== -1) {
    result2 = "mandriva";
  } else if (distro.indexOf("manjaro") !== -1) {
    result2 = "manjaro";
  } else if (distro.indexOf("mint") !== -1) {
    result2 = "mint";
  } else if (distro.indexOf("mx") !== -1) {
    result2 = "mx";
  } else if (distro.indexOf("openbsd") !== -1) {
    result2 = "openbsd";
  } else if (distro.indexOf("freebsd") !== -1) {
    result2 = "freebsd";
  } else if (distro.indexOf("opensuse") !== -1) {
    result2 = "opensuse";
  } else if (distro.indexOf("pclinuxos") !== -1) {
    result2 = "pclinuxos";
  } else if (distro.indexOf("puppy") !== -1) {
    result2 = "puppy";
  } else if (distro.indexOf("popos") !== -1) {
    result2 = "popos";
  } else if (distro.indexOf("raspbian") !== -1) {
    result2 = "raspbian";
  } else if (distro.indexOf("reactos") !== -1) {
    result2 = "reactos";
  } else if (distro.indexOf("redhat") !== -1) {
    result2 = "redhat";
  } else if (distro.indexOf("slackware") !== -1) {
    result2 = "slackware";
  } else if (distro.indexOf("sugar") !== -1) {
    result2 = "sugar";
  } else if (distro.indexOf("steam") !== -1) {
    result2 = "steam";
  } else if (distro.indexOf("suse") !== -1) {
    result2 = "suse";
  } else if (distro.indexOf("mate") !== -1) {
    result2 = "ubuntu-mate";
  } else if (distro.indexOf("lubuntu") !== -1) {
    result2 = "lubuntu";
  } else if (distro.indexOf("xubuntu") !== -1) {
    result2 = "xubuntu";
  } else if (distro.indexOf("ubuntu") !== -1) {
    result2 = "ubuntu";
  } else if (distro.indexOf("solaris") !== -1) {
    result2 = "solaris";
  } else if (distro.indexOf("tails") !== -1) {
    result2 = "tails";
  } else if (distro.indexOf("feren") !== -1) {
    result2 = "ferenos";
  } else if (distro.indexOf("robolinux") !== -1) {
    result2 = "robolinux";
  } else if (_linux$e && distro) {
    result2 = distro.toLowerCase().trim().replace(/\s+/g, "-");
  }
  return result2;
}
function getFQDN() {
  let fqdn = os$7.hostname;
  if (_linux$e || _darwin$e) {
    try {
      const stdout = execSync$9("hostname -f 2>/dev/null", util$g.execOptsLinux);
      fqdn = stdout.toString().split(os$7.EOL)[0];
    } catch (e) {
      util$g.noop();
    }
  }
  if (_freebsd$d || _openbsd$d || _netbsd$d) {
    try {
      const stdout = execSync$9("hostname 2>/dev/null");
      fqdn = stdout.toString().split(os$7.EOL)[0];
    } catch (e) {
      util$g.noop();
    }
  }
  if (_windows$f) {
    try {
      const stdout = execSync$9("echo %COMPUTERNAME%.%USERDNSDOMAIN%", util$g.execOptsWin);
      fqdn = stdout.toString().replace(".%USERDNSDOMAIN%", "").split(os$7.EOL)[0];
    } catch (e) {
      util$g.noop();
    }
  }
  return fqdn;
}
function osInfo(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        platform: _platform$f === "win32" ? "Windows" : _platform$f,
        distro: "unknown",
        release: "unknown",
        codename: "",
        kernel: os$7.release(),
        arch: os$7.arch(),
        hostname: os$7.hostname(),
        fqdn: getFQDN(),
        codepage: "",
        logofile: "",
        serial: "",
        build: "",
        servicepack: "",
        uefi: false
      };
      if (_linux$e) {
        exec$e("cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release", function(error, stdout) {
          let release = {};
          let lines = stdout.toString().split("\n");
          lines.forEach(function(line) {
            if (line.indexOf("=") !== -1) {
              release[line.split("=")[0].trim().toUpperCase()] = line.split("=")[1].trim();
            }
          });
          result2.distro = (release.DISTRIB_ID || release.NAME || "unknown").replace(/"/g, "");
          result2.logofile = getLogoFile(result2.distro);
          let releaseVersion = (release.VERSION || "").replace(/"/g, "");
          let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || "").replace(/"/g, "");
          const prettyName = (release.PRETTY_NAME || "").replace(/"/g, "");
          if (prettyName.indexOf(result2.distro + " ") === 0) {
            releaseVersion = prettyName.replace(result2.distro + " ", "").trim();
          }
          if (releaseVersion.indexOf("(") >= 0) {
            codename = releaseVersion.split("(")[1].replace(/[()]/g, "").trim();
            releaseVersion = releaseVersion.split("(")[0].trim();
          }
          result2.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || "unknown").replace(/"/g, "");
          result2.codename = codename;
          result2.codepage = util$g.getCodepage();
          result2.build = (release.BUILD_ID || "").replace(/"/g, "").trim();
          isUefiLinux().then((uefi) => {
            result2.uefi = uefi;
            uuid().then((data) => {
              result2.serial = data.os;
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          });
        });
      }
      if (_freebsd$d || _openbsd$d || _netbsd$d) {
        exec$e("sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml", function(error, stdout) {
          let lines = stdout.toString().split("\n");
          const distro = util$g.getValue(lines, "kern.ostype");
          const logofile = getLogoFile(distro);
          const release = util$g.getValue(lines, "kern.osrelease").split("-")[0];
          const serial = util$g.getValue(lines, "kern.uuid");
          const bootmethod = util$g.getValue(lines, "machdep.bootmethod");
          const uefiConf = stdout.toString().indexOf("<type>efi</type>") >= 0;
          const uefi = bootmethod ? bootmethod.toLowerCase().indexOf("uefi") >= 0 : uefiConf ? uefiConf : null;
          result2.distro = distro || result2.distro;
          result2.logofile = logofile || result2.logofile;
          result2.release = release || result2.release;
          result2.serial = serial || result2.serial;
          result2.codename = "";
          result2.codepage = util$g.getCodepage();
          result2.uefi = uefi || null;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$e) {
        exec$e("sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid", function(error, stdout) {
          let lines = stdout.toString().split("\n");
          result2.serial = util$g.getValue(lines, "kern.uuid");
          result2.distro = util$g.getValue(lines, "ProductName");
          result2.release = (util$g.getValue(lines, "ProductVersion", ":", true, true) + " " + util$g.getValue(lines, "ProductVersionExtra", ":", true, true)).trim();
          result2.build = util$g.getValue(lines, "BuildVersion");
          result2.logofile = getLogoFile(result2.distro);
          result2.codename = "macOS";
          result2.codename = result2.release.indexOf("10.4") > -1 ? "OS X Tiger" : result2.codename;
          result2.codename = result2.release.indexOf("10.5") > -1 ? "OS X Leopard" : result2.codename;
          result2.codename = result2.release.indexOf("10.6") > -1 ? "OS X Snow Leopard" : result2.codename;
          result2.codename = result2.release.indexOf("10.7") > -1 ? "OS X Lion" : result2.codename;
          result2.codename = result2.release.indexOf("10.8") > -1 ? "OS X Mountain Lion" : result2.codename;
          result2.codename = result2.release.indexOf("10.9") > -1 ? "OS X Mavericks" : result2.codename;
          result2.codename = result2.release.indexOf("10.10") > -1 ? "OS X Yosemite" : result2.codename;
          result2.codename = result2.release.indexOf("10.11") > -1 ? "OS X El Capitan" : result2.codename;
          result2.codename = result2.release.indexOf("10.12") > -1 ? "Sierra" : result2.codename;
          result2.codename = result2.release.indexOf("10.13") > -1 ? "High Sierra" : result2.codename;
          result2.codename = result2.release.indexOf("10.14") > -1 ? "Mojave" : result2.codename;
          result2.codename = result2.release.indexOf("10.15") > -1 ? "Catalina" : result2.codename;
          result2.codename = result2.release.startsWith("11.") ? "Big Sur" : result2.codename;
          result2.codename = result2.release.startsWith("12.") ? "Monterey" : result2.codename;
          result2.codename = result2.release.startsWith("13.") ? "Ventura" : result2.codename;
          result2.codename = result2.release.startsWith("14.") ? "Sonoma" : result2.codename;
          result2.codename = result2.release.startsWith("15.") ? "Sequoia" : result2.codename;
          result2.uefi = true;
          result2.codepage = util$g.getCodepage();
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$d) {
        result2.release = result2.kernel;
        exec$e("uname -o", function(error, stdout) {
          let lines = stdout.toString().split("\n");
          result2.distro = lines[0];
          result2.logofile = getLogoFile(result2.distro);
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$f) {
        result2.logofile = getLogoFile();
        result2.release = result2.kernel;
        try {
          const workload = [];
          workload.push(util$g.powerShell("Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl"));
          workload.push(util$g.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
          workload.push(util$g.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession"));
          util$g.promiseAll(
            workload
          ).then((data) => {
            let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [""];
            result2.distro = util$g.getValue(lines, "Caption", ":").trim();
            result2.serial = util$g.getValue(lines, "SerialNumber", ":").trim();
            result2.build = util$g.getValue(lines, "BuildNumber", ":").trim();
            result2.servicepack = util$g.getValue(lines, "ServicePackMajorVersion", ":").trim() + "." + util$g.getValue(lines, "ServicePackMinorVersion", ":").trim();
            result2.codepage = util$g.getCodepage();
            const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : "";
            result2.hypervisor = hyperv.indexOf("true") !== -1;
            const term = data.results[2] ? data.results[2].toString() : "";
            result2.remoteSession = term.toString().toLowerCase().indexOf("true") >= 0;
            isUefiWindows().then((uefi) => {
              result2.uefi = uefi;
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
osinfo.osInfo = osInfo;
function isUefiLinux() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      fs$8.stat("/sys/firmware/efi", function(err) {
        if (!err) {
          return resolve(true);
        } else {
          exec$e('dmesg | grep -E "EFI v"', function(error, stdout) {
            if (!error) {
              const lines = stdout.toString().split("\n");
              return resolve(lines.length > 0);
            }
            return resolve(false);
          });
        }
      });
    });
  });
}
function isUefiWindows() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      try {
        exec$e('findstr /C:"Detected boot environment" "%windir%\\Panther\\setupact.log"', util$g.execOptsWin, function(error, stdout) {
          if (!error) {
            const line = stdout.toString().split("\n\r")[0];
            return resolve(line.toLowerCase().indexOf("efi") >= 0);
          } else {
            exec$e("echo %firmware_type%", util$g.execOptsWin, function(error2, stdout2) {
              if (!error2) {
                const line = stdout2.toString() || "";
                return resolve(line.toLowerCase().indexOf("efi") >= 0);
              } else {
                return resolve(false);
              }
            });
          }
        });
      } catch (e) {
        return resolve(false);
      }
    });
  });
}
function versions(apps, callback) {
  let versionObject = {
    kernel: os$7.release(),
    apache: "",
    bash: "",
    bun: "",
    deno: "",
    docker: "",
    dotnet: "",
    fish: "",
    gcc: "",
    git: "",
    grunt: "",
    gulp: "",
    homebrew: "",
    java: "",
    mongodb: "",
    mysql: "",
    nginx: "",
    node: "",
    //process.versions.node,
    npm: "",
    openssl: "",
    perl: "",
    php: "",
    pip3: "",
    pip: "",
    pm2: "",
    postfix: "",
    postgresql: "",
    powershell: "",
    python3: "",
    python: "",
    redis: "",
    systemOpenssl: "",
    systemOpensslLib: "",
    tsc: "",
    v8: process.versions.v8,
    virtualbox: "",
    yarn: "",
    zsh: ""
  };
  function checkVersionParam(apps2) {
    if (apps2 === "*") {
      return {
        versions: versionObject,
        counter: 34
      };
    }
    if (!Array.isArray(apps2)) {
      apps2 = apps2.trim().toLowerCase().replace(/,+/g, "|").replace(/ /g, "|");
      apps2 = apps2.split("|");
      const result2 = {
        versions: {},
        counter: 0
      };
      apps2.forEach((el) => {
        if (el) {
          for (let key2 in versionObject) {
            if ({}.hasOwnProperty.call(versionObject, key2)) {
              if (key2.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result2.versions, key2)) {
                result2.versions[key2] = versionObject[key2];
                if (key2 === "openssl") {
                  result2.versions.systemOpenssl = "";
                  result2.versions.systemOpensslLib = "";
                }
                if (!result2.versions[key2]) {
                  result2.counter++;
                }
              }
            }
          }
        }
      });
      return result2;
    }
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (util$g.isFunction(apps) && !callback) {
        callback = apps;
        apps = "*";
      } else {
        apps = apps || "*";
        if (typeof apps !== "string") {
          if (callback) {
            callback({});
          }
          return resolve({});
        }
      }
      const appsObj = checkVersionParam(apps);
      let totalFunctions = appsObj.counter;
      let functionProcessed = /* @__PURE__ */ function() {
        return function() {
          if (--totalFunctions === 0) {
            if (callback) {
              callback(appsObj.versions);
            }
            resolve(appsObj.versions);
          }
        };
      }();
      let cmd = "";
      try {
        if ({}.hasOwnProperty.call(appsObj.versions, "openssl")) {
          appsObj.versions.openssl = process.versions.openssl;
          exec$e("openssl version", function(error, stdout) {
            if (!error) {
              let openssl_string = stdout.toString().split("\n")[0].trim();
              let openssl = openssl_string.split(" ");
              appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];
              appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : "openssl";
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "npm")) {
          exec$e("npm -v", function(error, stdout) {
            if (!error) {
              appsObj.versions.npm = stdout.toString().split("\n")[0];
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "pm2")) {
          cmd = "pm2";
          if (_windows$f) {
            cmd += ".cmd";
          }
          exec$e(`${cmd} -v`, function(error, stdout) {
            if (!error) {
              let pm2 = stdout.toString().split("\n")[0].trim();
              if (!pm2.startsWith("[PM2]")) {
                appsObj.versions.pm2 = pm2;
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "yarn")) {
          exec$e("yarn --version", function(error, stdout) {
            if (!error) {
              appsObj.versions.yarn = stdout.toString().split("\n")[0];
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "gulp")) {
          cmd = "gulp";
          if (_windows$f) {
            cmd += ".cmd";
          }
          exec$e(`${cmd} --version`, function(error, stdout) {
            if (!error) {
              const gulp = stdout.toString().split("\n")[0] || "";
              appsObj.versions.gulp = (gulp.toLowerCase().split("version")[1] || "").trim();
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "homebrew")) {
          cmd = "brew";
          exec$e(`${cmd} --version`, function(error, stdout) {
            if (!error) {
              const brew = stdout.toString().split("\n")[0] || "";
              appsObj.versions.homebrew = (brew.toLowerCase().split(" ")[1] || "").trim();
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "tsc")) {
          cmd = "tsc";
          if (_windows$f) {
            cmd += ".cmd";
          }
          exec$e(`${cmd} --version`, function(error, stdout) {
            if (!error) {
              const tsc = stdout.toString().split("\n")[0] || "";
              appsObj.versions.tsc = (tsc.toLowerCase().split("version")[1] || "").trim();
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "grunt")) {
          cmd = "grunt";
          if (_windows$f) {
            cmd += ".cmd";
          }
          exec$e(`${cmd} --version`, function(error, stdout) {
            if (!error) {
              const grunt = stdout.toString().split("\n")[0] || "";
              appsObj.versions.grunt = (grunt.toLowerCase().split("cli v")[1] || "").trim();
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "git")) {
          if (_darwin$e) {
            const gitHomebrewExists = fs$8.existsSync("/usr/local/Cellar/git") || fs$8.existsSync("/opt/homebrew/bin/git");
            if (util$g.darwinXcodeExists() || gitHomebrewExists) {
              exec$e("git --version", function(error, stdout) {
                if (!error) {
                  let git = stdout.toString().split("\n")[0] || "";
                  git = (git.toLowerCase().split("version")[1] || "").trim();
                  appsObj.versions.git = (git.split(" ")[0] || "").trim();
                }
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          } else {
            exec$e("git --version", function(error, stdout) {
              if (!error) {
                let git = stdout.toString().split("\n")[0] || "";
                git = (git.toLowerCase().split("version")[1] || "").trim();
                appsObj.versions.git = (git.split(" ")[0] || "").trim();
              }
              functionProcessed();
            });
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "apache")) {
          exec$e("apachectl -v 2>&1", function(error, stdout) {
            if (!error) {
              const apache = (stdout.toString().split("\n")[0] || "").split(":");
              appsObj.versions.apache = apache.length > 1 ? apache[1].replace("Apache", "").replace("/", "").split("(")[0].trim() : "";
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "nginx")) {
          exec$e("nginx -v 2>&1", function(error, stdout) {
            if (!error) {
              const nginx = stdout.toString().split("\n")[0] || "";
              appsObj.versions.nginx = (nginx.toLowerCase().split("/")[1] || "").trim();
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "mysql")) {
          exec$e("mysql -V", function(error, stdout) {
            if (!error) {
              let mysql = stdout.toString().split("\n")[0] || "";
              mysql = mysql.toLowerCase();
              if (mysql.indexOf(",") > -1) {
                mysql = (mysql.split(",")[0] || "").trim();
                const parts = mysql.split(" ");
                appsObj.versions.mysql = (parts[parts.length - 1] || "").trim();
              } else {
                if (mysql.indexOf(" ver ") > -1) {
                  mysql = mysql.split(" ver ")[1];
                  appsObj.versions.mysql = mysql.split(" ")[0];
                }
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "php")) {
          exec$e("php -v", function(error, stdout) {
            if (!error) {
              const php = stdout.toString().split("\n")[0] || "";
              let parts = php.split("(");
              if (parts[0].indexOf("-")) {
                parts = parts[0].split("-");
              }
              appsObj.versions.php = parts[0].replace(/[^0-9.]/g, "");
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "redis")) {
          exec$e("redis-server --version", function(error, stdout) {
            if (!error) {
              const redis = stdout.toString().split("\n")[0] || "";
              const parts = redis.split(" ");
              appsObj.versions.redis = util$g.getValue(parts, "v", "=", true);
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "docker")) {
          exec$e("docker --version", function(error, stdout) {
            if (!error) {
              const docker2 = stdout.toString().split("\n")[0] || "";
              const parts = docker2.split(" ");
              appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(",") ? parts[2].slice(0, -1) : "";
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "postfix")) {
          exec$e("postconf -d | grep mail_version", function(error, stdout) {
            if (!error) {
              const postfix = stdout.toString().split("\n") || [];
              appsObj.versions.postfix = util$g.getValue(postfix, "mail_version", "=", true);
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "mongodb")) {
          exec$e("mongod --version", function(error, stdout) {
            if (!error) {
              const mongodb = stdout.toString().split("\n")[0] || "";
              appsObj.versions.mongodb = (mongodb.toLowerCase().split(",")[0] || "").replace(/[^0-9.]/g, "");
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "postgresql")) {
          if (_linux$e) {
            exec$e("locate bin/postgres", function(error, stdout) {
              if (!error) {
                const postgresqlBin = stdout.toString().split("\n").sort();
                if (postgresqlBin.length) {
                  exec$e(postgresqlBin[postgresqlBin.length - 1] + " -V", function(error2, stdout2) {
                    if (!error2) {
                      const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec$e("psql -V", function(error2, stdout2) {
                  if (!error2) {
                    const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                    appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                    appsObj.versions.postgresql = appsObj.versions.postgresql.split("-")[0];
                  }
                  functionProcessed();
                });
              }
            });
          } else {
            if (_windows$f) {
              util$g.powerShell("Get-CimInstance Win32_Service | select caption | fl").then((stdout) => {
                let serviceSections = stdout.split(/\n\s*\n/);
                serviceSections.forEach((item) => {
                  if (item.trim() !== "") {
                    let lines = item.trim().split("\r\n");
                    let srvCaption = util$g.getValue(lines, "caption", ":", true).toLowerCase();
                    if (srvCaption.indexOf("postgresql") > -1) {
                      const parts = srvCaption.split(" server ");
                      if (parts.length > 1) {
                        appsObj.versions.postgresql = parts[1];
                      }
                    }
                  }
                });
                functionProcessed();
              });
            } else {
              exec$e("postgres -V", function(error, stdout) {
                if (!error) {
                  const postgresql = stdout.toString().split("\n")[0].split(" ") || [];
                  appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                } else {
                  exec$e("pg_config --version", function(error2, stdout2) {
                    if (!error2) {
                      const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                    }
                  });
                }
                functionProcessed();
              });
            }
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "perl")) {
          exec$e("perl -v", function(error, stdout) {
            if (!error) {
              const perl = stdout.toString().split("\n") || "";
              while (perl.length > 0 && perl[0].trim() === "") {
                perl.shift();
              }
              if (perl.length > 0) {
                appsObj.versions.perl = perl[0].split("(").pop().split(")")[0].replace("v", "");
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "python")) {
          if (_darwin$e) {
            try {
              const stdout = execSync$9("sw_vers");
              const lines = stdout.toString().split("\n");
              const osVersion = util$g.getValue(lines, "ProductVersion", ":");
              const gitHomebrewExists1 = fs$8.existsSync("/usr/local/Cellar/python");
              const gitHomebrewExists2 = fs$8.existsSync("/opt/homebrew/bin/python");
              if (util$g.darwinXcodeExists() && util$g.semverCompare("12.0.1", osVersion) < 0 || gitHomebrewExists1 || gitHomebrewExists2) {
                const cmd2 = gitHomebrewExists1 ? "/usr/local/Cellar/python -V 2>&1" : gitHomebrewExists2 ? "/opt/homebrew/bin/python -V 2>&1" : "python -V 2>&1";
                exec$e(cmd2, function(error, stdout2) {
                  if (!error) {
                    const python = stdout2.toString().split("\n")[0] || "";
                    appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } catch (e) {
              functionProcessed();
            }
          } else {
            exec$e("python -V 2>&1", function(error, stdout) {
              if (!error) {
                const python = stdout.toString().split("\n")[0] || "";
                appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
              }
              functionProcessed();
            });
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "python3")) {
          if (_darwin$e) {
            const gitHomebrewExists = fs$8.existsSync("/usr/local/Cellar/python3") || fs$8.existsSync("/opt/homebrew/bin/python3");
            if (util$g.darwinXcodeExists() || gitHomebrewExists) {
              exec$e("python3 -V 2>&1", function(error, stdout) {
                if (!error) {
                  const python = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          } else {
            exec$e("python3 -V 2>&1", function(error, stdout) {
              if (!error) {
                const python = stdout.toString().split("\n")[0] || "";
                appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
              }
              functionProcessed();
            });
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "pip")) {
          if (_darwin$e) {
            const gitHomebrewExists = fs$8.existsSync("/usr/local/Cellar/pip") || fs$8.existsSync("/opt/homebrew/bin/pip");
            if (util$g.darwinXcodeExists() || gitHomebrewExists) {
              exec$e("pip -V 2>&1", function(error, stdout) {
                if (!error) {
                  const pip = stdout.toString().split("\n")[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          } else {
            exec$e("pip -V 2>&1", function(error, stdout) {
              if (!error) {
                const pip = stdout.toString().split("\n")[0] || "";
                const parts = pip.split(" ");
                appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
              }
              functionProcessed();
            });
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "pip3")) {
          if (_darwin$e) {
            const gitHomebrewExists = fs$8.existsSync("/usr/local/Cellar/pip3") || fs$8.existsSync("/opt/homebrew/bin/pip3");
            if (util$g.darwinXcodeExists() || gitHomebrewExists) {
              exec$e("pip3 -V 2>&1", function(error, stdout) {
                if (!error) {
                  const pip = stdout.toString().split("\n")[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          } else {
            exec$e("pip3 -V 2>&1", function(error, stdout) {
              if (!error) {
                const pip = stdout.toString().split("\n")[0] || "";
                const parts = pip.split(" ");
                appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
              }
              functionProcessed();
            });
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "java")) {
          if (_darwin$e) {
            exec$e("/usr/libexec/java_home -V 2>&1", function(error, stdout) {
              if (!error && stdout.toString().toLowerCase().indexOf("no java runtime") === -1) {
                exec$e("java -version 2>&1", function(error2, stdout2) {
                  if (!error2) {
                    const java = stdout2.toString().split("\n")[0] || "";
                    const parts = java.split('"');
                    appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            });
          } else {
            exec$e("java -version 2>&1", function(error, stdout) {
              if (!error) {
                const java = stdout.toString().split("\n")[0] || "";
                const parts = java.split('"');
                appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
              }
              functionProcessed();
            });
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "gcc")) {
          if (_darwin$e && util$g.darwinXcodeExists() || !_darwin$e) {
            exec$e("gcc -dumpversion", function(error, stdout) {
              if (!error) {
                appsObj.versions.gcc = stdout.toString().split("\n")[0].trim() || "";
              }
              if (appsObj.versions.gcc.indexOf(".") > -1) {
                functionProcessed();
              } else {
                exec$e("gcc --version", function(error2, stdout2) {
                  if (!error2) {
                    const gcc = stdout2.toString().split("\n")[0].trim();
                    if (gcc.indexOf("gcc") > -1 && gcc.indexOf(")") > -1) {
                      const parts = gcc.split(")");
                      appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;
                    }
                  }
                  functionProcessed();
                });
              }
            });
          } else {
            functionProcessed();
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "virtualbox")) {
          exec$e(util$g.getVboxmanage() + " -v 2>&1", function(error, stdout) {
            if (!error) {
              const vbox = stdout.toString().split("\n")[0] || "";
              const parts = vbox.split("r");
              appsObj.versions.virtualbox = parts[0];
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "bash")) {
          exec$e("bash --version", function(error, stdout) {
            if (!error) {
              const line = stdout.toString().split("\n")[0];
              const parts = line.split(" version ");
              if (parts.length > 1) {
                appsObj.versions.bash = parts[1].split(" ")[0].split("(")[0];
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "zsh")) {
          exec$e("zsh --version", function(error, stdout) {
            if (!error) {
              const line = stdout.toString().split("\n")[0];
              const parts = line.split("zsh ");
              if (parts.length > 1) {
                appsObj.versions.zsh = parts[1].split(" ")[0];
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "fish")) {
          exec$e("fish --version", function(error, stdout) {
            if (!error) {
              const line = stdout.toString().split("\n")[0];
              const parts = line.split(" version ");
              if (parts.length > 1) {
                appsObj.versions.fish = parts[1].split(" ")[0];
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "bun")) {
          exec$e("bun -v", function(error, stdout) {
            if (!error) {
              const line = stdout.toString().split("\n")[0].trim();
              appsObj.versions.bun = line;
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "deno")) {
          exec$e("deno -v", function(error, stdout) {
            if (!error) {
              const line = stdout.toString().split("\n")[0].trim();
              const parts = line.split(" ");
              if (parts.length > 1) {
                appsObj.versions.deno = parts[1];
              }
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "node")) {
          exec$e("node -v", function(error, stdout) {
            if (!error) {
              let line = stdout.toString().split("\n")[0].trim();
              if (line.startsWith("v")) {
                line = line.slice(1);
              }
              appsObj.versions.node = line;
            }
            functionProcessed();
          });
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "powershell")) {
          if (_windows$f) {
            util$g.powerShell("$PSVersionTable").then((stdout) => {
              const lines = stdout.toString().toLowerCase().split("\n").map((line) => line.replace(/ +/g, " ").replace(/ +/g, ":"));
              appsObj.versions.powershell = util$g.getValue(lines, "psversion");
              functionProcessed();
            });
          } else {
            functionProcessed();
          }
        }
        if ({}.hasOwnProperty.call(appsObj.versions, "dotnet")) {
          if (_windows$f) {
            util$g.powerShell('gci "HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match "^(?!S)\\p{L}"} | select PSChildName, Version, Release').then((stdout) => {
              const lines = stdout.toString().split("\r\n");
              let dotnet = "";
              lines.forEach((line) => {
                line = line.replace(/ +/g, " ");
                const parts = line.split(" ");
                dotnet = dotnet || (parts[0].toLowerCase().startsWith("client") && parts.length > 2 ? parts[1].trim() : parts[0].toLowerCase().startsWith("full") && parts.length > 2 ? parts[1].trim() : "");
              });
              appsObj.versions.dotnet = dotnet.trim();
              functionProcessed();
            });
          } else {
            functionProcessed();
          }
        }
      } catch (e) {
        if (callback) {
          callback(appsObj.versions);
        }
        resolve(appsObj.versions);
      }
    });
  });
}
osinfo.versions = versions;
function shell(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (_windows$f) {
        try {
          const result2 = "CMD";
          util$g.powerShell(`Get-CimInstance -className win32_process | where-object {$_.ProcessId -eq ${process.ppid} } | select Name`).then((stdout) => {
            let result3 = "CMD";
            if (stdout) {
              if (stdout.toString().toLowerCase().indexOf("powershell") >= 0) {
                result3 = "PowerShell";
              }
            }
            if (callback) {
              callback(result3);
            }
            resolve(result3);
          });
        } catch {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      } else {
        let result2 = "";
        exec$e("echo $SHELL", function(error, stdout) {
          if (!error) {
            result2 = stdout.toString().split("\n")[0];
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
    });
  });
}
osinfo.shell = shell;
function getUniqueMacAdresses() {
  let macs = [];
  try {
    const ifaces = os$7.networkInterfaces();
    for (let dev in ifaces) {
      if ({}.hasOwnProperty.call(ifaces, dev)) {
        ifaces[dev].forEach(function(details) {
          if (details && details.mac && details.mac !== "00:00:00:00:00:00") {
            const mac = details.mac.toLowerCase();
            if (macs.indexOf(mac) === -1) {
              macs.push(mac);
            }
          }
        });
      }
    }
    macs = macs.sort(function(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    });
  } catch (e) {
    macs.push("00:00:00:00:00:00");
  }
  return macs;
}
function uuid(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        os: "",
        hardware: "",
        macs: getUniqueMacAdresses()
      };
      let parts;
      if (_darwin$e) {
        exec$e("system_profiler SPHardwareDataType -json", function(error, stdout) {
          if (!error) {
            try {
              const jsonObj = JSON.parse(stdout.toString());
              if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {
                const spHardware = jsonObj.SPHardwareDataType[0];
                result2.os = spHardware.platform_UUID.toLowerCase();
                result2.hardware = spHardware.serial_number;
              }
            } catch (e) {
              util$g.noop();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_linux$e) {
        const cmd = `echo -n "os: "; cat /var/lib/dbus/machine-id 2> /dev/null ||
cat /etc/machine-id 2> /dev/null; echo;
echo -n "hardware: "; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;
        exec$e(cmd, function(error, stdout) {
          const lines = stdout.toString().split("\n");
          result2.os = util$g.getValue(lines, "os").toLowerCase();
          result2.hardware = util$g.getValue(lines, "hardware").toLowerCase();
          if (!result2.hardware) {
            const lines2 = fs$8.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
            const serial = util$g.getValue(lines2, "serial");
            result2.hardware = serial || "";
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_freebsd$d || _openbsd$d || _netbsd$d) {
        exec$e("sysctl -i kern.hostid kern.hostuuid", function(error, stdout) {
          const lines = stdout.toString().split("\n");
          result2.os = util$g.getValue(lines, "kern.hostid", ":").toLowerCase();
          result2.hardware = util$g.getValue(lines, "kern.hostuuid", ":").toLowerCase();
          if (result2.os.indexOf("unknown") >= 0) {
            result2.os = "";
          }
          if (result2.hardware.indexOf("unknown") >= 0) {
            result2.hardware = "";
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$f) {
        let sysdir = "%windir%\\System32";
        if (process.arch === "ia32" && Object.prototype.hasOwnProperty.call(process.env, "PROCESSOR_ARCHITEW6432")) {
          sysdir = "%windir%\\sysnative\\cmd.exe /c %windir%\\System32";
        }
        util$g.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl").then((stdout) => {
          let lines = stdout.split("\r\n");
          result2.hardware = util$g.getValue(lines, "uuid", ":").toLowerCase();
          exec$e(`${sysdir}\\reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography" /v MachineGuid`, util$g.execOptsWin, function(error, stdout2) {
            parts = stdout2.toString().split("\n\r")[0].split("REG_SZ");
            result2.os = parts.length > 1 ? parts[1].replace(/\r+|\n+|\s+/ig, "").toLowerCase() : "";
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        });
      }
    });
  });
}
osinfo.uuid = uuid;
var cpu$1 = {};
const os$6 = os$a;
const exec$d = require$$1$1.exec;
const execSync$8 = require$$1$1.execSync;
const fs$7 = require$$1$2;
const util$f = util$j;
let _platform$e = process.platform;
const _linux$d = _platform$e === "linux" || _platform$e === "android";
const _darwin$d = _platform$e === "darwin";
const _windows$e = _platform$e === "win32";
const _freebsd$c = _platform$e === "freebsd";
const _openbsd$c = _platform$e === "openbsd";
const _netbsd$c = _platform$e === "netbsd";
const _sunos$c = _platform$e === "sunos";
let _cpu_speed = 0;
let _current_cpu = {
  user: 0,
  nice: 0,
  system: 0,
  idle: 0,
  irq: 0,
  steal: 0,
  guest: 0,
  load: 0,
  tick: 0,
  ms: 0,
  currentLoad: 0,
  currentLoadUser: 0,
  currentLoadSystem: 0,
  currentLoadNice: 0,
  currentLoadIdle: 0,
  currentLoadIrq: 0,
  currentLoadSteal: 0,
  currentLoadGuest: 0,
  rawCurrentLoad: 0,
  rawCurrentLoadUser: 0,
  rawCurrentLoadSystem: 0,
  rawCurrentLoadNice: 0,
  rawCurrentLoadIdle: 0,
  rawCurrentLoadIrq: 0,
  rawCurrentLoadSteal: 0,
  rawCurrentLoadGuest: 0
};
let _cpus = [];
let _corecount = 0;
const AMDBaseFrequencies = {
  "8346": "1.8",
  "8347": "1.9",
  "8350": "2.0",
  "8354": "2.2",
  "8356|SE": "2.4",
  "8356": "2.3",
  "8360": "2.5",
  "2372": "2.1",
  "2373": "2.1",
  "2374": "2.2",
  "2376": "2.3",
  "2377": "2.3",
  "2378": "2.4",
  "2379": "2.4",
  "2380": "2.5",
  "2381": "2.5",
  "2382": "2.6",
  "2384": "2.7",
  "2386": "2.8",
  "2387": "2.8",
  "2389": "2.9",
  "2393": "3.1",
  "8374": "2.2",
  "8376": "2.3",
  "8378": "2.4",
  "8379": "2.4",
  "8380": "2.5",
  "8381": "2.5",
  "8382": "2.6",
  "8384": "2.7",
  "8386": "2.8",
  "8387": "2.8",
  "8389": "2.9",
  "8393": "3.1",
  "2419EE": "1.8",
  "2423HE": "2.0",
  "2425HE": "2.1",
  "2427": "2.2",
  "2431": "2.4",
  "2435": "2.6",
  "2439SE": "2.8",
  "8425HE": "2.1",
  "8431": "2.4",
  "8435": "2.6",
  "8439SE": "2.8",
  "4122": "2.2",
  "4130": "2.6",
  "4162EE": "1.7",
  "4164EE": "1.8",
  "4170HE": "2.1",
  "4174HE": "2.3",
  "4176HE": "2.4",
  "4180": "2.6",
  "4184": "2.8",
  "6124HE": "1.8",
  "6128HE": "2.0",
  "6132HE": "2.2",
  "6128": "2.0",
  "6134": "2.3",
  "6136": "2.4",
  "6140": "2.6",
  "6164HE": "1.7",
  "6166HE": "1.8",
  "6168": "1.9",
  "6172": "2.1",
  "6174": "2.2",
  "6176": "2.3",
  "6176SE": "2.3",
  "6180SE": "2.5",
  "3250": "2.5",
  "3260": "2.7",
  "3280": "2.4",
  "4226": "2.7",
  "4228": "2.8",
  "4230": "2.9",
  "4234": "3.1",
  "4238": "3.3",
  "4240": "3.4",
  "4256": "1.6",
  "4274": "2.5",
  "4276": "2.6",
  "4280": "2.8",
  "4284": "3.0",
  "6204": "3.3",
  "6212": "2.6",
  "6220": "3.0",
  "6234": "2.4",
  "6238": "2.6",
  "6262HE": "1.6",
  "6272": "2.1",
  "6274": "2.2",
  "6276": "2.3",
  "6278": "2.4",
  "6282SE": "2.6",
  "6284SE": "2.7",
  "6308": "3.5",
  "6320": "2.8",
  "6328": "3.2",
  "6338P": "2.3",
  "6344": "2.6",
  "6348": "2.8",
  "6366": "1.8",
  "6370P": "2.0",
  "6376": "2.3",
  "6378": "2.4",
  "6380": "2.5",
  "6386": "2.8",
  "FX|4100": "3.6",
  "FX|4120": "3.9",
  "FX|4130": "3.8",
  "FX|4150": "3.8",
  "FX|4170": "4.2",
  "FX|6100": "3.3",
  "FX|6120": "3.6",
  "FX|6130": "3.6",
  "FX|6200": "3.8",
  "FX|8100": "2.8",
  "FX|8120": "3.1",
  "FX|8140": "3.2",
  "FX|8150": "3.6",
  "FX|8170": "3.9",
  "FX|4300": "3.8",
  "FX|4320": "4.0",
  "FX|4350": "4.2",
  "FX|6300": "3.5",
  "FX|6350": "3.9",
  "FX|8300": "3.3",
  "FX|8310": "3.4",
  "FX|8320": "3.5",
  "FX|8350": "4.0",
  "FX|8370": "4.0",
  "FX|9370": "4.4",
  "FX|9590": "4.7",
  "FX|8320E": "3.2",
  "FX|8370E": "3.3",
  // ZEN Desktop CPUs
  "1200": "3.1",
  "Pro 1200": "3.1",
  "1300X": "3.5",
  "Pro 1300": "3.5",
  "1400": "3.2",
  "1500X": "3.5",
  "Pro 1500": "3.5",
  "1600": "3.2",
  "1600X": "3.6",
  "Pro 1600": "3.2",
  "1700": "3.0",
  "Pro 1700": "3.0",
  "1700X": "3.4",
  "Pro 1700X": "3.4",
  "1800X": "3.6",
  "1900X": "3.8",
  "1920": "3.2",
  "1920X": "3.5",
  "1950X": "3.4",
  // ZEN Desktop APUs
  "200GE": "3.2",
  "Pro 200GE": "3.2",
  "220GE": "3.4",
  "240GE": "3.5",
  "3000G": "3.5",
  "300GE": "3.4",
  "3050GE": "3.4",
  "2200G": "3.5",
  "Pro 2200G": "3.5",
  "2200GE": "3.2",
  "Pro 2200GE": "3.2",
  "2400G": "3.6",
  "Pro 2400G": "3.6",
  "2400GE": "3.2",
  "Pro 2400GE": "3.2",
  // ZEN Mobile APUs
  "Pro 200U": "2.3",
  "300U": "2.4",
  "2200U": "2.5",
  "3200U": "2.6",
  "2300U": "2.0",
  "Pro 2300U": "2.0",
  "2500U": "2.0",
  "Pro 2500U": "2.2",
  "2600H": "3.2",
  "2700U": "2.0",
  "Pro 2700U": "2.2",
  "2800H": "3.3",
  // ZEN Server Processors
  "7351": "2.4",
  "7351P": "2.4",
  "7401": "2.0",
  "7401P": "2.0",
  "7551P": "2.0",
  "7551": "2.0",
  "7251": "2.1",
  "7261": "2.5",
  "7281": "2.1",
  "7301": "2.2",
  "7371": "3.1",
  "7451": "2.3",
  "7501": "2.0",
  "7571": "2.2",
  "7601": "2.2",
  // ZEN Embedded Processors
  "V1500B": "2.2",
  "V1780B": "3.35",
  "V1202B": "2.3",
  "V1404I": "2.0",
  "V1605B": "2.0",
  "V1756B": "3.25",
  "V1807B": "3.35",
  "3101": "2.1",
  "3151": "2.7",
  "3201": "1.5",
  "3251": "2.5",
  "3255": "2.5",
  "3301": "2.0",
  "3351": "1.9",
  "3401": "1.85",
  "3451": "2.15",
  // ZEN+ Desktop
  "1200|AF": "3.1",
  "2300X": "3.5",
  "2500X": "3.6",
  "2600": "3.4",
  "2600E": "3.1",
  "1600|AF": "3.2",
  "2600X": "3.6",
  "2700": "3.2",
  "2700E": "2.8",
  "Pro 2700": "3.2",
  "2700X": "3.7",
  "Pro 2700X": "3.6",
  "2920X": "3.5",
  "2950X": "3.5",
  "2970WX": "3.0",
  "2990WX": "3.0",
  // ZEN+ Desktop APU
  "Pro 300GE": "3.4",
  "Pro 3125GE": "3.4",
  "3150G": "3.5",
  "Pro 3150G": "3.5",
  "3150GE": "3.3",
  "Pro 3150GE": "3.3",
  "3200G": "3.6",
  "Pro 3200G": "3.6",
  "3200GE": "3.3",
  "Pro 3200GE": "3.3",
  "3350G": "3.6",
  "Pro 3350G": "3.6",
  "3350GE": "3.3",
  "Pro 3350GE": "3.3",
  "3400G": "3.7",
  "Pro 3400G": "3.7",
  "3400GE": "3.3",
  "Pro 3400GE": "3.3",
  // ZEN+ Mobile
  "3300U": "2.1",
  "PRO 3300U": "2.1",
  "3450U": "2.1",
  "3500U": "2.1",
  "PRO 3500U": "2.1",
  "3500C": "2.1",
  "3550H": "2.1",
  "3580U": "2.1",
  "3700U": "2.3",
  "PRO 3700U": "2.3",
  "3700C": "2.3",
  "3750H": "2.3",
  "3780U": "2.3",
  // ZEN2 Desktop CPUS
  "3100": "3.6",
  "3300X": "3.8",
  "3500": "3.6",
  "3500X": "3.6",
  "3600": "3.6",
  "Pro 3600": "3.6",
  "3600X": "3.8",
  "3600XT": "3.8",
  "Pro 3700": "3.6",
  "3700X": "3.6",
  "3800X": "3.9",
  "3800XT": "3.9",
  "3900": "3.1",
  "Pro 3900": "3.1",
  "3900X": "3.8",
  "3900XT": "3.8",
  "3950X": "3.5",
  "3960X": "3.8",
  "3970X": "3.7",
  "3990X": "2.9",
  "3945WX": "4.0",
  "3955WX": "3.9",
  "3975WX": "3.5",
  "3995WX": "2.7",
  // ZEN2 Desktop APUs
  "4300GE": "3.5",
  "Pro 4300GE": "3.5",
  "4300G": "3.8",
  "Pro 4300G": "3.8",
  "4600GE": "3.3",
  "Pro 4650GE": "3.3",
  "4600G": "3.7",
  "Pro 4650G": "3.7",
  "4700GE": "3.1",
  "Pro 4750GE": "3.1",
  "4700G": "3.6",
  "Pro 4750G": "3.6",
  "4300U": "2.7",
  "4450U": "2.5",
  "Pro 4450U": "2.5",
  "4500U": "2.3",
  "4600U": "2.1",
  "PRO 4650U": "2.1",
  "4680U": "2.1",
  "4600HS": "3.0",
  "4600H": "3.0",
  "4700U": "2.0",
  "PRO 4750U": "1.7",
  "4800U": "1.8",
  "4800HS": "2.9",
  "4800H": "2.9",
  "4900HS": "3.0",
  "4900H": "3.3",
  "5300U": "2.6",
  "5500U": "2.1",
  "5700U": "1.8",
  // ZEN2 - EPYC
  "7232P": "3.1",
  "7302P": "3.0",
  "7402P": "2.8",
  "7502P": "2.5",
  "7702P": "2.0",
  "7252": "3.1",
  "7262": "3.2",
  "7272": "2.9",
  "7282": "2.8",
  "7302": "3.0",
  "7352": "2.3",
  "7402": "2.8",
  "7452": "2.35",
  "7502": "2.5",
  "7532": "2.4",
  "7542": "2.9",
  "7552": "2.2",
  "7642": "2.3",
  "7662": "2.0",
  "7702": "2.0",
  "7742": "2.25",
  "7H12": "2.6",
  "7F32": "3.7",
  "7F52": "3.5",
  "7F72": "3.2",
  // Epyc (Milan)
  "7773X": "2.2",
  "7763": "2.45",
  "7713": "2.0",
  "7713P": "2.0",
  "7663": "2.0",
  "7643": "2.3",
  "7573X": "2.8",
  "75F3": "2.95",
  "7543": "2.8",
  "7543P": "2.8",
  "7513": "2.6",
  "7473X": "2.8",
  "7453": "2.75",
  "74F3": "3.2",
  "7443": "2.85",
  "7443P": "2.85",
  "7413": "2.65",
  "7373X": "3.05",
  "73F3": "3.5",
  "7343": "3.2",
  "7313": "3.0",
  "7313P": "3.0",
  "72F3": "3.7",
  // ZEN3
  "5600X": "3.7",
  "5800X": "3.8",
  "5900X": "3.7",
  "5950X": "3.4",
  "5945WX": "4.1",
  "5955WX": "4.0",
  "5965WX": "3.8",
  "5975WX": "3.6",
  "5995WX": "2.7",
  "7960X": "4.2",
  "7970X": "4.0",
  "7980X": "3.2",
  "7965WX": "4.2",
  "7975WX": "4.0",
  "7985WX": "3.2",
  "7995WX": "2.5",
  // ZEN4
  "9754": "2.25",
  "9754S": "2.25",
  "9734": "2.2",
  "9684X": "2.55",
  "9384X": "3.1",
  "9184X": "3.55",
  "9654P": "2.4",
  "9654": "2.4",
  "9634": "2.25",
  "9554P": "3.1",
  "9554": "3.1",
  "9534": "2.45",
  "9474F": "3.6",
  "9454P": "2.75",
  "9454": "2.75",
  "9374F": "3.85",
  "9354P": "3.25",
  "9354": "3.25",
  "9334": "2.7",
  "9274F": "4.05",
  "9254": "2.9",
  "9224": "2.5",
  "9174F": "4.1",
  "9124": "3.0"
};
const socketTypes = {
  1: "Other",
  2: "Unknown",
  3: "Daughter Board",
  4: "ZIF Socket",
  5: "Replacement/Piggy Back",
  6: "None",
  7: "LIF Socket",
  8: "Slot 1",
  9: "Slot 2",
  10: "370 Pin Socket",
  11: "Slot A",
  12: "Slot M",
  13: "423",
  14: "A (Socket 462)",
  15: "478",
  16: "754",
  17: "940",
  18: "939",
  19: "mPGA604",
  20: "LGA771",
  21: "LGA775",
  22: "S1",
  23: "AM2",
  24: "F (1207)",
  25: "LGA1366",
  26: "G34",
  27: "AM3",
  28: "C32",
  29: "LGA1156",
  30: "LGA1567",
  31: "PGA988A",
  32: "BGA1288",
  33: "rPGA988B",
  34: "BGA1023",
  35: "BGA1224",
  36: "LGA1155",
  37: "LGA1356",
  38: "LGA2011",
  39: "FS1",
  40: "FS2",
  41: "FM1",
  42: "FM2",
  43: "LGA2011-3",
  44: "LGA1356-3",
  45: "LGA1150",
  46: "BGA1168",
  47: "BGA1234",
  48: "BGA1364",
  49: "AM4",
  50: "LGA1151",
  51: "BGA1356",
  52: "BGA1440",
  53: "BGA1515",
  54: "LGA3647-1",
  55: "SP3",
  56: "SP3r2",
  57: "LGA2066",
  58: "BGA1392",
  59: "BGA1510",
  60: "BGA1528",
  61: "LGA4189",
  62: "LGA1200",
  63: "LGA4677",
  64: "LGA1700",
  65: "BGA1744",
  66: "BGA1781",
  67: "BGA1211",
  68: "BGA2422",
  69: "LGA1211",
  70: "LGA2422",
  71: "LGA5773",
  72: "BGA5773"
};
const socketTypesByName = {
  "LGA1150": "i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430",
  "LGA1151": "i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400",
  "1155": "G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290"
};
function getSocketTypesByName(str) {
  let result2 = "";
  for (const key2 in socketTypesByName) {
    const names = socketTypesByName[key2].split(" ");
    names.forEach((element) => {
      if (str.indexOf(element) >= 0) {
        result2 = key2;
      }
    });
  }
  return result2;
}
function cpuManufacturer(str) {
  let result2 = str;
  str = str.toLowerCase();
  if (str.indexOf("intel") >= 0) {
    result2 = "Intel";
  }
  if (str.indexOf("amd") >= 0) {
    result2 = "AMD";
  }
  if (str.indexOf("qemu") >= 0) {
    result2 = "QEMU";
  }
  if (str.indexOf("hygon") >= 0) {
    result2 = "Hygon";
  }
  if (str.indexOf("centaur") >= 0) {
    result2 = "WinChip/Via";
  }
  if (str.indexOf("vmware") >= 0) {
    result2 = "VMware";
  }
  if (str.indexOf("Xen") >= 0) {
    result2 = "Xen Hypervisor";
  }
  if (str.indexOf("tcg") >= 0) {
    result2 = "QEMU";
  }
  if (str.indexOf("apple") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("sifive") >= 0) {
    result2 = "SiFive";
  }
  if (str.indexOf("thead") >= 0) {
    result2 = "T-Head";
  }
  if (str.indexOf("andestech") >= 0) {
    result2 = "Andes Technology";
  }
  return result2;
}
function cpuBrandManufacturer(res) {
  res.brand = res.brand.replace(/\(R\)+/g, "Â®").replace(/\s+/g, " ").trim();
  res.brand = res.brand.replace(/\(TM\)+/g, "â¢").replace(/\s+/g, " ").trim();
  res.brand = res.brand.replace(/\(C\)+/g, "Â©").replace(/\s+/g, " ").trim();
  res.brand = res.brand.replace(/CPU+/g, "").replace(/\s+/g, " ").trim();
  res.manufacturer = cpuManufacturer(res.brand);
  let parts = res.brand.split(" ");
  parts.shift();
  res.brand = parts.join(" ");
  return res;
}
function getAMDSpeed(brand) {
  let result2 = "0";
  for (let key2 in AMDBaseFrequencies) {
    if ({}.hasOwnProperty.call(AMDBaseFrequencies, key2)) {
      let parts = key2.split("|");
      let found = 0;
      parts.forEach((item) => {
        if (brand.indexOf(item) > -1) {
          found++;
        }
      });
      if (found === parts.length) {
        result2 = AMDBaseFrequencies[key2];
      }
    }
  }
  return parseFloat(result2);
}
function getCpu() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      const UNKNOWN = "unknown";
      let result2 = {
        manufacturer: UNKNOWN,
        brand: UNKNOWN,
        vendor: "",
        family: "",
        model: "",
        stepping: "",
        revision: "",
        voltage: "",
        speed: 0,
        speedMin: 0,
        speedMax: 0,
        governor: "",
        cores: util$f.cores(),
        physicalCores: util$f.cores(),
        performanceCores: util$f.cores(),
        efficiencyCores: 0,
        processors: 1,
        socket: "",
        flags: "",
        virtualization: false,
        cache: {}
      };
      cpuFlags().then((flags) => {
        result2.flags = flags;
        result2.virtualization = flags.indexOf("vmx") > -1 || flags.indexOf("svm") > -1;
        if (_darwin$d) {
          exec$d("sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily", function(error, stdout) {
            let lines = stdout.toString().split("\n");
            const modelline = util$f.getValue(lines, "machdep.cpu.brand_string");
            const modellineParts = modelline.split("@");
            result2.brand = modellineParts[0].trim();
            const speed = modellineParts[1] ? modellineParts[1].trim() : "0";
            result2.speed = parseFloat(speed.replace(/GHz+/g, ""));
            let tbFrequency = util$f.getValue(lines, "hw.tbfrequency") / 1e9;
            tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;
            result2.speed = result2.speed === 0 ? tbFrequency : result2.speed;
            _cpu_speed = result2.speed;
            result2 = cpuBrandManufacturer(result2);
            result2.speedMin = util$f.getValue(lines, "hw.cpufrequency_min") ? util$f.getValue(lines, "hw.cpufrequency_min") / 1e9 : result2.speed;
            result2.speedMax = util$f.getValue(lines, "hw.cpufrequency_max") ? util$f.getValue(lines, "hw.cpufrequency_max") / 1e9 : result2.speed;
            result2.vendor = util$f.getValue(lines, "machdep.cpu.vendor") || "Apple";
            result2.family = util$f.getValue(lines, "machdep.cpu.family") || util$f.getValue(lines, "hw.cpufamily");
            result2.model = util$f.getValue(lines, "machdep.cpu.model");
            result2.stepping = util$f.getValue(lines, "machdep.cpu.stepping") || util$f.getValue(lines, "hw.cpusubfamily");
            result2.virtualization = true;
            const countProcessors = util$f.getValue(lines, "hw.packages");
            const countCores = util$f.getValue(lines, "hw.physicalcpu_max");
            const countThreads = util$f.getValue(lines, "hw.ncpu");
            if (os$6.arch() === "arm64") {
              result2.socket = "SOC";
              try {
                const clusters = execSync$8("ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type").toString().split("\n");
                const efficiencyCores = clusters.filter((line) => line.indexOf('"E"') >= 0).length;
                const performanceCores = clusters.filter((line) => line.indexOf('"P"') >= 0).length;
                result2.efficiencyCores = efficiencyCores;
                result2.performanceCores = performanceCores;
              } catch (e) {
                util$f.noop();
              }
            }
            if (countProcessors) {
              result2.processors = parseInt(countProcessors) || 1;
            }
            if (countCores && countThreads) {
              result2.cores = parseInt(countThreads) || util$f.cores();
              result2.physicalCores = parseInt(countCores) || util$f.cores();
            }
            cpuCache().then((res) => {
              result2.cache = res;
              resolve(result2);
            });
          });
        }
        if (_linux$d) {
          let modelline = "";
          let lines = [];
          if (os$6.cpus()[0] && os$6.cpus()[0].model) {
            modelline = os$6.cpus()[0].model;
          }
          exec$d('export LC_ALL=C; lscpu; echo -n "Governor: "; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function(error, stdout) {
            if (!error) {
              lines = stdout.toString().split("\n");
            }
            modelline = util$f.getValue(lines, "model name") || modelline;
            modelline = util$f.getValue(lines, "bios model name") || modelline;
            modelline = util$f.cleanString(modelline);
            const modellineParts = modelline.split("@");
            result2.brand = modellineParts[0].trim();
            result2.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;
            if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
              result2.speed = getAMDSpeed(result2.brand);
            }
            if (result2.speed === 0) {
              const current = getCpuCurrentSpeedSync();
              if (current.avg !== 0) {
                result2.speed = current.avg;
              }
            }
            _cpu_speed = result2.speed;
            result2.speedMin = Math.round(parseFloat(util$f.getValue(lines, "cpu min mhz").replace(/,/g, ".")) / 10) / 100;
            result2.speedMax = Math.round(parseFloat(util$f.getValue(lines, "cpu max mhz").replace(/,/g, ".")) / 10) / 100;
            result2 = cpuBrandManufacturer(result2);
            result2.vendor = cpuManufacturer(util$f.getValue(lines, "vendor id"));
            result2.family = util$f.getValue(lines, "cpu family");
            result2.model = util$f.getValue(lines, "model:");
            result2.stepping = util$f.getValue(lines, "stepping");
            result2.revision = util$f.getValue(lines, "cpu revision");
            result2.cache.l1d = util$f.getValue(lines, "l1d cache");
            if (result2.cache.l1d) {
              result2.cache.l1d = parseInt(result2.cache.l1d) * (result2.cache.l1d.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l1d.indexOf("K") !== -1 ? 1024 : 1);
            }
            result2.cache.l1i = util$f.getValue(lines, "l1i cache");
            if (result2.cache.l1i) {
              result2.cache.l1i = parseInt(result2.cache.l1i) * (result2.cache.l1i.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l1i.indexOf("K") !== -1 ? 1024 : 1);
            }
            result2.cache.l2 = util$f.getValue(lines, "l2 cache");
            if (result2.cache.l2) {
              result2.cache.l2 = parseInt(result2.cache.l2) * (result2.cache.l2.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l2.indexOf("K") !== -1 ? 1024 : 1);
            }
            result2.cache.l3 = util$f.getValue(lines, "l3 cache");
            if (result2.cache.l3) {
              result2.cache.l3 = parseInt(result2.cache.l3) * (result2.cache.l3.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l3.indexOf("K") !== -1 ? 1024 : 1);
            }
            const threadsPerCore = util$f.getValue(lines, "thread(s) per core") || "1";
            const processors = util$f.getValue(lines, "socket(s)") || "1";
            const threadsPerCoreInt = parseInt(threadsPerCore, 10);
            const processorsInt = parseInt(processors, 10) || 1;
            const coresPerSocket = parseInt(util$f.getValue(lines, "core(s) per socket"), 10);
            result2.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result2.cores / threadsPerCoreInt;
            result2.performanceCores = threadsPerCoreInt > 1 ? result2.cores - result2.physicalCores : result2.cores;
            result2.efficiencyCores = threadsPerCoreInt > 1 ? result2.cores - threadsPerCoreInt * result2.performanceCores : 0;
            result2.processors = processorsInt;
            result2.governor = util$f.getValue(lines, "governor") || "";
            if (result2.vendor === "ARM" && util$f.isRaspberry()) {
              const rPIRevision = util$f.decodePiCpuinfo();
              result2.family = result2.manufacturer;
              result2.manufacturer = rPIRevision.manufacturer;
              result2.brand = rPIRevision.processor;
              result2.revision = rPIRevision.revisionCode;
              result2.socket = "SOC";
            }
            if (util$f.getValue(lines, "architecture") === "riscv64") {
              const linesRiscV = fs$7.readFileSync("/proc/cpuinfo").toString().split("\n");
              const uarch = util$f.getValue(linesRiscV, "uarch") || "";
              if (uarch.indexOf(",") > -1) {
                const split = uarch.split(",");
                result2.manufacturer = cpuManufacturer(split[0]);
                result2.brand = split[1];
              }
            }
            let lines2 = [];
            exec$d('export LC_ALL=C; dmidecode ât 4 2>/dev/null | grep "Upgrade: Socket"; unset LC_ALL', function(error2, stdout2) {
              lines2 = stdout2.toString().split("\n");
              if (lines2 && lines2.length) {
                result2.socket = util$f.getValue(lines2, "Upgrade").replace("Socket", "").trim() || result2.socket;
              }
              resolve(result2);
            });
          });
        }
        if (_freebsd$c || _openbsd$c || _netbsd$c) {
          let modelline = "";
          let lines = [];
          if (os$6.cpus()[0] && os$6.cpus()[0].model) {
            modelline = os$6.cpus()[0].model;
          }
          exec$d("export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL", function(error, stdout) {
            let cache = [];
            if (!error) {
              const data = stdout.toString().split("# dmidecode");
              const processor = data.length > 1 ? data[1] : "";
              cache = data.length > 2 ? data[2].split("Cache Information") : [];
              lines = processor.split("\n");
            }
            result2.brand = modelline.split("@")[0].trim();
            result2.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()) : 0;
            if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
              result2.speed = getAMDSpeed(result2.brand);
            }
            if (result2.speed === 0) {
              const current = getCpuCurrentSpeedSync();
              if (current.avg !== 0) {
                result2.speed = current.avg;
              }
            }
            _cpu_speed = result2.speed;
            result2.speedMin = result2.speed;
            result2.speedMax = Math.round(parseFloat(util$f.getValue(lines, "max speed").replace(/Mhz/g, "")) / 10) / 100;
            result2 = cpuBrandManufacturer(result2);
            result2.vendor = cpuManufacturer(util$f.getValue(lines, "manufacturer"));
            let sig = util$f.getValue(lines, "signature");
            sig = sig.split(",");
            for (let i = 0; i < sig.length; i++) {
              sig[i] = sig[i].trim();
            }
            result2.family = util$f.getValue(sig, "Family", " ", true);
            result2.model = util$f.getValue(sig, "Model", " ", true);
            result2.stepping = util$f.getValue(sig, "Stepping", " ", true);
            result2.revision = "";
            const voltage = parseFloat(util$f.getValue(lines, "voltage"));
            result2.voltage = isNaN(voltage) ? "" : voltage.toFixed(2);
            for (let i = 0; i < cache.length; i++) {
              lines = cache[i].split("\n");
              let cacheType = util$f.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
              cacheType = cacheType.length ? cacheType[0] : "";
              const sizeParts = util$f.getValue(lines, "Installed Size").split(" ");
              let size = parseInt(sizeParts[0], 10);
              const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
              size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
              if (cacheType) {
                if (cacheType === "l1") {
                  result2.cache[cacheType + "d"] = size / 2;
                  result2.cache[cacheType + "i"] = size / 2;
                } else {
                  result2.cache[cacheType] = size;
                }
              }
            }
            result2.socket = util$f.getValue(lines, "Upgrade").replace("Socket", "").trim();
            const threadCount = util$f.getValue(lines, "thread count").trim();
            const coreCount = util$f.getValue(lines, "core count").trim();
            if (coreCount && threadCount) {
              result2.cores = parseInt(threadCount, 10);
              result2.physicalCores = parseInt(coreCount, 10);
            }
            resolve(result2);
          });
        }
        if (_sunos$c) {
          resolve(result2);
        }
        if (_windows$e) {
          try {
            const workload = [];
            workload.push(util$f.powerShell("Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl"));
            workload.push(util$f.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
            workload.push(util$f.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
            Promise.all(
              workload
            ).then((data) => {
              let lines = data[0].split("\r\n");
              let name = util$f.getValue(lines, "name", ":") || "";
              if (name.indexOf("@") >= 0) {
                result2.brand = name.split("@")[0].trim();
                result2.speed = name.split("@")[1] ? parseFloat(name.split("@")[1].trim()) : 0;
                _cpu_speed = result2.speed;
              } else {
                result2.brand = name.trim();
                result2.speed = 0;
              }
              result2 = cpuBrandManufacturer(result2);
              result2.revision = util$f.getValue(lines, "revision", ":");
              result2.vendor = util$f.getValue(lines, "manufacturer", ":");
              result2.speedMax = Math.round(parseFloat(util$f.getValue(lines, "maxclockspeed", ":").replace(/,/g, ".")) / 10) / 100;
              if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result2.speed = getAMDSpeed(result2.brand);
              }
              if (result2.speed === 0) {
                result2.speed = result2.speedMax;
              }
              result2.speedMin = result2.speed;
              let description = util$f.getValue(lines, "description", ":").split(" ");
              for (let i = 0; i < description.length; i++) {
                if (description[i].toLowerCase().startsWith("family") && i + 1 < description.length && description[i + 1]) {
                  result2.family = description[i + 1];
                }
                if (description[i].toLowerCase().startsWith("model") && i + 1 < description.length && description[i + 1]) {
                  result2.model = description[i + 1];
                }
                if (description[i].toLowerCase().startsWith("stepping") && i + 1 < description.length && description[i + 1]) {
                  result2.stepping = description[i + 1];
                }
              }
              const socketId = util$f.getValue(lines, "UpgradeMethod", ":");
              if (socketTypes[socketId]) {
                result2.socket = socketTypes[socketId];
              }
              const socketByName = getSocketTypesByName(name);
              if (socketByName) {
                result2.socket = socketByName;
              }
              const countProcessors = util$f.countLines(lines, "Caption");
              const countThreads = util$f.getValue(lines, "NumberOfLogicalProcessors", ":");
              const countCores = util$f.getValue(lines, "NumberOfCores", ":");
              if (countProcessors) {
                result2.processors = parseInt(countProcessors) || 1;
              }
              if (countCores && countThreads) {
                result2.cores = parseInt(countThreads) || util$f.cores();
                result2.physicalCores = parseInt(countCores) || util$f.cores();
              }
              if (countProcessors > 1) {
                result2.cores = result2.cores * countProcessors;
                result2.physicalCores = result2.physicalCores * countProcessors;
              }
              result2.cache = parseWinCache(data[0], data[1]);
              const hyperv = data[2] ? data[2].toString().toLowerCase() : "";
              result2.virtualization = hyperv.indexOf("true") !== -1;
              resolve(result2);
            });
          } catch (e) {
            resolve(result2);
          }
        }
      });
    });
  });
}
function cpu(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      getCpu().then((result2) => {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      });
    });
  });
}
cpu$1.cpu = cpu;
function getCpuCurrentSpeedSync() {
  let cpus = os$6.cpus();
  let minFreq = 999999999;
  let maxFreq = 0;
  let avgFreq = 0;
  let cores2 = [];
  let speeds = [];
  if (cpus && cpus.length && cpus[0].speed) {
    for (let i in cpus) {
      speeds.push(cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1e3 : cpus[i].speed / 10);
    }
  } else if (_linux$d) {
    try {
      const speedStrings = execSync$8('cat /proc/cpuinfo | grep "cpu MHz" | cut -d " " -f 3', util$f.execOptsLinux).toString().split("\n").filter((line) => line.length > 0);
      for (let i in speedStrings) {
        speeds.push(Math.floor(parseInt(speedStrings[i], 10) / 10) / 100);
      }
    } catch {
      util$f.noop();
    }
  }
  if (speeds && speeds.length) {
    for (let i in speeds) {
      avgFreq = avgFreq + speeds[i];
      if (speeds[i] > maxFreq) {
        maxFreq = speeds[i];
      }
      if (speeds[i] < minFreq) {
        minFreq = speeds[i];
      }
      cores2.push(parseFloat(speeds[i].toFixed(2)));
    }
    avgFreq = avgFreq / speeds.length;
    return {
      min: parseFloat(minFreq.toFixed(2)),
      max: parseFloat(maxFreq.toFixed(2)),
      avg: parseFloat(avgFreq.toFixed(2)),
      cores: cores2
    };
  } else {
    return {
      min: 0,
      max: 0,
      avg: 0,
      cores: cores2
    };
  }
}
function cpuCurrentSpeed(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = getCpuCurrentSpeedSync();
      if (result2.avg === 0 && _cpu_speed !== 0) {
        const currCpuSpeed = parseFloat(_cpu_speed);
        result2 = {
          min: currCpuSpeed,
          max: currCpuSpeed,
          avg: currCpuSpeed,
          cores: []
        };
      }
      if (callback) {
        callback(result2);
      }
      resolve(result2);
    });
  });
}
cpu$1.cpuCurrentSpeed = cpuCurrentSpeed;
function cpuTemperature(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        main: null,
        cores: [],
        max: null,
        socket: [],
        chipset: null
      };
      if (_linux$d) {
        try {
          const cmd2 = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo "-----"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';
          const parts = execSync$8(cmd2, util$f.execOptsLinux).toString().split("-----\n");
          if (parts.length === 2) {
            const lines = parts[0].split("\n");
            const lines2 = parts[1].split("\n");
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              if (line.startsWith("acpi") && lines2[i]) {
                result2.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);
              }
              if (line.startsWith("pch") && lines2[i]) {
                result2.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;
              }
            }
          }
        } catch (e) {
          util$f.noop();
        }
        const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in "$mon"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat "$label")___$(cat "$value"); fi; done; done;';
        try {
          exec$d(cmd, function(error, stdout) {
            stdout = stdout.toString();
            const tdiePos = stdout.toLowerCase().indexOf("tdie");
            if (tdiePos !== -1) {
              stdout = stdout.substring(tdiePos);
            }
            let lines = stdout.split("\n");
            let tctl = 0;
            lines.forEach((line) => {
              const parts = line.split("___");
              const label = parts[0];
              const value = parts.length > 1 && parts[1] ? parts[1] : "0";
              if (value && label && label.toLowerCase() === "tctl") {
                tctl = result2.main = Math.round(parseInt(value, 10) / 100) / 10;
              }
              if (value && (label === void 0 || label && label.toLowerCase().startsWith("core"))) {
                result2.cores.push(Math.round(parseInt(value, 10) / 100) / 10);
              } else if (value && label && result2.main === null && (label.toLowerCase().indexOf("package") >= 0 || label.toLowerCase().indexOf("physical") >= 0 || label.toLowerCase() === "tccd1")) {
                result2.main = Math.round(parseInt(value, 10) / 100) / 10;
              }
            });
            if (tctl && result2.main === null) {
              result2.main = tctl;
            }
            if (result2.cores.length > 0) {
              if (result2.main === null) {
                result2.main = Math.round(result2.cores.reduce((a, b) => a + b, 0) / result2.cores.length);
              }
              let maxtmp = Math.max.apply(Math, result2.cores);
              result2.max = maxtmp > result2.main ? maxtmp : result2.main;
            }
            if (result2.main !== null) {
              if (result2.max === null) {
                result2.max = result2.main;
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
              return;
            }
            exec$d("sensors", function(error2, stdout2) {
              if (!error2) {
                let lines2 = stdout2.toString().split("\n");
                let tdieTemp = null;
                let newSectionStarts = true;
                let section = "";
                lines2.forEach(function(line) {
                  if (line.trim() === "") {
                    newSectionStarts = true;
                  } else if (newSectionStarts) {
                    if (line.trim().toLowerCase().startsWith("acpi")) {
                      section = "acpi";
                    }
                    if (line.trim().toLowerCase().startsWith("pch")) {
                      section = "pch";
                    }
                    if (line.trim().toLowerCase().startsWith("core")) {
                      section = "core";
                    }
                    newSectionStarts = false;
                  }
                  let regex = /[+-]([^Â°]*)/g;
                  let temps = line.match(regex);
                  let firstPart = line.split(":")[0].toUpperCase();
                  if (section === "acpi") {
                    if (firstPart.indexOf("TEMP") !== -1) {
                      result2.socket.push(parseFloat(temps));
                    }
                  } else if (section === "pch") {
                    if (firstPart.indexOf("TEMP") !== -1 && !result2.chipset) {
                      result2.chipset = parseFloat(temps);
                    }
                  }
                  if (firstPart.indexOf("PHYSICAL") !== -1 || firstPart.indexOf("PACKAGE") !== -1) {
                    result2.main = parseFloat(temps);
                  }
                  if (firstPart.indexOf("CORE ") !== -1) {
                    result2.cores.push(parseFloat(temps));
                  }
                  if (firstPart.indexOf("TDIE") !== -1 && tdieTemp === null) {
                    tdieTemp = parseFloat(temps);
                  }
                });
                if (result2.cores.length > 0) {
                  result2.main = Math.round(result2.cores.reduce((a, b) => a + b, 0) / result2.cores.length);
                  let maxtmp = Math.max.apply(Math, result2.cores);
                  result2.max = maxtmp > result2.main ? maxtmp : result2.main;
                } else {
                  if (result2.main === null && tdieTemp !== null) {
                    result2.main = tdieTemp;
                    result2.max = tdieTemp;
                  }
                }
                if (result2.main !== null || result2.max !== null) {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                  return;
                }
              }
              fs$7.stat("/sys/class/thermal/thermal_zone0/temp", function(err) {
                if (err === null) {
                  fs$7.readFile("/sys/class/thermal/thermal_zone0/temp", function(error3, stdout3) {
                    if (!error3) {
                      let lines2 = stdout3.toString().split("\n");
                      if (lines2.length > 0) {
                        result2.main = parseFloat(lines2[0]) / 1e3;
                        result2.max = result2.main;
                      }
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  });
                } else {
                  exec$d("/opt/vc/bin/vcgencmd measure_temp", function(error3, stdout3) {
                    if (!error3) {
                      let lines2 = stdout3.toString().split("\n");
                      if (lines2.length > 0 && lines2[0].indexOf("=")) {
                        result2.main = parseFloat(lines2[0].split("=")[1]);
                        result2.max = result2.main;
                      }
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  });
                }
              });
            });
          });
        } catch (er) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_freebsd$c || _openbsd$c || _netbsd$c) {
        exec$d("sysctl dev.cpu | grep temp", function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            let sum = 0;
            lines.forEach(function(line) {
              const parts = line.split(":");
              if (parts.length > 1) {
                const temp = parseFloat(parts[1].replace(",", "."));
                if (temp > result2.max) {
                  result2.max = temp;
                }
                sum = sum + temp;
                result2.cores.push(temp);
              }
            });
            if (result2.cores.length) {
              result2.main = Math.round(sum / result2.cores.length * 100) / 100;
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$d) {
        let osxTemp = null;
        try {
          osxTemp = require("osx-temperature-sensor");
        } catch (er) {
          osxTemp = null;
        }
        if (osxTemp) {
          result2 = osxTemp.cpuTemperature();
          if (result2.main) {
            result2.main = Math.round(result2.main * 100) / 100;
          }
          if (result2.max) {
            result2.max = Math.round(result2.max * 100) / 100;
          }
          if (result2.cores && result2.cores.length) {
            for (let i = 0; i < result2.cores.length; i++) {
              result2.cores[i] = Math.round(result2.cores[i] * 100) / 100;
            }
          }
        }
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_sunos$c) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$e) {
        try {
          util$f.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace "root/wmi" | Select CurrentTemperature').then((stdout, error) => {
            if (!error) {
              let sum = 0;
              let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
              lines.forEach(function(line) {
                let value = (parseInt(line, 10) - 2732) / 10;
                if (!isNaN(value)) {
                  sum = sum + value;
                  if (value > result2.max) {
                    result2.max = value;
                  }
                  result2.cores.push(value);
                }
              });
              if (result2.cores.length) {
                result2.main = sum / result2.cores.length;
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
cpu$1.cpuTemperature = cpuTemperature;
function cpuFlags(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = "";
      if (_windows$e) {
        try {
          exec$d('reg query "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0" /v FeatureSet', util$f.execOptsWin, function(error, stdout) {
            if (!error) {
              let flag_hex = stdout.split("0x").pop().trim();
              let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);
              let flag_bin = "0".repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;
              let all_flags = [
                "fpu",
                "vme",
                "de",
                "pse",
                "tsc",
                "msr",
                "pae",
                "mce",
                "cx8",
                "apic",
                "",
                "sep",
                "mtrr",
                "pge",
                "mca",
                "cmov",
                "pat",
                "pse-36",
                "psn",
                "clfsh",
                "",
                "ds",
                "acpi",
                "mmx",
                "fxsr",
                "sse",
                "sse2",
                "ss",
                "htt",
                "tm",
                "ia64",
                "pbe"
              ];
              for (let f = 0; f < all_flags.length; f++) {
                if (flag_bin[f] === "1" && all_flags[f] !== "") {
                  result2 += " " + all_flags[f];
                }
              }
              result2 = result2.trim().toLowerCase();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_linux$d) {
        try {
          exec$d("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                if (line.split(":")[0].toUpperCase().indexOf("FLAGS") !== -1) {
                  result2 = line.split(":")[1].trim().toLowerCase();
                }
              });
            }
            if (!result2) {
              fs$7.readFile("/proc/cpuinfo", function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  result2 = util$f.getValue(lines, "features", ":", true).toLowerCase();
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_freebsd$c || _openbsd$c || _netbsd$c) {
        exec$d("export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL", function(error, stdout) {
          let flags = [];
          if (!error) {
            let parts = stdout.toString().split("	Flags:");
            const lines = parts.length > 1 ? parts[1].split("	Version:")[0].split("\n") : [];
            lines.forEach(function(line) {
              let flag = (line.indexOf("(") ? line.split("(")[0].toLowerCase() : "").trim().replace(/\t/g, "");
              if (flag) {
                flags.push(flag);
              }
            });
          }
          result2 = flags.join(" ").trim().toLowerCase();
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$d) {
        exec$d("sysctl machdep.cpu.features", function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            if (lines.length > 0 && lines[0].indexOf("machdep.cpu.features:") !== -1) {
              result2 = lines[0].split(":")[1].trim().toLowerCase();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$c) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
cpu$1.cpuFlags = cpuFlags;
function cpuCache(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        l1d: null,
        l1i: null,
        l2: null,
        l3: null
      };
      if (_linux$d) {
        try {
          exec$d("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                let parts = line.split(":");
                if (parts[0].toUpperCase().indexOf("L1D CACHE") !== -1) {
                  result2.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toUpperCase().indexOf("L1I CACHE") !== -1) {
                  result2.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toUpperCase().indexOf("L2 CACHE") !== -1) {
                  result2.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toUpperCase().indexOf("L3 CACHE") !== -1) {
                  result2.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_freebsd$c || _openbsd$c || _netbsd$c) {
        exec$d("export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL", function(error, stdout) {
          let cache = [];
          if (!error) {
            const data = stdout.toString();
            cache = data.split("Cache Information");
            cache.shift();
          }
          for (let i = 0; i < cache.length; i++) {
            const lines = cache[i].split("\n");
            let cacheType = util$f.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
            cacheType = cacheType.length ? cacheType[0] : "";
            const sizeParts = util$f.getValue(lines, "Installed Size").split(" ");
            let size = parseInt(sizeParts[0], 10);
            const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
            size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
            if (cacheType) {
              if (cacheType === "l1") {
                result2.cache[cacheType + "d"] = size / 2;
                result2.cache[cacheType + "i"] = size / 2;
              } else {
                result2.cache[cacheType] = size;
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$d) {
        exec$d("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            lines.forEach(function(line) {
              let parts = line.split(":");
              if (parts[0].toLowerCase().indexOf("hw.l1icachesize") !== -1) {
                result2.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf("hw.l1dcachesize") !== -1) {
                result2.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf("hw.l2cachesize") !== -1) {
                result2.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf("hw.l3cachesize") !== -1) {
                result2.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
              }
            });
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$c) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$e) {
        try {
          const workload = [];
          workload.push(util$f.powerShell("Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl"));
          workload.push(util$f.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
          Promise.all(
            workload
          ).then((data) => {
            result2 = parseWinCache(data[0], data[1]);
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
function parseWinCache(linesProc, linesCache) {
  let result2 = {
    l1d: null,
    l1i: null,
    l2: null,
    l3: null
  };
  let lines = linesProc.split("\r\n");
  result2.l1d = 0;
  result2.l1i = 0;
  result2.l2 = util$f.getValue(lines, "l2cachesize", ":");
  result2.l3 = util$f.getValue(lines, "l3cachesize", ":");
  if (result2.l2) {
    result2.l2 = parseInt(result2.l2, 10) * 1024;
  } else {
    result2.l2 = 0;
  }
  if (result2.l3) {
    result2.l3 = parseInt(result2.l3, 10) * 1024;
  } else {
    result2.l3 = 0;
  }
  const parts = linesCache.split(/\n\s*\n/);
  let l1i = 0;
  let l1d = 0;
  let l2 = 0;
  parts.forEach(function(part) {
    const lines2 = part.split("\r\n");
    const cacheType = util$f.getValue(lines2, "CacheType");
    const level = util$f.getValue(lines2, "Level");
    const installedSize = util$f.getValue(lines2, "InstalledSize");
    if (level === "3" && cacheType === "3") {
      result2.l1i = result2.l1i + parseInt(installedSize, 10) * 1024;
    }
    if (level === "3" && cacheType === "4") {
      result2.l1d = result2.l1d + parseInt(installedSize, 10) * 1024;
    }
    if (level === "3" && cacheType === "5") {
      l1i = parseInt(installedSize, 10) / 2;
      l1d = parseInt(installedSize, 10) / 2;
    }
    if (level === "4" && cacheType === "5") {
      l2 = l2 + parseInt(installedSize, 10) * 1024;
    }
  });
  if (!result2.l1i && !result2.l1d) {
    result2.l1i = l1i;
    result2.l1d = l1d;
  }
  if (l2) {
    result2.l2 = l2;
  }
  return result2;
}
cpu$1.cpuCache = cpuCache;
function getLoad() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let loads = os$6.loadavg().map(function(x) {
        return x / util$f.cores();
      });
      let avgLoad = parseFloat(Math.max.apply(Math, loads).toFixed(2));
      let result2 = {};
      let now = Date.now() - _current_cpu.ms;
      if (now >= 200) {
        _current_cpu.ms = Date.now();
        const cpus = os$6.cpus().map(function(cpu2) {
          cpu2.times.steal = 0;
          cpu2.times.guest = 0;
          return cpu2;
        });
        let totalUser = 0;
        let totalSystem = 0;
        let totalNice = 0;
        let totalIrq = 0;
        let totalIdle = 0;
        let totalSteal = 0;
        let totalGuest = 0;
        let cores2 = [];
        _corecount = cpus && cpus.length ? cpus.length : 0;
        if (_linux$d) {
          try {
            const lines = execSync$8("cat /proc/stat 2>/dev/null | grep cpu", util$f.execOptsLinux).toString().split("\n");
            if (lines.length > 1) {
              lines.shift();
              if (lines.length === cpus.length) {
                for (let i = 0; i < lines.length; i++) {
                  let parts = lines[i].split(" ");
                  if (parts.length >= 10) {
                    const steal = parseFloat(parts[8]) || 0;
                    const guest = parseFloat(parts[9]) || 0;
                    cpus[i].times.steal = steal;
                    cpus[i].times.guest = guest;
                  }
                }
              }
            }
          } catch (e) {
            util$f.noop();
          }
        }
        for (let i = 0; i < _corecount; i++) {
          const cpu2 = cpus[i].times;
          totalUser += cpu2.user;
          totalSystem += cpu2.sys;
          totalNice += cpu2.nice;
          totalIdle += cpu2.idle;
          totalIrq += cpu2.irq;
          totalSteal += cpu2.steal || 0;
          totalGuest += cpu2.guest || 0;
          let tmpTick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;
          let tmpLoad = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;
          let tmpUser = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;
          let tmpSystem = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;
          let tmpNice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;
          let tmpIdle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;
          let tmpIrq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;
          let tmpSteal = _cpus && _cpus[i] && _cpus[i].steal ? _cpus[i].steal : 0;
          let tmpGuest = _cpus && _cpus[i] && _cpus[i].guest ? _cpus[i].guest : 0;
          _cpus[i] = cpu2;
          _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest + _cpus[i].idle;
          _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest;
          _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;
          _cpus[i].load = _cpus[i].totalLoad - tmpLoad;
          _cpus[i].loadUser = _cpus[i].user - tmpUser;
          _cpus[i].loadSystem = _cpus[i].sys - tmpSystem;
          _cpus[i].loadNice = _cpus[i].nice - tmpNice;
          _cpus[i].loadIdle = _cpus[i].idle - tmpIdle;
          _cpus[i].loadIrq = _cpus[i].irq - tmpIrq;
          _cpus[i].loadSteal = _cpus[i].steal - tmpSteal;
          _cpus[i].loadGuest = _cpus[i].guest - tmpGuest;
          cores2[i] = {};
          cores2[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
          cores2[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
          cores2[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
          cores2[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
          cores2[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
          cores2[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
          cores2[i].loadSteal = _cpus[i].loadSteal / _cpus[i].currentTick * 100;
          cores2[i].loadGuest = _cpus[i].loadGuest / _cpus[i].currentTick * 100;
          cores2[i].rawLoad = _cpus[i].load;
          cores2[i].rawLoadUser = _cpus[i].loadUser;
          cores2[i].rawLoadSystem = _cpus[i].loadSystem;
          cores2[i].rawLoadNice = _cpus[i].loadNice;
          cores2[i].rawLoadIdle = _cpus[i].loadIdle;
          cores2[i].rawLoadIrq = _cpus[i].loadIrq;
          cores2[i].rawLoadSteal = _cpus[i].loadSteal;
          cores2[i].rawLoadGuest = _cpus[i].loadGuest;
        }
        let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest + totalIdle;
        let totalLoad = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest;
        let currentTick = totalTick - _current_cpu.tick;
        result2 = {
          avgLoad,
          currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,
          currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,
          currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,
          currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,
          currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,
          currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,
          currentLoadSteal: (totalSteal - _current_cpu.steal) / currentTick * 100,
          currentLoadGuest: (totalGuest - _current_cpu.guest) / currentTick * 100,
          rawCurrentLoad: totalLoad - _current_cpu.load,
          rawCurrentLoadUser: totalUser - _current_cpu.user,
          rawCurrentLoadSystem: totalSystem - _current_cpu.system,
          rawCurrentLoadNice: totalNice - _current_cpu.nice,
          rawCurrentLoadIdle: totalIdle - _current_cpu.idle,
          rawCurrentLoadIrq: totalIrq - _current_cpu.irq,
          rawCurrentLoadSteal: totalSteal - _current_cpu.steal,
          rawCurrentLoadGuest: totalGuest - _current_cpu.guest,
          cpus: cores2
        };
        _current_cpu = {
          user: totalUser,
          nice: totalNice,
          system: totalSystem,
          idle: totalIdle,
          irq: totalIrq,
          steal: totalSteal,
          guest: totalGuest,
          tick: totalTick,
          load: totalLoad,
          ms: _current_cpu.ms,
          currentLoad: result2.currentLoad,
          currentLoadUser: result2.currentLoadUser,
          currentLoadSystem: result2.currentLoadSystem,
          currentLoadNice: result2.currentLoadNice,
          currentLoadIdle: result2.currentLoadIdle,
          currentLoadIrq: result2.currentLoadIrq,
          currentLoadSteal: result2.currentLoadSteal,
          currentLoadGuest: result2.currentLoadGuest,
          rawCurrentLoad: result2.rawCurrentLoad,
          rawCurrentLoadUser: result2.rawCurrentLoadUser,
          rawCurrentLoadSystem: result2.rawCurrentLoadSystem,
          rawCurrentLoadNice: result2.rawCurrentLoadNice,
          rawCurrentLoadIdle: result2.rawCurrentLoadIdle,
          rawCurrentLoadIrq: result2.rawCurrentLoadIrq,
          rawCurrentLoadSteal: result2.rawCurrentLoadSteal,
          rawCurrentLoadGuest: result2.rawCurrentLoadGuest
        };
      } else {
        let cores2 = [];
        for (let i = 0; i < _corecount; i++) {
          cores2[i] = {};
          cores2[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
          cores2[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
          cores2[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
          cores2[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
          cores2[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
          cores2[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
          cores2[i].rawLoad = _cpus[i].load;
          cores2[i].rawLoadUser = _cpus[i].loadUser;
          cores2[i].rawLoadSystem = _cpus[i].loadSystem;
          cores2[i].rawLoadNice = _cpus[i].loadNice;
          cores2[i].rawLoadIdle = _cpus[i].loadIdle;
          cores2[i].rawLoadIrq = _cpus[i].loadIrq;
          cores2[i].rawLoadSteal = _cpus[i].loadSteal;
          cores2[i].rawLoadGuest = _cpus[i].loadGuest;
        }
        result2 = {
          avgLoad,
          currentLoad: _current_cpu.currentLoad,
          currentLoadUser: _current_cpu.currentLoadUser,
          currentLoadSystem: _current_cpu.currentLoadSystem,
          currentLoadNice: _current_cpu.currentLoadNice,
          currentLoadIdle: _current_cpu.currentLoadIdle,
          currentLoadIrq: _current_cpu.currentLoadIrq,
          currentLoadSteal: _current_cpu.currentLoadSteal,
          currentLoadGuest: _current_cpu.currentLoadGuest,
          rawCurrentLoad: _current_cpu.rawCurrentLoad,
          rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,
          rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,
          rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,
          rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,
          rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,
          rawCurrentLoadSteal: _current_cpu.rawCurrentLoadSteal,
          rawCurrentLoadGuest: _current_cpu.rawCurrentLoadGuest,
          cpus: cores2
        };
      }
      resolve(result2);
    });
  });
}
function currentLoad(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      getLoad().then((result2) => {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      });
    });
  });
}
cpu$1.currentLoad = currentLoad;
function getFullLoad() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      const cpus = os$6.cpus();
      let totalUser = 0;
      let totalSystem = 0;
      let totalNice = 0;
      let totalIrq = 0;
      let totalIdle = 0;
      let result2 = 0;
      if (cpus && cpus.length) {
        for (let i = 0, len = cpus.length; i < len; i++) {
          const cpu2 = cpus[i].times;
          totalUser += cpu2.user;
          totalSystem += cpu2.sys;
          totalNice += cpu2.nice;
          totalIrq += cpu2.irq;
          totalIdle += cpu2.idle;
        }
        let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;
        result2 = (totalTicks - totalIdle) / totalTicks * 100;
      }
      resolve(result2);
    });
  });
}
function fullLoad(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      getFullLoad().then((result2) => {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      });
    });
  });
}
cpu$1.fullLoad = fullLoad;
var memory = {};
const os$5 = os$a;
const exec$c = require$$1$1.exec;
const execSync$7 = require$$1$1.execSync;
const util$e = util$j;
const fs$6 = require$$1$2;
let _platform$d = process.platform;
const _linux$c = _platform$d === "linux" || _platform$d === "android";
const _darwin$c = _platform$d === "darwin";
const _windows$d = _platform$d === "win32";
const _freebsd$b = _platform$d === "freebsd";
const _openbsd$b = _platform$d === "openbsd";
const _netbsd$b = _platform$d === "netbsd";
const _sunos$b = _platform$d === "sunos";
const OSX_RAM_manufacturers = {
  "0x014F": "Transcend Information",
  "0x2C00": "Micron Technology Inc.",
  "0x802C": "Micron Technology Inc.",
  "0x80AD": "Hynix Semiconductor Inc.",
  "0x80CE": "Samsung Electronics Inc.",
  "0xAD00": "Hynix Semiconductor Inc.",
  "0xCE00": "Samsung Electronics Inc.",
  "0x02FE": "Elpida",
  "0x5105": "Qimonda AG i. In.",
  "0x8551": "Qimonda AG i. In.",
  "0x859B": "Crucial",
  "0x04CD": "G-Skill"
};
const LINUX_RAM_manufacturers = {
  "017A": "Apacer",
  "0198": "HyperX",
  "029E": "Corsair",
  "04CB": "A-DATA",
  "04CD": "G-Skill",
  "059B": "Crucial",
  "00CE": "Samsung",
  "1315": "Crucial",
  "014F": "Transcend Information",
  "2C00": "Micron Technology Inc.",
  "802C": "Micron Technology Inc.",
  "80AD": "Hynix Semiconductor Inc.",
  "80CE": "Samsung Electronics Inc.",
  "AD00": "Hynix Semiconductor Inc.",
  "CE00": "Samsung Electronics Inc.",
  "02FE": "Elpida",
  "5105": "Qimonda AG i. In.",
  "8551": "Qimonda AG i. In.",
  "859B": "Crucial"
};
function mem(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        total: os$5.totalmem(),
        free: os$5.freemem(),
        used: os$5.totalmem() - os$5.freemem(),
        active: os$5.totalmem() - os$5.freemem(),
        // temporarily (fallback)
        available: os$5.freemem(),
        // temporarily (fallback)
        buffers: 0,
        cached: 0,
        slab: 0,
        buffcache: 0,
        swaptotal: 0,
        swapused: 0,
        swapfree: 0,
        writeback: null,
        dirty: null
      };
      if (_linux$c) {
        try {
          fs$6.readFile("/proc/meminfo", function(error, stdout) {
            if (!error) {
              const lines = stdout.toString().split("\n");
              result2.total = parseInt(util$e.getValue(lines, "memtotal"), 10);
              result2.total = result2.total ? result2.total * 1024 : os$5.totalmem();
              result2.free = parseInt(util$e.getValue(lines, "memfree"), 10);
              result2.free = result2.free ? result2.free * 1024 : os$5.freemem();
              result2.used = result2.total - result2.free;
              result2.buffers = parseInt(util$e.getValue(lines, "buffers"), 10);
              result2.buffers = result2.buffers ? result2.buffers * 1024 : 0;
              result2.cached = parseInt(util$e.getValue(lines, "cached"), 10);
              result2.cached = result2.cached ? result2.cached * 1024 : 0;
              result2.slab = parseInt(util$e.getValue(lines, "slab"), 10);
              result2.slab = result2.slab ? result2.slab * 1024 : 0;
              result2.buffcache = result2.buffers + result2.cached + result2.slab;
              let available = parseInt(util$e.getValue(lines, "memavailable"), 10);
              result2.available = available ? available * 1024 : result2.free + result2.buffcache;
              result2.active = result2.total - result2.available;
              result2.swaptotal = parseInt(util$e.getValue(lines, "swaptotal"), 10);
              result2.swaptotal = result2.swaptotal ? result2.swaptotal * 1024 : 0;
              result2.swapfree = parseInt(util$e.getValue(lines, "swapfree"), 10);
              result2.swapfree = result2.swapfree ? result2.swapfree * 1024 : 0;
              result2.swapused = result2.swaptotal - result2.swapfree;
              result2.writeback = parseInt(util$e.getValue(lines, "writeback"), 10);
              result2.writeback = result2.writeback ? result2.writeback * 1024 : 0;
              result2.dirty = parseInt(util$e.getValue(lines, "dirty"), 10);
              result2.dirty = result2.dirty ? result2.dirty * 1024 : 0;
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_freebsd$b || _openbsd$b || _netbsd$b) {
        try {
          exec$c("/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              const pagesize = parseInt(util$e.getValue(lines, "vm.stats.vm.v_page_size"), 10);
              const inactive = parseInt(util$e.getValue(lines, "vm.stats.vm.v_inactive_count"), 10) * pagesize;
              const cache = parseInt(util$e.getValue(lines, "vm.stats.vm.v_cache_count"), 10) * pagesize;
              result2.total = parseInt(util$e.getValue(lines, "hw.realmem"), 10);
              if (isNaN(result2.total)) {
                result2.total = parseInt(util$e.getValue(lines, "hw.physmem"), 10);
              }
              result2.free = parseInt(util$e.getValue(lines, "vm.stats.vm.v_free_count"), 10) * pagesize;
              result2.buffcache = inactive + cache;
              result2.available = result2.buffcache + result2.free;
              result2.active = result2.total - result2.free - result2.buffcache;
              result2.swaptotal = 0;
              result2.swapfree = 0;
              result2.swapused = 0;
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_sunos$b) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_darwin$c) {
        let pageSize = 4096;
        try {
          let sysPpageSize = util$e.toInt(execSync$7("sysctl -n vm.pagesize").toString());
          pageSize = sysPpageSize || pageSize;
        } catch (e) {
          util$e.noop();
        }
        try {
          exec$c('vm_stat 2>/dev/null | grep "Pages active"', function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result2.active = parseInt(lines[0].split(":")[1], 10) * pageSize;
              result2.buffcache = result2.used - result2.active;
              result2.available = result2.free + result2.buffcache;
            }
            exec$c("sysctl -n vm.swapusage 2>/dev/null", function(error2, stdout2) {
              if (!error2) {
                let lines = stdout2.toString().split("\n");
                if (lines.length > 0) {
                  let firstline = lines[0].replace(/,/g, ".").replace(/M/g, "");
                  let lineArray = firstline.trim().split("  ");
                  lineArray.forEach((line) => {
                    if (line.toLowerCase().indexOf("total") !== -1) {
                      result2.swaptotal = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                    }
                    if (line.toLowerCase().indexOf("used") !== -1) {
                      result2.swapused = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                    }
                    if (line.toLowerCase().indexOf("free") !== -1) {
                      result2.swapfree = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                    }
                  });
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_windows$d) {
        let swaptotal = 0;
        let swapused = 0;
        try {
          util$e.powerShell("Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage").then((stdout, error) => {
            if (!error) {
              let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
              lines.forEach(function(line) {
                if (line !== "") {
                  line = line.trim().split(/\s\s+/);
                  swaptotal = swaptotal + (parseInt(line[0], 10) || 0);
                  swapused = swapused + (parseInt(line[1], 10) || 0);
                }
              });
            }
            result2.swaptotal = swaptotal * 1024 * 1024;
            result2.swapused = swapused * 1024 * 1024;
            result2.swapfree = result2.swaptotal - result2.swapused;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
memory.mem = mem;
function memLayout(callback) {
  function getManufacturerDarwin(manId) {
    if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {
      return OSX_RAM_manufacturers[manId];
    }
    return manId;
  }
  function getManufacturerLinux(manId) {
    const manIdSearch = manId.replace("0x", "").toUpperCase();
    if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {
      return LINUX_RAM_manufacturers[manIdSearch];
    }
    return manId;
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$c || _freebsd$b || _openbsd$b || _netbsd$b) {
        exec$c('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE "Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number"; unset LC_ALL', function(error, stdout) {
          if (!error) {
            let devices = stdout.toString().split("Memory Device");
            devices.shift();
            devices.forEach(function(device) {
              let lines = device.split("\n");
              const sizeString = util$e.getValue(lines, "Size");
              const size = sizeString.indexOf("GB") >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;
              let bank = util$e.getValue(lines, "Bank Locator");
              if (bank.toLowerCase().indexOf("bad") >= 0) {
                bank = "";
              }
              if (parseInt(util$e.getValue(lines, "Size"), 10) > 0) {
                const totalWidth = util$e.toInt(util$e.getValue(lines, "Total Width"));
                const dataWidth = util$e.toInt(util$e.getValue(lines, "Data Width"));
                result2.push({
                  size,
                  bank,
                  type: util$e.getValue(lines, "Type:"),
                  ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                  clockSpeed: util$e.getValue(lines, "Configured Clock Speed:") ? parseInt(util$e.getValue(lines, "Configured Clock Speed:"), 10) : util$e.getValue(lines, "Speed:") ? parseInt(util$e.getValue(lines, "Speed:"), 10) : null,
                  formFactor: util$e.getValue(lines, "Form Factor:"),
                  manufacturer: getManufacturerLinux(util$e.getValue(lines, "Manufacturer:")),
                  partNum: util$e.getValue(lines, "Part Number:"),
                  serialNum: util$e.getValue(lines, "Serial Number:"),
                  voltageConfigured: parseFloat(util$e.getValue(lines, "Configured Voltage:")) || null,
                  voltageMin: parseFloat(util$e.getValue(lines, "Minimum Voltage:")) || null,
                  voltageMax: parseFloat(util$e.getValue(lines, "Maximum Voltage:")) || null
                });
              } else {
                result2.push({
                  size: 0,
                  bank,
                  type: "Empty",
                  ecc: null,
                  clockSpeed: 0,
                  formFactor: util$e.getValue(lines, "Form Factor:"),
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
              }
            });
          }
          if (!result2.length) {
            result2.push({
              size: os$5.totalmem(),
              bank: "",
              type: "",
              ecc: null,
              clockSpeed: 0,
              formFactor: "",
              partNum: "",
              serialNum: "",
              voltageConfigured: null,
              voltageMin: null,
              voltageMax: null
            });
            try {
              let stdout2 = execSync$7("cat /proc/cpuinfo 2>/dev/null", util$e.execOptsLinux);
              let lines = stdout2.toString().split("\n");
              let version2 = util$e.getValue(lines, "revision", ":", true).toLowerCase();
              if (util$e.isRaspberry(lines)) {
                const clockSpeed = {
                  "0": 400,
                  "1": 450,
                  "2": 450,
                  "3": 3200,
                  "4": 4267
                };
                result2[0].type = "LPDDR2";
                result2[0].type = version2 && version2[2] && version2[2] === "3" ? "LPDDR4" : result2[0].type;
                result2[0].type = version2 && version2[2] && version2[2] === "4" ? "LPDDR4X" : result2[0].type;
                result2[0].ecc = false;
                result2[0].clockSpeed = version2 && version2[2] && clockSpeed[version2[2]] || 400;
                result2[0].clockSpeed = version2 && version2[4] && version2[4] === "d" ? 500 : result2[0].clockSpeed;
                result2[0].formFactor = "SoC";
                stdout2 = execSync$7("vcgencmd get_config sdram_freq 2>/dev/null", util$e.execOptsLinux);
                lines = stdout2.toString().split("\n");
                let freq = parseInt(util$e.getValue(lines, "sdram_freq", "=", true), 10) || 0;
                if (freq) {
                  result2[0].clockSpeed = freq;
                }
                stdout2 = execSync$7("vcgencmd measure_volts sdram_p 2>/dev/null", util$e.execOptsLinux);
                lines = stdout2.toString().split("\n");
                let voltage = parseFloat(util$e.getValue(lines, "volt", "=", true)) || 0;
                if (voltage) {
                  result2[0].voltageConfigured = voltage;
                  result2[0].voltageMin = voltage;
                  result2[0].voltageMax = voltage;
                }
              }
            } catch (e) {
              util$e.noop();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$c) {
        exec$c("system_profiler SPMemoryDataType", function(error, stdout) {
          if (!error) {
            const allLines = stdout.toString().split("\n");
            const eccStatus = util$e.getValue(allLines, "ecc", ":", true).toLowerCase();
            let devices = stdout.toString().split("        BANK ");
            let hasBank = true;
            if (devices.length === 1) {
              devices = stdout.toString().split("        DIMM");
              hasBank = false;
            }
            devices.shift();
            devices.forEach(function(device) {
              let lines = device.split("\n");
              const bank = (hasBank ? "BANK " : "DIMM") + lines[0].trim().split("/")[0];
              const size = parseInt(util$e.getValue(lines, "          Size"));
              if (size) {
                result2.push({
                  size: size * 1024 * 1024 * 1024,
                  bank,
                  type: util$e.getValue(lines, "          Type:"),
                  ecc: eccStatus ? eccStatus === "enabled" : null,
                  clockSpeed: parseInt(util$e.getValue(lines, "          Speed:"), 10),
                  formFactor: "",
                  manufacturer: getManufacturerDarwin(util$e.getValue(lines, "          Manufacturer:")),
                  partNum: util$e.getValue(lines, "          Part Number:"),
                  serialNum: util$e.getValue(lines, "          Serial Number:"),
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
              } else {
                result2.push({
                  size: 0,
                  bank,
                  type: "Empty",
                  ecc: null,
                  clockSpeed: 0,
                  formFactor: "",
                  manufacturer: "",
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
              }
            });
          }
          if (!result2.length) {
            const lines = stdout.toString().split("\n");
            const size = parseInt(util$e.getValue(lines, "      Memory:"));
            const type = util$e.getValue(lines, "      Type:");
            const manufacturerId = util$e.getValue(lines, "      Manufacturer:");
            if (size && type) {
              result2.push({
                size: size * 1024 * 1024 * 1024,
                bank: "0",
                type,
                ecc: false,
                clockSpeed: null,
                formFactor: "SOC",
                manufacturer: getManufacturerDarwin(manufacturerId),
                partNum: "",
                serialNum: "",
                voltageConfigured: null,
                voltageMin: null,
                voltageMax: null
              });
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$b) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$d) {
        const memoryTypes = "Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4|Logical non-volatile device|HBM|HBM2|DDR5|LPDDR5".split("|");
        const FormFactors = "Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA".split("|");
        try {
          util$e.powerShell("Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,Speed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage,Tag | fl").then((stdout, error) => {
            if (!error) {
              let devices = stdout.toString().split(/\n\s*\n/);
              devices.shift();
              devices.forEach(function(device) {
                let lines = device.split("\r\n");
                const dataWidth = util$e.toInt(util$e.getValue(lines, "DataWidth", ":"));
                const totalWidth = util$e.toInt(util$e.getValue(lines, "TotalWidth", ":"));
                const size = parseInt(util$e.getValue(lines, "Capacity", ":"), 10) || 0;
                const tag = util$e.getValue(lines, "Tag", ":");
                const tagInt = util$e.splitByNumber(tag);
                if (size) {
                  result2.push({
                    size,
                    bank: util$e.getValue(lines, "BankLabel", ":") + (tagInt[1] ? "/" + tagInt[1] : ""),
                    // BankLabel
                    type: memoryTypes[parseInt(util$e.getValue(lines, "MemoryType", ":"), 10) || parseInt(util$e.getValue(lines, "SMBIOSMemoryType", ":"), 10)],
                    ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                    clockSpeed: parseInt(util$e.getValue(lines, "ConfiguredClockSpeed", ":"), 10) || parseInt(util$e.getValue(lines, "Speed", ":"), 10) || 0,
                    formFactor: FormFactors[parseInt(util$e.getValue(lines, "FormFactor", ":"), 10) || 0],
                    manufacturer: util$e.getValue(lines, "Manufacturer", ":"),
                    partNum: util$e.getValue(lines, "PartNumber", ":"),
                    serialNum: util$e.getValue(lines, "SerialNumber", ":"),
                    voltageConfigured: (parseInt(util$e.getValue(lines, "ConfiguredVoltage", ":"), 10) || 0) / 1e3,
                    voltageMin: (parseInt(util$e.getValue(lines, "MinVoltage", ":"), 10) || 0) / 1e3,
                    voltageMax: (parseInt(util$e.getValue(lines, "MaxVoltage", ":"), 10) || 0) / 1e3
                  });
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
memory.memLayout = memLayout;
const exec$b = require$$1$1.exec;
const fs$5 = require$$1$2;
const util$d = util$j;
let _platform$c = process.platform;
const _linux$b = _platform$c === "linux" || _platform$c === "android";
const _darwin$b = _platform$c === "darwin";
const _windows$c = _platform$c === "win32";
const _freebsd$a = _platform$c === "freebsd";
const _openbsd$a = _platform$c === "openbsd";
const _netbsd$a = _platform$c === "netbsd";
const _sunos$a = _platform$c === "sunos";
function parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {
  const result2 = {};
  let status = util$d.getValue(lines, "BatteryStatus", ":").trim();
  if (status >= 0) {
    const statusValue = status ? parseInt(status) : 0;
    result2.status = statusValue;
    result2.hasBattery = true;
    result2.maxCapacity = fullChargeCapacity || parseInt(util$d.getValue(lines, "DesignCapacity", ":") || 0);
    result2.designedCapacity = parseInt(util$d.getValue(lines, "DesignCapacity", ":") || designedCapacity);
    result2.voltage = parseInt(util$d.getValue(lines, "DesignVoltage", ":") || 0) / 1e3;
    result2.capacityUnit = "mWh";
    result2.percent = parseInt(util$d.getValue(lines, "EstimatedChargeRemaining", ":") || 0);
    result2.currentCapacity = parseInt(result2.maxCapacity * result2.percent / 100);
    result2.isCharging = statusValue >= 6 && statusValue <= 9 || statusValue === 11 || statusValue !== 3 && statusValue !== 1 && result2.percent < 100;
    result2.acConnected = result2.isCharging || statusValue === 2;
    result2.model = util$d.getValue(lines, "DeviceID", ":");
  } else {
    result2.status = -1;
  }
  return result2;
}
var battery = function(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        hasBattery: false,
        cycleCount: 0,
        isCharging: false,
        designedCapacity: 0,
        maxCapacity: 0,
        currentCapacity: 0,
        voltage: 0,
        capacityUnit: "",
        percent: 0,
        timeRemaining: null,
        acConnected: true,
        type: "",
        model: "",
        manufacturer: "",
        serial: ""
      };
      if (_linux$b) {
        let battery_path = "";
        if (fs$5.existsSync("/sys/class/power_supply/BAT1/uevent")) {
          battery_path = "/sys/class/power_supply/BAT1/";
        } else if (fs$5.existsSync("/sys/class/power_supply/BAT0/uevent")) {
          battery_path = "/sys/class/power_supply/BAT0/";
        }
        let acConnected = false;
        let acPath = "";
        if (fs$5.existsSync("/sys/class/power_supply/AC/online")) {
          acPath = "/sys/class/power_supply/AC/online";
        } else if (fs$5.existsSync("/sys/class/power_supply/AC0/online")) {
          acPath = "/sys/class/power_supply/AC0/online";
        }
        if (acPath) {
          const file = fs$5.readFileSync(acPath);
          acConnected = file.toString().trim() === "1";
        }
        if (battery_path) {
          fs$5.readFile(battery_path + "uevent", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result2.isCharging = util$d.getValue(lines, "POWER_SUPPLY_STATUS", "=").toLowerCase() === "charging";
              result2.acConnected = acConnected || result2.isCharging;
              result2.voltage = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_VOLTAGE_NOW", "="), 10) / 1e6;
              result2.capacityUnit = result2.voltage ? "mWh" : "mAh";
              result2.cycleCount = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_CYCLE_COUNT", "="), 10);
              result2.maxCapacity = Math.round(parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_CHARGE_FULL", "=", true, true), 10) / 1e3 * (result2.voltage || 1));
              const desingedMinVoltage = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_VOLTAGE_MIN_DESIGN", "="), 10) / 1e6;
              result2.designedCapacity = Math.round(parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_CHARGE_FULL_DESIGN", "=", true, true), 10) / 1e3 * (desingedMinVoltage || result2.voltage || 1));
              result2.currentCapacity = Math.round(parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10) / 1e3 * (result2.voltage || 1));
              if (!result2.maxCapacity) {
                result2.maxCapacity = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_ENERGY_FULL", "=", true, true), 10) / 1e3;
                result2.designedCapacity = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_ENERGY_FULL_DESIGN", "=", true, true), 10) / 1e3 | result2.maxCapacity;
                result2.currentCapacity = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10) / 1e3;
              }
              const percent = util$d.getValue(lines, "POWER_SUPPLY_CAPACITY", "=");
              const energy = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10);
              const power = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_POWER_NOW", "="), 10);
              const current = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_CURRENT_NOW", "="), 10);
              const charge = parseInt("0" + util$d.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10);
              result2.percent = parseInt("0" + percent, 10);
              if (result2.maxCapacity && result2.currentCapacity) {
                result2.hasBattery = true;
                if (!percent) {
                  result2.percent = 100 * result2.currentCapacity / result2.maxCapacity;
                }
              }
              if (result2.isCharging) {
                result2.hasBattery = true;
              }
              if (energy && power) {
                result2.timeRemaining = Math.floor(energy / power * 60);
              } else if (current && charge) {
                result2.timeRemaining = Math.floor(charge / current * 60);
              } else if (current && result2.currentCapacity) {
                result2.timeRemaining = Math.floor(result2.currentCapacity / current * 60);
              }
              result2.type = util$d.getValue(lines, "POWER_SUPPLY_TECHNOLOGY", "=");
              result2.model = util$d.getValue(lines, "POWER_SUPPLY_MODEL_NAME", "=");
              result2.manufacturer = util$d.getValue(lines, "POWER_SUPPLY_MANUFACTURER", "=");
              result2.serial = util$d.getValue(lines, "POWER_SUPPLY_SERIAL_NUMBER", "=");
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_freebsd$a || _openbsd$a || _netbsd$a) {
        exec$b("sysctl -i hw.acpi.battery hw.acpi.acline", function(error, stdout) {
          let lines = stdout.toString().split("\n");
          const batteries = parseInt("0" + util$d.getValue(lines, "hw.acpi.battery.units"), 10);
          const percent = parseInt("0" + util$d.getValue(lines, "hw.acpi.battery.life"), 10);
          result2.hasBattery = batteries > 0;
          result2.cycleCount = null;
          result2.isCharging = util$d.getValue(lines, "hw.acpi.acline") !== "1";
          result2.acConnected = result2.isCharging;
          result2.maxCapacity = null;
          result2.currentCapacity = null;
          result2.capacityUnit = "unknown";
          result2.percent = batteries ? percent : null;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$b) {
        exec$b('ioreg -n AppleSmartBattery -r | egrep "CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|DeviceName|BatterySerialNumber|Serial|TimeRemaining|Voltage"; pmset -g batt | grep %', function(error, stdout) {
          if (stdout) {
            let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").replace(/-/g, "").split("\n");
            result2.cycleCount = parseInt("0" + util$d.getValue(lines, "cyclecount", "="), 10);
            result2.voltage = parseInt("0" + util$d.getValue(lines, "voltage", "="), 10) / 1e3;
            result2.capacityUnit = result2.voltage ? "mWh" : "mAh";
            result2.maxCapacity = Math.round(parseInt("0" + util$d.getValue(lines, "applerawmaxcapacity", "="), 10) * (result2.voltage || 1));
            result2.currentCapacity = Math.round(parseInt("0" + util$d.getValue(lines, "applerawcurrentcapacity", "="), 10) * (result2.voltage || 1));
            result2.designedCapacity = Math.round(parseInt("0" + util$d.getValue(lines, "DesignCapacity", "="), 10) * (result2.voltage || 1));
            result2.manufacturer = "Apple";
            result2.serial = util$d.getValue(lines, "BatterySerialNumber", "=") || util$d.getValue(lines, "Serial", "=");
            result2.model = util$d.getValue(lines, "DeviceName", "=");
            let percent = null;
            const line = util$d.getValue(lines, "internal", "Battery");
            let parts = line.split(";");
            if (parts && parts[0]) {
              let parts2 = parts[0].split("	");
              if (parts2 && parts2[1]) {
                percent = parseFloat(parts2[1].trim().replace(/%/g, ""));
              }
            }
            if (parts && parts[1]) {
              result2.isCharging = parts[1].trim() === "charging";
              result2.acConnected = parts[1].trim() !== "discharging";
            } else {
              result2.isCharging = util$d.getValue(lines, "ischarging", "=").toLowerCase() === "yes";
              result2.acConnected = result2.isCharging;
            }
            if (result2.maxCapacity && result2.currentCapacity) {
              result2.hasBattery = true;
              result2.type = "Li-ion";
              result2.percent = percent !== null ? percent : Math.round(100 * result2.currentCapacity / result2.maxCapacity);
              if (!result2.isCharging) {
                result2.timeRemaining = parseInt("0" + util$d.getValue(lines, "TimeRemaining", "="), 10);
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$a) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows$c) {
        try {
          const workload = [];
          workload.push(util$d.powerShell("Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl"));
          workload.push(util$d.powerShell("(Get-WmiObject -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity"));
          workload.push(util$d.powerShell("(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity"));
          util$d.promiseAll(
            workload
          ).then((data) => {
            if (data) {
              let parts = data.results[0].split(/\n\s*\n/);
              let batteries = [];
              const hasValue = (value) => /\S/.test(value);
              for (let i = 0; i < parts.length; i++) {
                if (hasValue(parts[i]) && (!batteries.length || !hasValue(parts[i - 1]))) {
                  batteries.push([]);
                }
                if (hasValue(parts[i])) {
                  batteries[batteries.length - 1].push(parts[i]);
                }
              }
              let designCapacities = data.results[1].split("\r\n").filter((e) => e);
              let fullChargeCapacities = data.results[2].split("\r\n").filter((e) => e);
              if (batteries.length) {
                let first = false;
                let additionalBatteries = [];
                for (let i = 0; i < batteries.length; i++) {
                  let lines = batteries[i][0].split("\r\n");
                  const designedCapacity = designCapacities && designCapacities.length >= i + 1 && designCapacities[i] ? util$d.toInt(designCapacities[i]) : 0;
                  const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= i + 1 && fullChargeCapacities[i] ? util$d.toInt(fullChargeCapacities[i]) : 0;
                  const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);
                  if (!first && parsed.status > 0 && parsed.status !== 10) {
                    result2.hasBattery = parsed.hasBattery;
                    result2.maxCapacity = parsed.maxCapacity;
                    result2.designedCapacity = parsed.designedCapacity;
                    result2.voltage = parsed.voltage;
                    result2.capacityUnit = parsed.capacityUnit;
                    result2.percent = parsed.percent;
                    result2.currentCapacity = parsed.currentCapacity;
                    result2.isCharging = parsed.isCharging;
                    result2.acConnected = parsed.acConnected;
                    result2.model = parsed.model;
                    first = true;
                  } else if (parsed.status !== -1) {
                    additionalBatteries.push(
                      {
                        hasBattery: parsed.hasBattery,
                        maxCapacity: parsed.maxCapacity,
                        designedCapacity: parsed.designedCapacity,
                        voltage: parsed.voltage,
                        capacityUnit: parsed.capacityUnit,
                        percent: parsed.percent,
                        currentCapacity: parsed.currentCapacity,
                        isCharging: parsed.isCharging,
                        timeRemaining: null,
                        acConnected: parsed.acConnected,
                        model: parsed.model,
                        type: "",
                        manufacturer: "",
                        serial: ""
                      }
                    );
                  }
                }
                if (!first && additionalBatteries.length) {
                  result2 = additionalBatteries[0];
                  additionalBatteries.shift();
                }
                if (additionalBatteries.length) {
                  result2.additionalBatteries = additionalBatteries;
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
};
var graphics$1 = {};
const fs$4 = require$$1$2;
const exec$a = require$$1$1.exec;
const execSync$6 = require$$1$1.execSync;
const util$c = util$j;
let _platform$b = process.platform;
let _nvidiaSmiPath = "";
const _linux$a = _platform$b === "linux" || _platform$b === "android";
const _darwin$a = _platform$b === "darwin";
const _windows$b = _platform$b === "win32";
const _freebsd$9 = _platform$b === "freebsd";
const _openbsd$9 = _platform$b === "openbsd";
const _netbsd$9 = _platform$b === "netbsd";
const _sunos$9 = _platform$b === "sunos";
let _resolutionX = 0;
let _resolutionY = 0;
let _pixelDepth = 0;
let _refreshRate = 0;
const videoTypes = {
  "-2": "UNINITIALIZED",
  "-1": "OTHER",
  "0": "HD15",
  "1": "SVIDEO",
  "2": "Composite video",
  "3": "Component video",
  "4": "DVI",
  "5": "HDMI",
  "6": "LVDS",
  "8": "D_JPN",
  "9": "SDI",
  "10": "DP",
  "11": "DP embedded",
  "12": "UDI",
  "13": "UDI embedded",
  "14": "SDTVDONGLE",
  "15": "MIRACAST",
  "2147483648": "INTERNAL"
};
function getVendorFromModel(model) {
  const manufacturers = [
    { pattern: "^LG.+", manufacturer: "LG" },
    { pattern: "^BENQ.+", manufacturer: "BenQ" },
    { pattern: "^ASUS.+", manufacturer: "Asus" },
    { pattern: "^DELL.+", manufacturer: "Dell" },
    { pattern: "^SAMSUNG.+", manufacturer: "Samsung" },
    { pattern: "^VIEWSON.+", manufacturer: "ViewSonic" },
    { pattern: "^SONY.+", manufacturer: "Sony" },
    { pattern: "^ACER.+", manufacturer: "Acer" },
    { pattern: "^AOC.+", manufacturer: "AOC Monitors" },
    { pattern: "^HP.+", manufacturer: "HP" },
    { pattern: "^EIZO.?", manufacturer: "Eizo" },
    { pattern: "^PHILIPS.?", manufacturer: "Philips" },
    { pattern: "^IIYAMA.?", manufacturer: "Iiyama" },
    { pattern: "^SHARP.?", manufacturer: "Sharp" },
    { pattern: "^NEC.?", manufacturer: "NEC" },
    { pattern: "^LENOVO.?", manufacturer: "Lenovo" },
    { pattern: "COMPAQ.?", manufacturer: "Compaq" },
    { pattern: "APPLE.?", manufacturer: "Apple" },
    { pattern: "INTEL.?", manufacturer: "Intel" },
    { pattern: "AMD.?", manufacturer: "AMD" },
    { pattern: "NVIDIA.?", manufacturer: "NVDIA" }
  ];
  let result2 = "";
  if (model) {
    model = model.toUpperCase();
    manufacturers.forEach((manufacturer) => {
      const re = RegExp(manufacturer.pattern);
      if (re.test(model)) {
        result2 = manufacturer.manufacturer;
      }
    });
  }
  return result2;
}
function getVendorFromId(id) {
  const vendors = {
    "610": "Apple",
    "1e6d": "LG",
    "10ac": "DELL",
    "4dd9": "Sony",
    "38a3": "NEC"
  };
  return vendors[id] || "";
}
function vendorToId(str) {
  let result2 = "";
  str = (str || "").toLowerCase();
  if (str.indexOf("apple") >= 0) {
    result2 = "0x05ac";
  } else if (str.indexOf("nvidia") >= 0) {
    result2 = "0x10de";
  } else if (str.indexOf("intel") >= 0) {
    result2 = "0x8086";
  } else if (str.indexOf("ati") >= 0 || str.indexOf("amd") >= 0) {
    result2 = "0x1002";
  }
  return result2;
}
function getMetalVersion(id) {
  const families = {
    "spdisplays_mtlgpufamilymac1": "mac1",
    "spdisplays_mtlgpufamilymac2": "mac2",
    "spdisplays_mtlgpufamilyapple1": "apple1",
    "spdisplays_mtlgpufamilyapple2": "apple2",
    "spdisplays_mtlgpufamilyapple3": "apple3",
    "spdisplays_mtlgpufamilyapple4": "apple4",
    "spdisplays_mtlgpufamilyapple5": "apple5",
    "spdisplays_mtlgpufamilyapple6": "apple6",
    "spdisplays_mtlgpufamilyapple7": "apple7",
    "spdisplays_metalfeaturesetfamily11": "family1_v1",
    "spdisplays_metalfeaturesetfamily12": "family1_v2",
    "spdisplays_metalfeaturesetfamily13": "family1_v3",
    "spdisplays_metalfeaturesetfamily14": "family1_v4",
    "spdisplays_metalfeaturesetfamily21": "family2_v1"
  };
  return families[id] || "";
}
function graphics(callback) {
  function parseLinesDarwin(graphicsArr) {
    const res = {
      controllers: [],
      displays: []
    };
    try {
      graphicsArr.forEach(function(item) {
        const bus = (item.sppci_bus || "").indexOf("builtin") > -1 ? "Built-In" : (item.sppci_bus || "").indexOf("pcie") > -1 ? "PCIe" : "";
        const vram = (parseInt(item.spdisplays_vram || "", 10) || 0) * ((item.spdisplays_vram || "").indexOf("GB") > -1 ? 1024 : 1);
        const vramDyn = (parseInt(item.spdisplays_vram_shared || "", 10) || 0) * ((item.spdisplays_vram_shared || "").indexOf("GB") > -1 ? 1024 : 1);
        let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || "");
        res.controllers.push({
          vendor: getVendorFromModel(item.spdisplays_vendor || "") || item.spdisplays_vendor || "",
          model: item.sppci_model || "",
          bus,
          vramDynamic: bus === "Built-In",
          vram: vram || vramDyn || null,
          deviceId: item["spdisplays_device-id"] || "",
          vendorId: item["spdisplays_vendor-id"] || vendorToId((item["spdisplays_vendor"] || "") + (item.sppci_model || "")),
          external: item.sppci_device_type === "spdisplays_egpu",
          cores: item["sppci_cores"] || null,
          metalVersion
        });
        if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {
          item.spdisplays_ndrvs.forEach(function(displayItem) {
            const connectionType = displayItem["spdisplays_connection_type"] || "";
            const currentResolutionParts = (displayItem["_spdisplays_resolution"] || "").split("@");
            const currentResolution = currentResolutionParts[0].split("x");
            const pixelParts = (displayItem["_spdisplays_pixels"] || "").split("x");
            const pixelDepthString = displayItem["spdisplays_depth"] || "";
            const serial = displayItem["_spdisplays_display-serial-number"] || displayItem["_spdisplays_display-serial-number2"] || null;
            res.displays.push({
              vendor: getVendorFromId(displayItem["_spdisplays_display-vendor-id"] || "") || getVendorFromModel(displayItem["_name"] || ""),
              vendorId: displayItem["_spdisplays_display-vendor-id"] || "",
              model: displayItem["_name"] || "",
              productionYear: displayItem["_spdisplays_display-year"] || null,
              serial: serial !== "0" ? serial : null,
              displayId: displayItem["_spdisplays_displayID"] || null,
              main: displayItem["spdisplays_main"] ? displayItem["spdisplays_main"] === "spdisplays_yes" : false,
              builtin: (displayItem["spdisplays_display_type"] || "").indexOf("built-in") > -1,
              connection: connectionType.indexOf("_internal") > -1 ? "Internal" : connectionType.indexOf("_displayport") > -1 ? "Display Port" : connectionType.indexOf("_hdmi") > -1 ? "HDMI" : null,
              sizeX: null,
              sizeY: null,
              pixelDepth: pixelDepthString === "CGSThirtyBitColor" ? 30 : pixelDepthString === "CGSThirtytwoBitColor" ? 32 : pixelDepthString === "CGSTwentyfourBitColor" ? 24 : null,
              resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,
              resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,
              currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,
              currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,
              positionX: 0,
              positionY: 0,
              currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null
            });
          });
        }
      });
      return res;
    } catch (e) {
      return res;
    }
  }
  function parseLinesLinuxControllers(lines) {
    let controllers = [];
    let currentController = {
      vendor: "",
      subVendor: "",
      model: "",
      bus: "",
      busAddress: "",
      vram: null,
      vramDynamic: false,
      pciID: ""
    };
    let isGraphicsController = false;
    let pciIDs = [];
    try {
      pciIDs = execSync$6('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep "Bus Address: "', util$c.execOptsLinux).toString().split("\n");
      for (let i2 = 0; i2 < pciIDs.length; i2++) {
        pciIDs[i2] = pciIDs[i2].replace("Bus Address:", "").replace("0000:", "").trim();
      }
      pciIDs = pciIDs.filter(function(el) {
        return el != null && el;
      });
    } catch (e) {
      util$c.noop();
    }
    let i = 1;
    lines.forEach((line) => {
      let subsystem = "";
      if (i < lines.length && lines[i]) {
        subsystem = lines[i];
        if (subsystem.indexOf(":") > 0) {
          subsystem = subsystem.split(":")[1];
        }
      }
      if ("" !== line.trim()) {
        if (" " !== line[0] && "	" !== line[0]) {
          let isExternal = pciIDs.indexOf(line.split(" ")[0]) >= 0;
          let vgapos = line.toLowerCase().indexOf(" vga ");
          let _3dcontrollerpos = line.toLowerCase().indexOf("3d controller");
          if (vgapos !== -1 || _3dcontrollerpos !== -1) {
            if (_3dcontrollerpos !== -1 && vgapos === -1) {
              vgapos = _3dcontrollerpos;
            }
            if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) {
              controllers.push(currentController);
              currentController = {
                vendor: "",
                model: "",
                bus: "",
                busAddress: "",
                vram: null,
                vramDynamic: false
              };
            }
            const pciIDCandidate = line.split(" ")[0];
            if (/[\da-fA-F]{2}:[\da-fA-F]{2}\.[\da-fA-F]/.test(pciIDCandidate)) {
              currentController.busAddress = pciIDCandidate;
            }
            isGraphicsController = true;
            let endpos = line.search(/\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);
            let parts = line.substr(vgapos, endpos - vgapos).split(":");
            currentController.busAddress = line.substr(0, vgapos).trim();
            if (parts.length > 1) {
              parts[1] = parts[1].trim();
              if (parts[1].toLowerCase().indexOf("corporation") >= 0) {
                currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("corporation") + 11).trim();
                currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("corporation") + 11, 200).split("(")[0].trim();
                currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                currentController.vram = null;
                currentController.vramDynamic = false;
              } else if (parts[1].toLowerCase().indexOf(" inc.") >= 0) {
                if ((parts[1].match(/]/g) || []).length > 1) {
                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                } else {
                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" inc.") + 5).trim();
                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" inc.") + 5, 200).trim().split("(")[0].trim();
                }
                currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                currentController.vram = null;
                currentController.vramDynamic = false;
              } else if (parts[1].toLowerCase().indexOf(" ltd.") >= 0) {
                if ((parts[1].match(/]/g) || []).length > 1) {
                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                } else {
                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" ltd.") + 5).trim();
                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" ltd.") + 5, 200).trim().split("(")[0].trim();
                }
              }
              if (currentController.model && subsystem.indexOf(currentController.model) !== -1) {
                const subVendor = subsystem.split(currentController.model)[0].trim();
                if (subVendor) {
                  currentController.subVendor = subVendor;
                }
              }
            }
          } else {
            isGraphicsController = false;
          }
        }
        if (isGraphicsController) {
          let parts = line.split(":");
          if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("devicename") !== -1 && parts[1].toLowerCase().indexOf("onboard") !== -1) {
            currentController.bus = "Onboard";
          }
          if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("region") !== -1 && parts[1].toLowerCase().indexOf("memory") !== -1) {
            let memparts = parts[1].split("=");
            if (memparts.length > 1) {
              currentController.vram = parseInt(memparts[1]);
            }
          }
        }
      }
      i++;
    });
    if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) {
      controllers.push(currentController);
    }
    return controllers;
  }
  function parseLinesLinuxClinfo(controllers, lines) {
    const fieldPattern = /\[([^\]]+)\]\s+(\w+)\s+(.*)/;
    const devices = lines.reduce((devices2, line) => {
      const field = fieldPattern.exec(line.trim());
      if (field) {
        if (!devices2[field[1]]) {
          devices2[field[1]] = {};
        }
        devices2[field[1]][field[2]] = field[3];
      }
      return devices2;
    }, {});
    for (let deviceId in devices) {
      const device = devices[deviceId];
      if (device["CL_DEVICE_TYPE"] === "CL_DEVICE_TYPE_GPU") {
        let busAddress;
        if (device["CL_DEVICE_TOPOLOGY_AMD"]) {
          const bdf = device["CL_DEVICE_TOPOLOGY_AMD"].match(/[a-zA-Z0-9]+:\d+\.\d+/);
          if (bdf) {
            busAddress = bdf[0];
          }
        } else if (device["CL_DEVICE_PCI_BUS_ID_NV"] && device["CL_DEVICE_PCI_SLOT_ID_NV"]) {
          const bus = parseInt(device["CL_DEVICE_PCI_BUS_ID_NV"]);
          const slot = parseInt(device["CL_DEVICE_PCI_SLOT_ID_NV"]);
          if (!isNaN(bus) && !isNaN(slot)) {
            const b = bus & 255;
            const d = slot >> 3 & 255;
            const f = slot & 7;
            busAddress = `${b.toString().padStart(2, "0")}:${d.toString().padStart(2, "0")}.${f}`;
          }
        }
        if (busAddress) {
          let controller = controllers.find((controller2) => controller2.busAddress === busAddress);
          if (!controller) {
            controller = {
              vendor: "",
              model: "",
              bus: "",
              busAddress,
              vram: null,
              vramDynamic: false
            };
            controllers.push(controller);
          }
          controller.vendor = device["CL_DEVICE_VENDOR"];
          if (device["CL_DEVICE_BOARD_NAME_AMD"]) {
            controller.model = device["CL_DEVICE_BOARD_NAME_AMD"];
          } else {
            controller.model = device["CL_DEVICE_NAME"];
          }
          const memory2 = parseInt(device["CL_DEVICE_GLOBAL_MEM_SIZE"]);
          if (!isNaN(memory2)) {
            controller.vram = Math.round(memory2 / 1024 / 1024);
          }
        }
      }
    }
    return controllers;
  }
  function getNvidiaSmi() {
    if (_nvidiaSmiPath) {
      return _nvidiaSmiPath;
    }
    if (_windows$b) {
      try {
        const basePath = util$c.WINDIR + "\\System32\\DriverStore\\FileRepository";
        const candidateDirs = fs$4.readdirSync(basePath).filter((dir) => {
          return fs$4.readdirSync([basePath, dir].join("/")).includes("nvidia-smi.exe");
        });
        const targetDir = candidateDirs.reduce((prevDir, currentDir) => {
          const previousNvidiaSmi = fs$4.statSync([basePath, prevDir, "nvidia-smi.exe"].join("/"));
          const currentNvidiaSmi = fs$4.statSync([basePath, currentDir, "nvidia-smi.exe"].join("/"));
          return previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs ? prevDir : currentDir;
        });
        if (targetDir) {
          _nvidiaSmiPath = [basePath, targetDir, "nvidia-smi.exe"].join("/");
        }
      } catch (e) {
        util$c.noop();
      }
    } else if (_linux$a) {
      _nvidiaSmiPath = "nvidia-smi";
    }
    return _nvidiaSmiPath;
  }
  function nvidiaSmi(options) {
    const nvidiaSmiExe = getNvidiaSmi();
    options = options || util$c.execOptsWin;
    if (nvidiaSmiExe) {
      const nvidiaSmiOpts = "--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits";
      const cmd = nvidiaSmiExe + " " + nvidiaSmiOpts + (_linux$a ? "  2>/dev/null" : "");
      if (_linux$a) {
        options.stdio = ["pipe", "pipe", "ignore"];
      }
      try {
        const res = execSync$6(cmd, options).toString();
        return res;
      } catch (e) {
        util$c.noop();
      }
    }
    return "";
  }
  function nvidiaDevices() {
    function safeParseNumber(value) {
      if ([null, void 0].includes(value)) {
        return value;
      }
      return parseFloat(value);
    }
    const stdout = nvidiaSmi();
    if (!stdout) {
      return [];
    }
    const gpus = stdout.split("\n").filter(Boolean);
    let results = gpus.map((gpu) => {
      const splittedData = gpu.split(", ").map((value) => value.includes("N/A") ? void 0 : value);
      if (splittedData.length === 16) {
        return {
          driverVersion: splittedData[0],
          subDeviceId: splittedData[1],
          name: splittedData[2],
          pciBus: splittedData[3],
          fanSpeed: safeParseNumber(splittedData[4]),
          memoryTotal: safeParseNumber(splittedData[5]),
          memoryUsed: safeParseNumber(splittedData[6]),
          memoryFree: safeParseNumber(splittedData[7]),
          utilizationGpu: safeParseNumber(splittedData[8]),
          utilizationMemory: safeParseNumber(splittedData[9]),
          temperatureGpu: safeParseNumber(splittedData[10]),
          temperatureMemory: safeParseNumber(splittedData[11]),
          powerDraw: safeParseNumber(splittedData[12]),
          powerLimit: safeParseNumber(splittedData[13]),
          clockCore: safeParseNumber(splittedData[14]),
          clockMemory: safeParseNumber(splittedData[15])
        };
      } else {
        return {};
      }
    });
    results = results.filter((item) => {
      return "pciBus" in item;
    });
    return results;
  }
  function mergeControllerNvidia(controller, nvidia) {
    if (nvidia.driverVersion) {
      controller.driverVersion = nvidia.driverVersion;
    }
    if (nvidia.subDeviceId) {
      controller.subDeviceId = nvidia.subDeviceId;
    }
    if (nvidia.name) {
      controller.name = nvidia.name;
    }
    if (nvidia.pciBus) {
      controller.pciBus = nvidia.pciBus;
    }
    if (nvidia.fanSpeed) {
      controller.fanSpeed = nvidia.fanSpeed;
    }
    if (nvidia.memoryTotal) {
      controller.memoryTotal = nvidia.memoryTotal;
      controller.vram = nvidia.memoryTotal;
      controller.vramDynamic = false;
    }
    if (nvidia.memoryUsed) {
      controller.memoryUsed = nvidia.memoryUsed;
    }
    if (nvidia.memoryFree) {
      controller.memoryFree = nvidia.memoryFree;
    }
    if (nvidia.utilizationGpu) {
      controller.utilizationGpu = nvidia.utilizationGpu;
    }
    if (nvidia.utilizationMemory) {
      controller.utilizationMemory = nvidia.utilizationMemory;
    }
    if (nvidia.temperatureGpu) {
      controller.temperatureGpu = nvidia.temperatureGpu;
    }
    if (nvidia.temperatureMemory) {
      controller.temperatureMemory = nvidia.temperatureMemory;
    }
    if (nvidia.powerDraw) {
      controller.powerDraw = nvidia.powerDraw;
    }
    if (nvidia.powerLimit) {
      controller.powerLimit = nvidia.powerLimit;
    }
    if (nvidia.clockCore) {
      controller.clockCore = nvidia.clockCore;
    }
    if (nvidia.clockMemory) {
      controller.clockMemory = nvidia.clockMemory;
    }
    return controller;
  }
  function parseLinesLinuxEdid(edid) {
    let result2 = {
      vendor: "",
      model: "",
      deviceName: "",
      main: false,
      builtin: false,
      connection: "",
      sizeX: null,
      sizeY: null,
      pixelDepth: null,
      resolutionX: null,
      resolutionY: null,
      currentResX: null,
      currentResY: null,
      positionX: 0,
      positionY: 0,
      currentRefreshRate: null
    };
    let start = 108;
    if (edid.substr(start, 6) === "000000") {
      start += 36;
    }
    if (edid.substr(start, 6) === "000000") {
      start += 36;
    }
    if (edid.substr(start, 6) === "000000") {
      start += 36;
    }
    if (edid.substr(start, 6) === "000000") {
      start += 36;
    }
    result2.resolutionX = parseInt("0x0" + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));
    result2.resolutionY = parseInt("0x0" + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));
    result2.sizeX = parseInt("0x0" + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));
    result2.sizeY = parseInt("0x0" + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));
    start = edid.indexOf("000000fc00");
    if (start >= 0) {
      let model_raw = edid.substr(start + 10, 26);
      if (model_raw.indexOf("0a") !== -1) {
        model_raw = model_raw.substr(0, model_raw.indexOf("0a"));
      }
      try {
        if (model_raw.length > 2) {
          result2.model = model_raw.match(/.{1,2}/g).map(function(v) {
            return String.fromCharCode(parseInt(v, 16));
          }).join("");
        }
      } catch (e) {
        util$c.noop();
      }
    } else {
      result2.model = "";
    }
    return result2;
  }
  function parseLinesLinuxDisplays(lines, depth) {
    let displays = [];
    let currentDisplay = {
      vendor: "",
      model: "",
      deviceName: "",
      main: false,
      builtin: false,
      connection: "",
      sizeX: null,
      sizeY: null,
      pixelDepth: null,
      resolutionX: null,
      resolutionY: null,
      currentResX: null,
      currentResY: null,
      positionX: 0,
      positionY: 0,
      currentRefreshRate: null
    };
    let is_edid = false;
    let is_current = false;
    let edid_raw = "";
    let start = 0;
    for (let i = 1; i < lines.length; i++) {
      if ("" !== lines[i].trim()) {
        if (" " !== lines[i][0] && "	" !== lines[i][0] && lines[i].toLowerCase().indexOf(" connected ") !== -1) {
          if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
            displays.push(currentDisplay);
            currentDisplay = {
              vendor: "",
              model: "",
              main: false,
              builtin: false,
              connection: "",
              sizeX: null,
              sizeY: null,
              pixelDepth: null,
              resolutionX: null,
              resolutionY: null,
              currentResX: null,
              currentResY: null,
              positionX: 0,
              positionY: 0,
              currentRefreshRate: null
            };
          }
          let parts = lines[i].split(" ");
          currentDisplay.connection = parts[0];
          currentDisplay.main = lines[i].toLowerCase().indexOf(" primary ") >= 0;
          currentDisplay.builtin = parts[0].toLowerCase().indexOf("edp") >= 0;
        }
        if (is_edid) {
          if (lines[i].search(/\S|$/) > start) {
            edid_raw += lines[i].toLowerCase().trim();
          } else {
            let edid_decoded = parseLinesLinuxEdid(edid_raw);
            currentDisplay.vendor = edid_decoded.vendor;
            currentDisplay.model = edid_decoded.model;
            currentDisplay.resolutionX = edid_decoded.resolutionX;
            currentDisplay.resolutionY = edid_decoded.resolutionY;
            currentDisplay.sizeX = edid_decoded.sizeX;
            currentDisplay.sizeY = edid_decoded.sizeY;
            currentDisplay.pixelDepth = depth;
            is_edid = false;
          }
        }
        if (lines[i].toLowerCase().indexOf("edid:") >= 0) {
          is_edid = true;
          start = lines[i].search(/\S|$/);
        }
        if (lines[i].toLowerCase().indexOf("*current") >= 0) {
          const parts1 = lines[i].split("(");
          if (parts1 && parts1.length > 1 && parts1[0].indexOf("x") >= 0) {
            const resParts = parts1[0].trim().split("x");
            currentDisplay.currentResX = util$c.toInt(resParts[0]);
            currentDisplay.currentResY = util$c.toInt(resParts[1]);
          }
          is_current = true;
        }
        if (is_current && lines[i].toLowerCase().indexOf("clock") >= 0 && lines[i].toLowerCase().indexOf("hz") >= 0 && lines[i].toLowerCase().indexOf("v: height") >= 0) {
          const parts1 = lines[i].split("clock");
          if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf("hz") >= 0) {
            currentDisplay.currentRefreshRate = util$c.toInt(parts1[1]);
          }
          is_current = false;
        }
      }
    }
    if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
      displays.push(currentDisplay);
    }
    return displays;
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        controllers: [],
        displays: []
      };
      if (_darwin$a) {
        let cmd = "system_profiler -xml -detailLevel full SPDisplaysDataType";
        exec$a(cmd, function(error, stdout) {
          if (!error) {
            try {
              const output = stdout.toString();
              result2 = parseLinesDarwin(util$c.plistParser(output)[0]._items);
            } catch (e) {
              util$c.noop();
            }
            try {
              stdout = execSync$6('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo ""', { maxBuffer: 1024 * 2e4 });
              const output = (stdout || "").toString();
              const obj = util$c.plistReader(output);
              if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"]["Configs"] && obj["DisplayAnyUserSets"]["Configs"][0] && obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"]) {
                const current = obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"];
                let i = 0;
                current.forEach((o) => {
                  if (o["CurrentInfo"] && o["CurrentInfo"]["OriginX"] !== void 0 && result2.displays && result2.displays[i]) {
                    result2.displays[i].positionX = o["CurrentInfo"]["OriginX"];
                  }
                  if (o["CurrentInfo"] && o["CurrentInfo"]["OriginY"] !== void 0 && result2.displays && result2.displays[i]) {
                    result2.displays[i].positionY = o["CurrentInfo"]["OriginY"];
                  }
                  i++;
                });
              }
              if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"].length > 0 && obj["DisplayAnyUserSets"][0].length > 0 && obj["DisplayAnyUserSets"][0][0]["DisplayID"]) {
                const current = obj["DisplayAnyUserSets"][0];
                let i = 0;
                current.forEach((o) => {
                  if ("OriginX" in o && result2.displays && result2.displays[i]) {
                    result2.displays[i].positionX = o["OriginX"];
                  }
                  if ("OriginY" in o && result2.displays && result2.displays[i]) {
                    result2.displays[i].positionY = o["OriginY"];
                  }
                  if (o["Mode"] && o["Mode"]["BitsPerPixel"] !== void 0 && result2.displays && result2.displays[i]) {
                    result2.displays[i].pixelDepth = o["Mode"]["BitsPerPixel"];
                  }
                  i++;
                });
              }
            } catch (e) {
              util$c.noop();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_linux$a) {
        if (util$c.isRaspberry()) {
          let cmd2 = `fbset -s 2> /dev/null | grep 'mode "' ; vcgencmd get_mem gpu 2> /dev/null; tvservice -s 2> /dev/null; tvservice -n 2> /dev/null;`;
          exec$a(cmd2, function(error, stdout) {
            let lines = stdout.toString().split("\n");
            if (lines.length > 3 && lines[0].indexOf('mode "') >= -1 && lines[2].indexOf("0x12000a") > -1) {
              const parts = lines[0].replace("mode", "").replace(/"/g, "").trim().split("x");
              if (parts.length === 2) {
                result2.displays.push({
                  vendor: "",
                  model: util$c.getValue(lines, "device_name", "="),
                  main: true,
                  builtin: false,
                  connection: "HDMI",
                  sizeX: null,
                  sizeY: null,
                  pixelDepth: null,
                  resolutionX: parseInt(parts[0], 10),
                  resolutionY: parseInt(parts[1], 10),
                  currentResX: null,
                  currentResY: null,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: null
                });
              }
            }
            if (lines.length >= 1 && stdout.toString().indexOf("gpu=") >= -1) {
              result2.controllers.push({
                vendor: "Broadcom",
                model: util$c.getRpiGpu(),
                bus: "",
                vram: util$c.getValue(lines, "gpu", "=").replace("M", ""),
                vramDynamic: true
              });
            }
          });
        }
        let cmd = "lspci -vvv  2>/dev/null";
        exec$a(cmd, function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            if (result2.controllers.length === 0) {
              result2.controllers = parseLinesLinuxControllers(lines);
              const nvidiaData = nvidiaDevices();
              result2.controllers = result2.controllers.map((controller) => {
                return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});
              });
            }
          }
          let cmd2 = "clinfo --raw";
          exec$a(cmd2, function(error2, stdout2) {
            if (!error2) {
              let lines = stdout2.toString().split("\n");
              result2.controllers = parseLinesLinuxClinfo(result2.controllers, lines);
            }
            let cmd3 = "xdpyinfo 2>/dev/null | grep 'depth of root window' | awk '{ print $5 }'";
            exec$a(cmd3, function(error3, stdout3) {
              let depth = 0;
              if (!error3) {
                let lines = stdout3.toString().split("\n");
                depth = parseInt(lines[0]) || 0;
              }
              let cmd4 = "xrandr --verbose 2>/dev/null";
              exec$a(cmd4, function(error4, stdout4) {
                if (!error4) {
                  let lines = stdout4.toString().split("\n");
                  result2.displays = parseLinesLinuxDisplays(lines, depth);
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          });
        });
      }
      if (_freebsd$9 || _openbsd$9 || _netbsd$9) {
        if (callback) {
          callback(null);
        }
        resolve(null);
      }
      if (_sunos$9) {
        if (callback) {
          callback(null);
        }
        resolve(null);
      }
      if (_windows$b) {
        try {
          const workload = [];
          workload.push(util$c.powerShell("Get-CimInstance win32_VideoController | fl *"));
          workload.push(util$c.powerShell('gp "HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\*" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));
          workload.push(util$c.powerShell("Get-CimInstance win32_desktopmonitor | fl *"));
          workload.push(util$c.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams | fl"));
          workload.push(util$c.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens"));
          workload.push(util$c.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorConnectionParams | fl"));
          workload.push(util$c.powerShell('gwmi WmiMonitorID -Namespace root\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + $_.InstanceName}'));
          const nvidiaData = nvidiaDevices();
          Promise.all(
            workload
          ).then((data) => {
            let csections = data[0].replace(/\r/g, "").split(/\n\s*\n/);
            let vsections = data[1].replace(/\r/g, "").split(/\n\s*\n/);
            result2.controllers = parseLinesWindowsControllers(csections, vsections);
            result2.controllers = result2.controllers.map((controller) => {
              if (controller.vendor.toLowerCase() === "nvidia") {
                return mergeControllerNvidia(controller, nvidiaData.find((device) => {
                  let windowsSubDeviceId = (controller.subDeviceId || "").toLowerCase();
                  const nvidiaSubDeviceIdParts = device.subDeviceId.split("x");
                  let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();
                  const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);
                  if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {
                    for (let i = 0; i < lengthDifference; i++) {
                      nvidiaSubDeviceId = "0" + nvidiaSubDeviceId;
                    }
                  } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {
                    for (let i = 0; i < lengthDifference; i++) {
                      windowsSubDeviceId = "0" + windowsSubDeviceId;
                    }
                  }
                  return windowsSubDeviceId === nvidiaSubDeviceId;
                }) || {});
              } else {
                return controller;
              }
            });
            let dsections = data[2].replace(/\r/g, "").split(/\n\s*\n/);
            if (dsections[0].trim() === "") {
              dsections.shift();
            }
            if (dsections.length && dsections[dsections.length - 1].trim() === "") {
              dsections.pop();
            }
            let msections = data[3].replace(/\r/g, "").split("Active ");
            msections.shift();
            let ssections = data[4].replace(/\r/g, "").split("BitsPerPixel ");
            ssections.shift();
            let tsections = data[5].replace(/\r/g, "").split(/\n\s*\n/);
            tsections.shift();
            const res = data[6].replace(/\r/g, "").split(/\n/);
            let isections = [];
            res.forEach((element) => {
              const parts = element.split("|");
              if (parts.length === 5) {
                isections.push({
                  vendor: parts[0],
                  code: parts[1],
                  model: parts[2],
                  serial: parts[3],
                  instanceId: parts[4]
                });
              }
            });
            result2.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);
            if (result2.displays.length === 1) {
              if (_resolutionX) {
                result2.displays[0].resolutionX = _resolutionX;
                if (!result2.displays[0].currentResX) {
                  result2.displays[0].currentResX = _resolutionX;
                }
              }
              if (_resolutionY) {
                result2.displays[0].resolutionY = _resolutionY;
                if (result2.displays[0].currentResY === 0) {
                  result2.displays[0].currentResY = _resolutionY;
                }
              }
              if (_pixelDepth) {
                result2.displays[0].pixelDepth = _pixelDepth;
              }
            }
            result2.displays = result2.displays.map((element) => {
              if (_refreshRate && !element.currentRefreshRate) {
                element.currentRefreshRate = _refreshRate;
              }
              return element;
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }).catch(() => {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
  function parseLinesWindowsControllers(sections, vections) {
    const memorySizes = {};
    for (const i in vections) {
      if ({}.hasOwnProperty.call(vections, i)) {
        if (vections[i].trim() !== "") {
          const lines = vections[i].trim().split("\n");
          const matchingDeviceId = util$c.getValue(lines, "MatchingDeviceId").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
          if (matchingDeviceId) {
            const quadWordmemorySize = parseInt(util$c.getValue(lines, "HardwareInformation.qwMemorySize"));
            if (!isNaN(quadWordmemorySize)) {
              let deviceId = matchingDeviceId[1].toUpperCase() + "&" + matchingDeviceId[2].toUpperCase();
              if (matchingDeviceId[3]) {
                deviceId += "&" + matchingDeviceId[3].toUpperCase();
              }
              if (matchingDeviceId[4]) {
                deviceId += "&" + matchingDeviceId[4].toUpperCase();
              }
              memorySizes[deviceId] = quadWordmemorySize;
            }
          }
        }
      }
    }
    let controllers = [];
    for (let i in sections) {
      if ({}.hasOwnProperty.call(sections, i)) {
        if (sections[i].trim() !== "") {
          let lines = sections[i].trim().split("\n");
          let pnpDeviceId = util$c.getValue(lines, "PNPDeviceID", ":").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
          let subDeviceId = null;
          let memorySize = null;
          if (pnpDeviceId) {
            subDeviceId = pnpDeviceId[3] || "";
            if (subDeviceId) {
              subDeviceId = subDeviceId.split("_")[1];
            }
            if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {
              const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                memorySize = memorySizes[deviceId];
              }
            }
            if (memorySize == null && pnpDeviceId[3]) {
              const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase();
              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                memorySize = memorySizes[deviceId];
              }
            }
            if (memorySize == null && pnpDeviceId[4]) {
              const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                memorySize = memorySizes[deviceId];
              }
            }
            if (memorySize == null) {
              const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase();
              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                memorySize = memorySizes[deviceId];
              }
            }
          }
          controllers.push({
            vendor: util$c.getValue(lines, "AdapterCompatibility", ":"),
            model: util$c.getValue(lines, "name", ":"),
            bus: util$c.getValue(lines, "PNPDeviceID", ":").startsWith("PCI") ? "PCI" : "",
            vram: (memorySize == null ? util$c.toInt(util$c.getValue(lines, "AdapterRAM", ":")) : memorySize) / 1024 / 1024,
            vramDynamic: util$c.getValue(lines, "VideoMemoryType", ":") === "2",
            subDeviceId
          });
          _resolutionX = util$c.toInt(util$c.getValue(lines, "CurrentHorizontalResolution", ":")) || _resolutionX;
          _resolutionY = util$c.toInt(util$c.getValue(lines, "CurrentVerticalResolution", ":")) || _resolutionY;
          _refreshRate = util$c.toInt(util$c.getValue(lines, "CurrentRefreshRate", ":")) || _refreshRate;
          _pixelDepth = util$c.toInt(util$c.getValue(lines, "CurrentBitsPerPixel", ":")) || _pixelDepth;
        }
      }
    }
    return controllers;
  }
  function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {
    let displays = [];
    let vendor = "";
    let model = "";
    let deviceID = "";
    let resolutionX = 0;
    let resolutionY = 0;
    if (dsections && dsections.length) {
      let linesDisplay = dsections[0].split("\n");
      vendor = util$c.getValue(linesDisplay, "MonitorManufacturer", ":");
      model = util$c.getValue(linesDisplay, "Name", ":");
      deviceID = util$c.getValue(linesDisplay, "PNPDeviceID", ":").replace(/&amp;/g, "&").toLowerCase();
      resolutionX = util$c.toInt(util$c.getValue(linesDisplay, "ScreenWidth", ":"));
      resolutionY = util$c.toInt(util$c.getValue(linesDisplay, "ScreenHeight", ":"));
    }
    for (let i = 0; i < ssections.length; i++) {
      if (ssections[i].trim() !== "") {
        ssections[i] = "BitsPerPixel " + ssections[i];
        msections[i] = "Active " + msections[i];
        if (tsections.length === 0 || tsections[i] === void 0) {
          tsections[i] = "Unknown";
        }
        let linesScreen = ssections[i].split("\n");
        let linesMonitor = msections[i].split("\n");
        let linesConnection = tsections[i].split("\n");
        const bitsPerPixel = util$c.getValue(linesScreen, "BitsPerPixel");
        const bounds = util$c.getValue(linesScreen, "Bounds").replace("{", "").replace("}", "").replace(/=/g, ":").split(",");
        const primary = util$c.getValue(linesScreen, "Primary");
        const sizeX = util$c.getValue(linesMonitor, "MaxHorizontalImageSize");
        const sizeY = util$c.getValue(linesMonitor, "MaxVerticalImageSize");
        const instanceName = util$c.getValue(linesMonitor, "InstanceName").toLowerCase();
        const videoOutputTechnology = util$c.getValue(linesConnection, "VideoOutputTechnology");
        const deviceName = util$c.getValue(linesScreen, "DeviceName");
        let displayVendor = "";
        let displayModel = "";
        isections.forEach((element) => {
          if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith("(") && model.startsWith("PnP")) {
            displayVendor = element.vendor;
            displayModel = element.model;
          }
        });
        displays.push({
          vendor: instanceName.startsWith(deviceID) && displayVendor === "" ? vendor : displayVendor,
          model: instanceName.startsWith(deviceID) && displayModel === "" ? model : displayModel,
          deviceName,
          main: primary.toLowerCase() === "true",
          builtin: videoOutputTechnology === "2147483648",
          connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : "",
          resolutionX: util$c.toInt(util$c.getValue(bounds, "Width", ":")),
          resolutionY: util$c.toInt(util$c.getValue(bounds, "Height", ":")),
          sizeX: sizeX ? parseInt(sizeX, 10) : null,
          sizeY: sizeY ? parseInt(sizeY, 10) : null,
          pixelDepth: bitsPerPixel,
          currentResX: util$c.toInt(util$c.getValue(bounds, "Width", ":")),
          currentResY: util$c.toInt(util$c.getValue(bounds, "Height", ":")),
          positionX: util$c.toInt(util$c.getValue(bounds, "X", ":")),
          positionY: util$c.toInt(util$c.getValue(bounds, "Y", ":"))
        });
      }
    }
    if (ssections.length === 0) {
      displays.push({
        vendor,
        model,
        main: true,
        sizeX: null,
        sizeY: null,
        resolutionX,
        resolutionY,
        pixelDepth: null,
        currentResX: resolutionX,
        currentResY: resolutionY,
        positionX: 0,
        positionY: 0
      });
    }
    return displays;
  }
}
graphics$1.graphics = graphics;
var filesystem = {};
const util$b = util$j;
const fs$3 = require$$1$2;
const exec$9 = require$$1$1.exec;
const execSync$5 = require$$1$1.execSync;
const execPromiseSave = util$b.promisifySave(require$$1$1.exec);
let _platform$a = process.platform;
const _linux$9 = _platform$a === "linux" || _platform$a === "android";
const _darwin$9 = _platform$a === "darwin";
const _windows$a = _platform$a === "win32";
const _freebsd$8 = _platform$a === "freebsd";
const _openbsd$8 = _platform$a === "openbsd";
const _netbsd$8 = _platform$a === "netbsd";
const _sunos$8 = _platform$a === "sunos";
let _fs_speed = {};
let _disk_io = {};
function fsSize(drive2, callback) {
  if (util$b.isFunction(drive2)) {
    callback = drive2;
    drive2 = "";
  }
  let macOsDisks = [];
  let osMounts = [];
  function getmacOsFsType(fs2) {
    if (!fs2.startsWith("/")) {
      return "NFS";
    }
    const parts = fs2.split("/");
    const fsShort = parts[parts.length - 1];
    const macOsDisksSingle = macOsDisks.filter((item) => item.indexOf(fsShort) >= 0);
    if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf("APFS") >= 0) {
      return "APFS";
    }
    return "HFS";
  }
  function isLinuxTmpFs(fs2) {
    const linuxTmpFileSystems = ["rootfs", "unionfs", "squashfs", "cramfs", "initrd", "initramfs", "devtmpfs", "tmpfs", "udev", "devfs", "specfs", "type", "appimaged"];
    let result2 = false;
    linuxTmpFileSystems.forEach((linuxFs) => {
      if (fs2.toLowerCase().indexOf(linuxFs) >= 0) {
        result2 = true;
      }
    });
    return result2;
  }
  function filterLines(stdout) {
    let lines = stdout.toString().split("\n");
    lines.shift();
    if (stdout.toString().toLowerCase().indexOf("filesystem")) {
      let removeLines = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i] && lines[i].toLowerCase().startsWith("filesystem")) {
          removeLines = i;
        }
      }
      for (let i = 0; i < removeLines; i++) {
        lines.shift();
      }
    }
    return lines;
  }
  function parseDf(lines) {
    let data = [];
    lines.forEach(function(line) {
      if (line !== "") {
        line = line.replace(/ +/g, " ").split(" ");
        if (line && (line[0].startsWith("/") || line[6] && line[6] === "/" || line[0].indexOf("/") > 0 || line[0].indexOf(":") === 1 || !_darwin$9 && !isLinuxTmpFs(line[1]))) {
          const fs2 = line[0];
          const fsType = _linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8 ? line[1] : getmacOsFsType(line[0]);
          const size = parseInt(_linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8 ? line[2] : line[1]) * 1024;
          const used = parseInt(_linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8 ? line[3] : line[2]) * 1024;
          const available = parseInt(_linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8 ? line[4] : line[3]) * 1024;
          const use = parseFloat((100 * (used / (used + available))).toFixed(2));
          let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs2] || false : null;
          line.splice(0, _linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8 ? 6 : 5);
          const mount = line.join(" ");
          if (!data.find((el) => el.fs === fs2 && el.type === fsType)) {
            data.push({
              fs: fs2,
              type: fsType,
              size,
              used,
              available,
              use,
              mount,
              rw
            });
          }
        }
      }
    });
    return data;
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      let data = [];
      if (_linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8 || _darwin$9) {
        let cmd = "";
        macOsDisks = [];
        osMounts = {};
        if (_darwin$9) {
          cmd = "df -kP";
          try {
            macOsDisks = execSync$5("diskutil list").toString().split("\n").filter((line) => {
              return !line.startsWith("/") && line.indexOf(":") > 0;
            });
            execSync$5("mount").toString().split("\n").filter((line) => {
              return line.startsWith("/");
            }).forEach((line) => {
              osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
            });
          } catch (e) {
            util$b.noop();
          }
        }
        if (_linux$9) {
          try {
            cmd = "export LC_ALL=C; df -lkPTx squashfs; unset LC_ALL";
            execSync$5("cat /proc/mounts 2>/dev/null", util$b.execOptsLinux).toString().split("\n").filter((line) => {
              return line.startsWith("/");
            }).forEach((line) => {
              osMounts[line.split(" ")[0]] = osMounts[line.split(" ")[0]] || false;
              if (line.toLowerCase().indexOf("/snap/") === -1) {
                osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("rw,") >= 0 || line.toLowerCase().indexOf(" rw ") >= 0;
              }
            });
          } catch (e) {
            util$b.noop();
          }
        }
        if (_freebsd$8 || _openbsd$8 || _netbsd$8) {
          try {
            cmd = "df -lkPT";
            execSync$5("mount").toString().split("\n").forEach((line) => {
              osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
            });
          } catch (e) {
            util$b.noop();
          }
        }
        exec$9(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
          let lines = filterLines(stdout);
          data = parseDf(lines);
          if (drive2) {
            data = data.filter((item) => {
              return item.fs.toLowerCase().indexOf(drive2.toLowerCase()) >= 0 || item.mount.toLowerCase().indexOf(drive2.toLowerCase()) >= 0;
            });
          }
          if ((!error || data.length) && stdout.toString().trim() !== "") {
            if (callback) {
              callback(data);
            }
            resolve(data);
          } else {
            exec$9("df -kPT", { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
              if (!error2) {
                let lines2 = filterLines(stdout2);
                data = parseDf(lines2);
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          }
        });
      }
      if (_sunos$8) {
        if (callback) {
          callback(data);
        }
        resolve(data);
      }
      if (_windows$a) {
        try {
          const cmd = `Get-WmiObject Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size ${drive2 ? "| where -property Caption -eq " + drive2 : ""} | fl`;
          util$b.powerShell(cmd).then((stdout, error) => {
            if (!error) {
              let devices = stdout.toString().split(/\n\s*\n/);
              devices.forEach(function(device) {
                let lines = device.split("\r\n");
                const size = util$b.toInt(util$b.getValue(lines, "size", ":"));
                const free = util$b.toInt(util$b.getValue(lines, "freespace", ":"));
                const caption = util$b.getValue(lines, "caption", ":");
                const rwValue = util$b.getValue(lines, "access", ":");
                const rw = rwValue ? util$b.toInt(rwValue) !== 1 : null;
                if (size) {
                  data.push({
                    fs: caption,
                    type: util$b.getValue(lines, "filesystem", ":"),
                    size,
                    used: size - free,
                    available: free,
                    use: parseFloat((100 * (size - free) / size).toFixed(2)),
                    mount: caption,
                    rw
                  });
                }
              });
            }
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        } catch (e) {
          if (callback) {
            callback(data);
          }
          resolve(data);
        }
      }
    });
  });
}
filesystem.fsSize = fsSize;
function fsOpenFiles(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      const result2 = {
        max: null,
        allocated: null,
        available: null
      };
      if (_freebsd$8 || _openbsd$8 || _netbsd$8 || _darwin$9) {
        let cmd = "sysctl -i kern.maxfiles kern.num_files kern.open_files";
        exec$9(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            result2.max = parseInt(util$b.getValue(lines, "kern.maxfiles", ":"), 10);
            result2.allocated = parseInt(util$b.getValue(lines, "kern.num_files", ":"), 10) || parseInt(util$b.getValue(lines, "kern.open_files", ":"), 10);
            result2.available = result2.max - result2.allocated;
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_linux$9) {
        fs$3.readFile("/proc/sys/fs/file-nr", function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            if (lines[0]) {
              const parts = lines[0].replace(/\s+/g, " ").split(" ");
              if (parts.length === 3) {
                result2.allocated = parseInt(parts[0], 10);
                result2.available = parseInt(parts[1], 10);
                result2.max = parseInt(parts[2], 10);
                if (!result2.available) {
                  result2.available = result2.max - result2.allocated;
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          } else {
            fs$3.readFile("/proc/sys/fs/file-max", function(error2, stdout2) {
              if (!error2) {
                let lines = stdout2.toString().split("\n");
                if (lines[0]) {
                  result2.max = parseInt(lines[0], 10);
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
        });
      }
      if (_sunos$8) {
        if (callback) {
          callback(null);
        }
        resolve(null);
      }
      if (_windows$a) {
        if (callback) {
          callback(null);
        }
        resolve(null);
      }
    });
  });
}
filesystem.fsOpenFiles = fsOpenFiles;
function parseBytes(s) {
  return parseInt(s.substr(s.indexOf(" (") + 2, s.indexOf(" Bytes)") - 10));
}
function parseDevices(lines) {
  let devices = [];
  let i = 0;
  lines.forEach((line) => {
    if (line.length > 0) {
      if (line[0] === "*") {
        i++;
      } else {
        let parts = line.split(":");
        if (parts.length > 1) {
          if (!devices[i]) {
            devices[i] = {
              name: "",
              identifier: "",
              type: "disk",
              fsType: "",
              mount: "",
              size: 0,
              physical: "HDD",
              uuid: "",
              label: "",
              model: "",
              serial: "",
              removable: false,
              protocol: "",
              group: "",
              device: ""
            };
          }
          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, "");
          parts[1] = parts[1].trim();
          if ("DEVICEIDENTIFIER" === parts[0]) {
            devices[i].identifier = parts[1];
          }
          if ("DEVICENODE" === parts[0]) {
            devices[i].name = parts[1];
          }
          if ("VOLUMENAME" === parts[0]) {
            if (parts[1].indexOf("Not applicable") === -1) {
              devices[i].label = parts[1];
            }
          }
          if ("PROTOCOL" === parts[0]) {
            devices[i].protocol = parts[1];
          }
          if ("DISKSIZE" === parts[0]) {
            devices[i].size = parseBytes(parts[1]);
          }
          if ("FILESYSTEMPERSONALITY" === parts[0]) {
            devices[i].fsType = parts[1];
          }
          if ("MOUNTPOINT" === parts[0]) {
            devices[i].mount = parts[1];
          }
          if ("VOLUMEUUID" === parts[0]) {
            devices[i].uuid = parts[1];
          }
          if ("READ-ONLYMEDIA" === parts[0] && parts[1] === "Yes") {
            devices[i].physical = "CD/DVD";
          }
          if ("SOLIDSTATE" === parts[0] && parts[1] === "Yes") {
            devices[i].physical = "SSD";
          }
          if ("VIRTUAL" === parts[0]) {
            devices[i].type = "virtual";
          }
          if ("REMOVABLEMEDIA" === parts[0]) {
            devices[i].removable = parts[1] === "Removable";
          }
          if ("PARTITIONTYPE" === parts[0]) {
            devices[i].type = "part";
          }
          if ("DEVICE/MEDIANAME" === parts[0]) {
            devices[i].model = parts[1];
          }
        }
      }
    }
  });
  return devices;
}
function parseBlk(lines) {
  let data = [];
  lines.filter((line) => line !== "").forEach((line) => {
    try {
      line = decodeURIComponent(line.replace(/\\x/g, "%"));
      line = line.replace(/\\/g, "\\\\");
      let disk = JSON.parse(line);
      data.push({
        "name": disk.name,
        "type": disk.type,
        "fsType": disk.fsType,
        "mount": disk.mountpoint,
        "size": parseInt(disk.size),
        "physical": disk.type === "disk" ? disk.rota === "0" ? "SSD" : "HDD" : disk.type === "rom" ? "CD/DVD" : "",
        "uuid": disk.uuid,
        "label": disk.label,
        "model": (disk.model || "").trim(),
        "serial": disk.serial,
        "removable": disk.rm === "1",
        "protocol": disk.tran,
        "group": disk.group || ""
      });
    } catch (e) {
      util$b.noop();
    }
  });
  data = util$b.unique(data);
  data = util$b.sortByKey(data, ["type", "name"]);
  return data;
}
function decodeMdabmData(lines) {
  const raid = util$b.getValue(lines, "md_level", "=");
  const label = util$b.getValue(lines, "md_name", "=");
  const uuid2 = util$b.getValue(lines, "md_uuid", "=");
  const members = [];
  lines.forEach((line) => {
    if (line.toLowerCase().startsWith("md_device_dev") && line.toLowerCase().indexOf("/dev/") > 0) {
      members.push(line.split("/dev/")[1]);
    }
  });
  return {
    raid,
    label,
    uuid: uuid2,
    members
  };
}
function raidMatchLinux(data) {
  let result2 = data;
  try {
    data.forEach((element) => {
      if (element.type.startsWith("raid")) {
        const lines = execSync$5(`mdadm --export --detail /dev/${element.name}`, util$b.execOptsLinux).toString().split("\n");
        const mdData = decodeMdabmData(lines);
        element.label = mdData.label;
        element.uuid = mdData.uuid;
        if (mdData.members && mdData.members.length && mdData.raid === element.type) {
          result2 = result2.map((blockdevice) => {
            if (blockdevice.fsType === "linux_raid_member" && mdData.members.indexOf(blockdevice.name) >= 0) {
              blockdevice.group = element.name;
            }
            return blockdevice;
          });
        }
      }
    });
  } catch (e) {
    util$b.noop();
  }
  return result2;
}
function getDevicesLinux(data) {
  const result2 = [];
  data.forEach((element) => {
    if (element.type.startsWith("disk")) {
      result2.push(element.name);
    }
  });
  return result2;
}
function matchDevicesLinux(data) {
  let result2 = data;
  try {
    const devices = getDevicesLinux(data);
    result2 = result2.map((blockdevice) => {
      if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk")) {
        devices.forEach((element) => {
          if (blockdevice.name.startsWith(element)) {
            blockdevice.device = "/dev/" + element;
          }
        });
      }
      return blockdevice;
    });
  } catch (e) {
    util$b.noop();
  }
  return result2;
}
function getDevicesMac(data) {
  const result2 = [];
  data.forEach((element) => {
    if (element.type.startsWith("disk")) {
      result2.push({ name: element.name, model: element.model, device: element.name });
    }
    if (element.type.startsWith("virtual")) {
      let device = "";
      result2.forEach((e) => {
        if (e.model === element.model) {
          device = e.device;
        }
      });
      if (device) {
        result2.push({ name: element.name, model: element.model, device });
      }
    }
  });
  return result2;
}
function matchDevicesMac(data) {
  let result2 = data;
  try {
    const devices = getDevicesMac(data);
    result2 = result2.map((blockdevice) => {
      if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk") || blockdevice.type.startsWith("virtual")) {
        devices.forEach((element) => {
          if (blockdevice.name.startsWith(element.name)) {
            blockdevice.device = element.device;
          }
        });
      }
      return blockdevice;
    });
  } catch (e) {
    util$b.noop();
  }
  return result2;
}
function getDevicesWin(diskDrives) {
  const result2 = [];
  diskDrives.forEach((element) => {
    const lines = element.split("\r\n");
    const device = util$b.getValue(lines, "DeviceID", ":");
    let partitions = element.split("@{DeviceID=");
    if (partitions.length > 1) {
      partitions = partitions.slice(1);
      partitions.forEach((partition) => {
        result2.push({ name: partition.split(";")[0].toUpperCase(), device });
      });
    }
  });
  return result2;
}
function matchDevicesWin(data, diskDrives) {
  const devices = getDevicesWin(diskDrives);
  data.map((element) => {
    const filteresDevices = devices.filter((e) => {
      return e.name === element.name.toUpperCase();
    });
    if (filteresDevices.length > 0) {
      element.device = filteresDevices[0].device;
    }
    return element;
  });
  return data;
}
function blkStdoutToObject(stdout) {
  return stdout.toString().replace(/NAME=/g, '{"name":').replace(/FSTYPE=/g, ',"fsType":').replace(/TYPE=/g, ',"type":').replace(/SIZE=/g, ',"size":').replace(/MOUNTPOINT=/g, ',"mountpoint":').replace(/UUID=/g, ',"uuid":').replace(/ROTA=/g, ',"rota":').replace(/RO=/g, ',"ro":').replace(/RM=/g, ',"rm":').replace(/TRAN=/g, ',"tran":').replace(/SERIAL=/g, ',"serial":').replace(/LABEL=/g, ',"label":').replace(/MODEL=/g, ',"model":').replace(/OWNER=/g, ',"owner":').replace(/GROUP=/g, ',"group":').replace(/\n/g, "}\n");
}
function blockDevices(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let data = [];
      if (_linux$9) {
        exec$9("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
          if (!error) {
            let lines = blkStdoutToObject(stdout).split("\n");
            data = parseBlk(lines);
            data = raidMatchLinux(data);
            data = matchDevicesLinux(data);
            if (callback) {
              callback(data);
            }
            resolve(data);
          } else {
            exec$9("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
              if (!error2) {
                let lines = blkStdoutToObject(stdout2).split("\n");
                data = parseBlk(lines);
                data = raidMatchLinux(data);
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          }
        });
      }
      if (_darwin$9) {
        exec$9("diskutil info -all", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            data = parseDevices(lines);
            data = matchDevicesMac(data);
          }
          if (callback) {
            callback(data);
          }
          resolve(data);
        });
      }
      if (_sunos$8) {
        if (callback) {
          callback(data);
        }
        resolve(data);
      }
      if (_windows$a) {
        let drivetypes = ["Unknown", "NoRoot", "Removable", "Local", "Network", "CD/DVD", "RAM"];
        try {
          const workload = [];
          workload.push(util$b.powerShell("Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl"));
          workload.push(util$b.powerShell("Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L='Partitions'; E={$_.GetRelated('Win32_DiskPartition').GetRelated('Win32_LogicalDisk') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl"));
          util$b.promiseAll(
            workload
          ).then((res) => {
            let logicalDisks = res.results[0].toString().split(/\n\s*\n/);
            let diskDrives = res.results[1].toString().split(/\n\s*\n/);
            logicalDisks.forEach(function(device) {
              let lines = device.split("\r\n");
              let drivetype = util$b.getValue(lines, "drivetype", ":");
              if (drivetype) {
                data.push({
                  name: util$b.getValue(lines, "name", ":"),
                  identifier: util$b.getValue(lines, "caption", ":"),
                  type: "disk",
                  fsType: util$b.getValue(lines, "filesystem", ":").toLowerCase(),
                  mount: util$b.getValue(lines, "caption", ":"),
                  size: util$b.getValue(lines, "size", ":"),
                  physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],
                  uuid: util$b.getValue(lines, "volumeserialnumber", ":"),
                  label: util$b.getValue(lines, "volumename", ":"),
                  model: "",
                  serial: util$b.getValue(lines, "volumeserialnumber", ":"),
                  removable: drivetype === "2",
                  protocol: "",
                  group: "",
                  device: ""
                });
              }
            });
            data = matchDevicesWin(data, diskDrives);
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        } catch (e) {
          if (callback) {
            callback(data);
          }
          resolve(data);
        }
      }
      if (_freebsd$8 || _openbsd$8 || _netbsd$8) {
        if (callback) {
          callback(null);
        }
        resolve(null);
      }
    });
  });
}
filesystem.blockDevices = blockDevices;
function calcFsSpeed(rx, wx) {
  let result2 = {
    rx: 0,
    wx: 0,
    tx: 0,
    rx_sec: null,
    wx_sec: null,
    tx_sec: null,
    ms: 0
  };
  if (_fs_speed && _fs_speed.ms) {
    result2.rx = rx;
    result2.wx = wx;
    result2.tx = result2.rx + result2.wx;
    result2.ms = Date.now() - _fs_speed.ms;
    result2.rx_sec = (result2.rx - _fs_speed.bytes_read) / (result2.ms / 1e3);
    result2.wx_sec = (result2.wx - _fs_speed.bytes_write) / (result2.ms / 1e3);
    result2.tx_sec = result2.rx_sec + result2.wx_sec;
    _fs_speed.rx_sec = result2.rx_sec;
    _fs_speed.wx_sec = result2.wx_sec;
    _fs_speed.tx_sec = result2.tx_sec;
    _fs_speed.bytes_read = result2.rx;
    _fs_speed.bytes_write = result2.wx;
    _fs_speed.bytes_overall = result2.rx + result2.wx;
    _fs_speed.ms = Date.now();
    _fs_speed.last_ms = result2.ms;
  } else {
    result2.rx = rx;
    result2.wx = wx;
    result2.tx = result2.rx + result2.wx;
    _fs_speed.rx_sec = null;
    _fs_speed.wx_sec = null;
    _fs_speed.tx_sec = null;
    _fs_speed.bytes_read = result2.rx;
    _fs_speed.bytes_write = result2.wx;
    _fs_speed.bytes_overall = result2.rx + result2.wx;
    _fs_speed.ms = Date.now();
    _fs_speed.last_ms = 0;
  }
  return result2;
}
function fsStats(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (_windows$a || _freebsd$8 || _openbsd$8 || _netbsd$8 || _sunos$8) {
        return resolve(null);
      }
      let result2 = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: null,
        wx_sec: null,
        tx_sec: null,
        ms: 0
      };
      let rx = 0;
      let wx = 0;
      if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {
        if (_linux$9) {
          exec$9("lsblk -r 2>/dev/null | grep /", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              let fs_filter = [];
              lines.forEach(function(line) {
                if (line !== "") {
                  line = line.trim().split(" ");
                  if (fs_filter.indexOf(line[0]) === -1) {
                    fs_filter.push(line[0]);
                  }
                }
              });
              let output = fs_filter.join("|");
              exec$9('cat /proc/diskstats | egrep "' + output + '"', { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                if (!error2) {
                  let lines2 = stdout2.toString().split("\n");
                  lines2.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.replace(/ +/g, " ").split(" ");
                      rx += parseInt(line[5]) * 512;
                      wx += parseInt(line[9]) * 512;
                    }
                  });
                  result2 = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        }
        if (_darwin$9) {
          exec$9('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                line = line.trim();
                if (line !== "") {
                  line = line.split(",");
                  rx += parseInt(line[2]);
                  wx += parseInt(line[9]);
                }
              });
              result2 = calcFsSpeed(rx, wx);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
      } else {
        result2.ms = _fs_speed.last_ms;
        result2.rx = _fs_speed.bytes_read;
        result2.wx = _fs_speed.bytes_write;
        result2.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
        result2.rx_sec = _fs_speed.rx_sec;
        result2.wx_sec = _fs_speed.wx_sec;
        result2.tx_sec = _fs_speed.tx_sec;
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
filesystem.fsStats = fsStats;
function calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {
  let result2 = {
    rIO: 0,
    wIO: 0,
    tIO: 0,
    rIO_sec: null,
    wIO_sec: null,
    tIO_sec: null,
    rWaitTime: 0,
    wWaitTime: 0,
    tWaitTime: 0,
    rWaitPercent: null,
    wWaitPercent: null,
    tWaitPercent: null,
    ms: 0
  };
  if (_disk_io && _disk_io.ms) {
    result2.rIO = rIO;
    result2.wIO = wIO;
    result2.tIO = rIO + wIO;
    result2.ms = Date.now() - _disk_io.ms;
    result2.rIO_sec = (result2.rIO - _disk_io.rIO) / (result2.ms / 1e3);
    result2.wIO_sec = (result2.wIO - _disk_io.wIO) / (result2.ms / 1e3);
    result2.tIO_sec = result2.rIO_sec + result2.wIO_sec;
    result2.rWaitTime = rWaitTime;
    result2.wWaitTime = wWaitTime;
    result2.tWaitTime = tWaitTime;
    result2.rWaitPercent = (result2.rWaitTime - _disk_io.rWaitTime) * 100 / result2.ms;
    result2.wWaitPercent = (result2.wWaitTime - _disk_io.wWaitTime) * 100 / result2.ms;
    result2.tWaitPercent = (result2.tWaitTime - _disk_io.tWaitTime) * 100 / result2.ms;
    _disk_io.rIO = rIO;
    _disk_io.wIO = wIO;
    _disk_io.rIO_sec = result2.rIO_sec;
    _disk_io.wIO_sec = result2.wIO_sec;
    _disk_io.tIO_sec = result2.tIO_sec;
    _disk_io.rWaitTime = rWaitTime;
    _disk_io.wWaitTime = wWaitTime;
    _disk_io.tWaitTime = tWaitTime;
    _disk_io.rWaitPercent = result2.rWaitPercent;
    _disk_io.wWaitPercent = result2.wWaitPercent;
    _disk_io.tWaitPercent = result2.tWaitPercent;
    _disk_io.last_ms = result2.ms;
    _disk_io.ms = Date.now();
  } else {
    result2.rIO = rIO;
    result2.wIO = wIO;
    result2.tIO = rIO + wIO;
    result2.rWaitTime = rWaitTime;
    result2.wWaitTime = wWaitTime;
    result2.tWaitTime = tWaitTime;
    _disk_io.rIO = rIO;
    _disk_io.wIO = wIO;
    _disk_io.rIO_sec = null;
    _disk_io.wIO_sec = null;
    _disk_io.tIO_sec = null;
    _disk_io.rWaitTime = rWaitTime;
    _disk_io.wWaitTime = wWaitTime;
    _disk_io.tWaitTime = tWaitTime;
    _disk_io.rWaitPercent = null;
    _disk_io.wWaitPercent = null;
    _disk_io.tWaitPercent = null;
    _disk_io.last_ms = 0;
    _disk_io.ms = Date.now();
  }
  return result2;
}
function disksIO(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (_windows$a) {
        return resolve(null);
      }
      if (_sunos$8) {
        return resolve(null);
      }
      let result2 = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: null,
        wIO_sec: null,
        tIO_sec: null,
        rWaitTime: 0,
        wWaitTime: 0,
        tWaitTime: 0,
        rWaitPercent: null,
        wWaitPercent: null,
        tWaitPercent: null,
        ms: 0
      };
      let rIO = 0;
      let wIO = 0;
      let rWaitTime = 0;
      let wWaitTime = 0;
      let tWaitTime = 0;
      if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {
        if (_linux$9 || _freebsd$8 || _openbsd$8 || _netbsd$8) {
          let cmd = 'for mount in `lsblk 2>/dev/null | grep " disk " | sed "s/[ââââ]//g" | awk \'{$1=$1};1\' | cut -d " " -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r "s/ +/;/g" | sed -r "s/^;//"; done';
          exec$9(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.split("\n");
              lines.forEach(function(line) {
                if (!line) {
                  return;
                }
                let stats = line.split(";");
                rIO += parseInt(stats[0]);
                wIO += parseInt(stats[4]);
                rWaitTime += parseInt(stats[3]);
                wWaitTime += parseInt(stats[7]);
                tWaitTime += parseInt(stats[10]);
              });
              result2 = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        }
        if (_darwin$9) {
          exec$9('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                line = line.trim();
                if (line !== "") {
                  line = line.split(",");
                  rIO += parseInt(line[10]);
                  wIO += parseInt(line[0]);
                }
              });
              result2 = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
      } else {
        result2.rIO = _disk_io.rIO;
        result2.wIO = _disk_io.wIO;
        result2.tIO = _disk_io.rIO + _disk_io.wIO;
        result2.ms = _disk_io.last_ms;
        result2.rIO_sec = _disk_io.rIO_sec;
        result2.wIO_sec = _disk_io.wIO_sec;
        result2.tIO_sec = _disk_io.tIO_sec;
        result2.rWaitTime = _disk_io.rWaitTime;
        result2.wWaitTime = _disk_io.wWaitTime;
        result2.tWaitTime = _disk_io.tWaitTime;
        result2.rWaitPercent = _disk_io.rWaitPercent;
        result2.wWaitPercent = _disk_io.wWaitPercent;
        result2.tWaitPercent = _disk_io.tWaitPercent;
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
filesystem.disksIO = disksIO;
function diskLayout(callback) {
  function getVendorFromModel2(model) {
    const diskManufacturers = [
      { pattern: "WESTERN.*", manufacturer: "Western Digital" },
      { pattern: "^WDC.*", manufacturer: "Western Digital" },
      { pattern: "WD.*", manufacturer: "Western Digital" },
      { pattern: "TOSHIBA.*", manufacturer: "Toshiba" },
      { pattern: "HITACHI.*", manufacturer: "Hitachi" },
      { pattern: "^IC.*", manufacturer: "Hitachi" },
      { pattern: "^HTS.*", manufacturer: "Hitachi" },
      { pattern: "SANDISK.*", manufacturer: "SanDisk" },
      { pattern: "KINGSTON.*", manufacturer: "Kingston Technology" },
      { pattern: "^SONY.*", manufacturer: "Sony" },
      { pattern: "TRANSCEND.*", manufacturer: "Transcend" },
      { pattern: "SAMSUNG.*", manufacturer: "Samsung" },
      { pattern: "^ST(?!I\\ ).*", manufacturer: "Seagate" },
      { pattern: "^STI\\ .*", manufacturer: "SimpleTech" },
      { pattern: "^D...-.*", manufacturer: "IBM" },
      { pattern: "^IBM.*", manufacturer: "IBM" },
      { pattern: "^FUJITSU.*", manufacturer: "Fujitsu" },
      { pattern: "^MP.*", manufacturer: "Fujitsu" },
      { pattern: "^MK.*", manufacturer: "Toshiba" },
      { pattern: "MAXTO.*", manufacturer: "Maxtor" },
      { pattern: "PIONEER.*", manufacturer: "Pioneer" },
      { pattern: "PHILIPS.*", manufacturer: "Philips" },
      { pattern: "QUANTUM.*", manufacturer: "Quantum Technology" },
      { pattern: "FIREBALL.*", manufacturer: "Quantum Technology" },
      { pattern: "^VBOX.*", manufacturer: "VirtualBox" },
      { pattern: "CORSAIR.*", manufacturer: "Corsair Components" },
      { pattern: "CRUCIAL.*", manufacturer: "Crucial" },
      { pattern: "ECM.*", manufacturer: "ECM" },
      { pattern: "INTEL.*", manufacturer: "INTEL" },
      { pattern: "EVO.*", manufacturer: "Samsung" },
      { pattern: "APPLE.*", manufacturer: "Apple" }
    ];
    let result2 = "";
    if (model) {
      model = model.toUpperCase();
      diskManufacturers.forEach((manufacturer) => {
        const re = RegExp(manufacturer.pattern);
        if (re.test(model)) {
          result2 = manufacturer.manufacturer;
        }
      });
    }
    return result2;
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      const commitResult = (res) => {
        for (let i = 0; i < res.length; i++) {
          delete res[i].BSDName;
        }
        if (callback) {
          callback(res);
        }
        resolve(res);
      };
      let result2 = [];
      let cmd = "";
      if (_linux$9) {
        let cmdFullSmart = "";
        exec$9("export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
          if (!error) {
            try {
              const out = stdout.toString().trim();
              let devices = [];
              try {
                const outJSON = JSON.parse(out);
                if (outJSON && {}.hasOwnProperty.call(outJSON, "blockdevices")) {
                  devices = outJSON.blockdevices.filter((item) => {
                    return item.type === "disk" && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf("/ram") !== 0 && item.path.indexOf("/loop") !== 0 && item["disc-max"] && item["disc-max"] !== 0);
                  });
                }
              } catch (e) {
                try {
                  const out2 = execSync$5("export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL", util$b.execOptsLinux).toString();
                  let lines = blkStdoutToObject(out2).split("\n");
                  const data = parseBlk(lines);
                  devices = data.filter((item) => {
                    return item.type === "disk" && item.size > 0 && (item.model !== null && item.model !== "" || item.mount === "" && item.label === "" && item.fsType === "");
                  });
                } catch (e2) {
                  util$b.noop();
                }
              }
              devices.forEach((device) => {
                let mediumType = "";
                const BSDName = "/dev/" + device.name;
                const logical = device.name;
                try {
                  mediumType = execSync$5("cat /sys/block/" + logical + "/queue/rotational 2>/dev/null", util$b.execOptsLinux).toString().split("\n")[0];
                } catch (e) {
                  util$b.noop();
                }
                let interfaceType = device.tran ? device.tran.toUpperCase().trim() : "";
                if (interfaceType === "NVME") {
                  mediumType = "2";
                  interfaceType = "PCIe";
                }
                result2.push({
                  device: BSDName,
                  type: mediumType === "0" ? "SSD" : mediumType === "1" ? "HD" : mediumType === "2" ? "NVMe" : device.model && device.model.indexOf("SSD") > -1 ? "SSD" : device.model && device.model.indexOf("NVM") > -1 ? "NVMe" : "HD",
                  name: device.model || "",
                  vendor: getVendorFromModel2(device.model) || (device.vendor ? device.vendor.trim() : ""),
                  size: device.size || 0,
                  bytesPerSector: null,
                  totalCylinders: null,
                  totalHeads: null,
                  totalSectors: null,
                  totalTracks: null,
                  tracksPerCylinder: null,
                  sectorsPerTrack: null,
                  firmwareRevision: device.rev ? device.rev.trim() : "",
                  serialNum: device.serial ? device.serial.trim() : "",
                  interfaceType,
                  smartStatus: "unknown",
                  temperature: null,
                  BSDName
                });
                cmd += `printf "
${BSDName}|"; smartctl -H ${BSDName} | grep overall;`;
                cmdFullSmart += `${cmdFullSmart ? 'printf ",";' : ""}smartctl -a -j ${BSDName};`;
              });
            } catch (e) {
              util$b.noop();
            }
          }
          if (cmdFullSmart) {
            exec$9(cmdFullSmart, { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
              try {
                const data = JSON.parse(`[${stdout2}]`);
                data.forEach((disk) => {
                  const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];
                  for (let i = 0; i < result2.length; i++) {
                    if (result2[i].BSDName === diskBSDName) {
                      result2[i].smartStatus = disk.smart_status.passed ? "Ok" : disk.smart_status.passed === false ? "Predicted Failure" : "unknown";
                      if (disk.temperature && disk.temperature.current) {
                        result2[i].temperature = disk.temperature.current;
                      }
                      result2[i].smartData = disk;
                    }
                  }
                });
                commitResult(result2);
              } catch (e) {
                if (cmd) {
                  cmd = cmd + 'printf "\n"';
                  exec$9(cmd, { maxBuffer: 1024 * 1024 }, function(error3, stdout3) {
                    let lines = stdout3.toString().split("\n");
                    lines.forEach((line) => {
                      if (line) {
                        let parts = line.split("|");
                        if (parts.length === 2) {
                          let BSDName = parts[0];
                          parts[1] = parts[1].trim();
                          let parts2 = parts[1].split(":");
                          if (parts2.length === 2) {
                            parts2[1] = parts2[1].trim();
                            let status = parts2[1].toLowerCase();
                            for (let i = 0; i < result2.length; i++) {
                              if (result2[i].BSDName === BSDName) {
                                result2[i].smartStatus = status === "passed" ? "Ok" : status === "failed!" ? "Predicted Failure" : "unknown";
                              }
                            }
                          }
                        }
                      }
                    });
                    commitResult(result2);
                  });
                } else {
                  commitResult(result2);
                }
              }
            });
          } else {
            commitResult(result2);
          }
        });
      }
      if (_freebsd$8 || _openbsd$8 || _netbsd$8) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_sunos$8) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_darwin$9) {
        exec$9("system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            let linesSATA = [];
            let linesNVMe = [];
            let linesUSB = [];
            let dataType = "SATA";
            lines.forEach((line) => {
              if (line === "NVMExpress:") {
                dataType = "NVMe";
              } else if (line === "USB:") {
                dataType = "USB";
              } else if (line === "SATA/SATA Express:") {
                dataType = "SATA";
              } else if (dataType === "SATA") {
                linesSATA.push(line);
              } else if (dataType === "NVMe") {
                linesNVMe.push(line);
              } else if (dataType === "USB") {
                linesUSB.push(line);
              }
            });
            try {
              let devices = linesSATA.join("\n").split(" Physical Interconnect: ");
              devices.shift();
              devices.forEach(function(device) {
                device = "InterfaceType: " + device;
                let lines2 = device.split("\n");
                const mediumType = util$b.getValue(lines2, "Medium Type", ":", true).trim();
                const sizeStr = util$b.getValue(lines2, "capacity", ":", true).trim();
                const BSDName = util$b.getValue(lines2, "BSD Name", ":", true).trim();
                if (sizeStr) {
                  let sizeValue = 0;
                  if (sizeStr.indexOf("(") >= 0) {
                    sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                  }
                  if (!sizeValue) {
                    sizeValue = parseInt(sizeStr);
                  }
                  if (sizeValue) {
                    const smartStatusString = util$b.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                    result2.push({
                      device: BSDName,
                      type: mediumType.startsWith("Solid") ? "SSD" : "HD",
                      name: util$b.getValue(lines2, "Model", ":", true).trim(),
                      vendor: getVendorFromModel2(util$b.getValue(lines2, "Model", ":", true).trim()) || util$b.getValue(lines2, "Manufacturer", ":", true),
                      size: sizeValue,
                      bytesPerSector: null,
                      totalCylinders: null,
                      totalHeads: null,
                      totalSectors: null,
                      totalTracks: null,
                      tracksPerCylinder: null,
                      sectorsPerTrack: null,
                      firmwareRevision: util$b.getValue(lines2, "Revision", ":", true).trim(),
                      serialNum: util$b.getValue(lines2, "Serial Number", ":", true).trim(),
                      interfaceType: util$b.getValue(lines2, "InterfaceType", ":", true).trim(),
                      smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                      temperature: null,
                      BSDName
                    });
                    cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                  }
                }
              });
            } catch (e) {
              util$b.noop();
            }
            try {
              let devices = linesNVMe.join("\n").split("\n\n          Capacity:");
              devices.shift();
              devices.forEach(function(device) {
                device = "!Capacity: " + device;
                let lines2 = device.split("\n");
                const linkWidth = util$b.getValue(lines2, "link width", ":", true).trim();
                const sizeStr = util$b.getValue(lines2, "!capacity", ":", true).trim();
                const BSDName = util$b.getValue(lines2, "BSD Name", ":", true).trim();
                if (sizeStr) {
                  let sizeValue = 0;
                  if (sizeStr.indexOf("(") >= 0) {
                    sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                  }
                  if (!sizeValue) {
                    sizeValue = parseInt(sizeStr);
                  }
                  if (sizeValue) {
                    const smartStatusString = util$b.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                    result2.push({
                      device: BSDName,
                      type: "NVMe",
                      name: util$b.getValue(lines2, "Model", ":", true).trim(),
                      vendor: getVendorFromModel2(util$b.getValue(lines2, "Model", ":", true).trim()),
                      size: sizeValue,
                      bytesPerSector: null,
                      totalCylinders: null,
                      totalHeads: null,
                      totalSectors: null,
                      totalTracks: null,
                      tracksPerCylinder: null,
                      sectorsPerTrack: null,
                      firmwareRevision: util$b.getValue(lines2, "Revision", ":", true).trim(),
                      serialNum: util$b.getValue(lines2, "Serial Number", ":", true).trim(),
                      interfaceType: ("PCIe " + linkWidth).trim(),
                      smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                      temperature: null,
                      BSDName
                    });
                    cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                  }
                }
              });
            } catch (e) {
              util$b.noop();
            }
            try {
              let devices = linesUSB.join("\n").replaceAll("Media:\n ", "Model:").split("\n\n          Product ID:");
              devices.shift();
              devices.forEach(function(device) {
                let lines2 = device.split("\n");
                const sizeStr = util$b.getValue(lines2, "Capacity", ":", true).trim();
                const BSDName = util$b.getValue(lines2, "BSD Name", ":", true).trim();
                if (sizeStr) {
                  let sizeValue = 0;
                  if (sizeStr.indexOf("(") >= 0) {
                    sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                  }
                  if (!sizeValue) {
                    sizeValue = parseInt(sizeStr);
                  }
                  if (sizeValue) {
                    const smartStatusString = util$b.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                    result2.push({
                      device: BSDName,
                      type: "USB",
                      name: util$b.getValue(lines2, "Model", ":", true).trim().replaceAll(":", ""),
                      vendor: getVendorFromModel2(util$b.getValue(lines2, "Model", ":", true).trim()),
                      size: sizeValue,
                      bytesPerSector: null,
                      totalCylinders: null,
                      totalHeads: null,
                      totalSectors: null,
                      totalTracks: null,
                      tracksPerCylinder: null,
                      sectorsPerTrack: null,
                      firmwareRevision: util$b.getValue(lines2, "Revision", ":", true).trim(),
                      serialNum: util$b.getValue(lines2, "Serial Number", ":", true).trim(),
                      interfaceType: "USB",
                      smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                      temperature: null,
                      BSDName
                    });
                    cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                  }
                }
              });
            } catch (e) {
              util$b.noop();
            }
            if (cmd) {
              cmd = cmd + 'printf "\n"';
              exec$9(cmd, { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                let lines2 = stdout2.toString().split("\n");
                lines2.forEach((line) => {
                  if (line) {
                    let parts = line.split("|");
                    if (parts.length === 2) {
                      let BSDName = parts[0];
                      parts[1] = parts[1].trim();
                      let parts2 = parts[1].split(":");
                      if (parts2.length === 2) {
                        parts2[1] = parts2[1].trim();
                        let status = parts2[1].toLowerCase();
                        for (let i = 0; i < result2.length; i++) {
                          if (result2[i].BSDName === BSDName) {
                            result2[i].smartStatus = status === "not supported" ? "not supported" : status === "verified" ? "Ok" : status === "failing" ? "Predicted Failure" : "unknown";
                          }
                        }
                      }
                    }
                  }
                });
                for (let i = 0; i < result2.length; i++) {
                  delete result2[i].BSDName;
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              for (let i = 0; i < result2.length; i++) {
                delete result2[i].BSDName;
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          }
        });
      }
      if (_windows$a) {
        try {
          const workload = [];
          workload.push(util$b.powerShell("Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl"));
          workload.push(util$b.powerShell("Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl"));
          if (util$b.smartMonToolsInstalled()) {
            try {
              const smartDev = JSON.parse(execSync$5("smartctl --scan -j").toString());
              if (smartDev && smartDev.devices && smartDev.devices.length > 0) {
                smartDev.devices.forEach((dev) => {
                  workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util$b.execOptsWin));
                });
              }
            } catch (e) {
              util$b.noop();
            }
          }
          util$b.promiseAll(
            workload
          ).then((data) => {
            let devices = data.results[0].toString().split(/\n\s*\n/);
            devices.forEach(function(device) {
              let lines = device.split("\r\n");
              const size = util$b.getValue(lines, "Size", ":").trim();
              const status = util$b.getValue(lines, "Status", ":").trim().toLowerCase();
              if (size) {
                result2.push({
                  device: util$b.getValue(lines, "DeviceId", ":"),
                  // changed from PNPDeviceId to DeviceID (be be able to match devices)
                  type: device.indexOf("SSD") > -1 ? "SSD" : "HD",
                  // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below
                  name: util$b.getValue(lines, "Caption", ":"),
                  vendor: getVendorFromModel2(util$b.getValue(lines, "Caption", ":", true).trim()),
                  size: parseInt(size),
                  bytesPerSector: parseInt(util$b.getValue(lines, "BytesPerSector", ":")),
                  totalCylinders: parseInt(util$b.getValue(lines, "TotalCylinders", ":")),
                  totalHeads: parseInt(util$b.getValue(lines, "TotalHeads", ":")),
                  totalSectors: parseInt(util$b.getValue(lines, "TotalSectors", ":")),
                  totalTracks: parseInt(util$b.getValue(lines, "TotalTracks", ":")),
                  tracksPerCylinder: parseInt(util$b.getValue(lines, "TracksPerCylinder", ":")),
                  sectorsPerTrack: parseInt(util$b.getValue(lines, "SectorsPerTrack", ":")),
                  firmwareRevision: util$b.getValue(lines, "FirmwareRevision", ":").trim(),
                  serialNum: util$b.getValue(lines, "SerialNumber", ":").trim(),
                  interfaceType: util$b.getValue(lines, "InterfaceType", ":").trim(),
                  smartStatus: status === "ok" ? "Ok" : status === "degraded" ? "Degraded" : status === "pred fail" ? "Predicted Failure" : "Unknown",
                  temperature: null
                });
              }
            });
            devices = data.results[1].split(/\n\s*\n/);
            devices.forEach(function(device) {
              let lines = device.split("\r\n");
              const serialNum = util$b.getValue(lines, "SerialNumber", ":").trim();
              const name = util$b.getValue(lines, "FriendlyName", ":").trim().replace("Msft ", "Microsoft");
              const size = util$b.getValue(lines, "Size", ":").trim();
              const model = util$b.getValue(lines, "Model", ":").trim();
              const interfaceType = util$b.getValue(lines, "BusType", ":").trim();
              let mediaType = util$b.getValue(lines, "MediaType", ":").trim();
              if (mediaType === "3" || mediaType === "HDD") {
                mediaType = "HD";
              }
              if (mediaType === "4") {
                mediaType = "SSD";
              }
              if (mediaType === "5") {
                mediaType = "SCM";
              }
              if (mediaType === "Unspecified" && (model.toLowerCase().indexOf("virtual") > -1 || model.toLowerCase().indexOf("vbox") > -1)) {
                mediaType = "Virtual";
              }
              if (size) {
                let i = util$b.findObjectByKey(result2, "serialNum", serialNum);
                if (i === -1 || serialNum === "") {
                  i = util$b.findObjectByKey(result2, "name", name);
                }
                if (i != -1) {
                  result2[i].type = mediaType;
                  result2[i].interfaceType = interfaceType;
                }
              }
            });
            data.results.shift();
            data.results.shift();
            if (data.results.length) {
              data.results.forEach((smartStr) => {
                try {
                  const smartData = JSON.parse(smartStr);
                  if (smartData.serial_number) {
                    const serialNum = smartData.serial_number;
                    let i = util$b.findObjectByKey(result2, "serialNum", serialNum);
                    if (i != -1) {
                      result2[i].smartStatus = smartData.smart_status && smartData.smart_status.passed ? "Ok" : smartData.smart_status && smartData.smart_status.passed === false ? "Predicted Failure" : "unknown";
                      if (smartData.temperature && smartData.temperature.current) {
                        result2[i].temperature = smartData.temperature.current;
                      }
                      result2[i].smartData = smartData;
                    }
                  }
                } catch (e) {
                  util$b.noop();
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
filesystem.diskLayout = diskLayout;
var network = {};
const os$4 = os$a;
const exec$8 = require$$1$1.exec;
const execSync$4 = require$$1$1.execSync;
const fs$2 = require$$1$2;
const util$a = util$j;
let _platform$9 = process.platform;
const _linux$8 = _platform$9 === "linux" || _platform$9 === "android";
const _darwin$8 = _platform$9 === "darwin";
const _windows$9 = _platform$9 === "win32";
const _freebsd$7 = _platform$9 === "freebsd";
const _openbsd$7 = _platform$9 === "openbsd";
const _netbsd$7 = _platform$9 === "netbsd";
const _sunos$7 = _platform$9 === "sunos";
let _network = {};
let _default_iface = "";
let _ifaces = {};
let _dhcpNics = [];
let _networkInterfaces = [];
let _mac = {};
let pathToIp;
function getDefaultNetworkInterface() {
  let ifacename = "";
  let ifacenameFirst = "";
  try {
    let ifaces = os$4.networkInterfaces();
    let scopeid = 9999;
    for (let dev in ifaces) {
      if ({}.hasOwnProperty.call(ifaces, dev)) {
        ifaces[dev].forEach(function(details) {
          if (details && details.internal === false) {
            ifacenameFirst = ifacenameFirst || dev;
            if (details.scopeid && details.scopeid < scopeid) {
              ifacename = dev;
              scopeid = details.scopeid;
            }
          }
        });
      }
    }
    ifacename = ifacename || ifacenameFirst || "";
    if (_windows$9) {
      let defaultIp = "";
      const cmd = "netstat -r";
      const result2 = execSync$4(cmd, util$a.execOptsWin);
      const lines = result2.toString().split(os$4.EOL);
      lines.forEach((line) => {
        line = line.replace(/\s+/g, " ").trim();
        if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
          const parts = line.split(" ");
          if (parts.length >= 5) {
            defaultIp = parts[parts.length - 2];
          }
        }
      });
      if (defaultIp) {
        for (let dev in ifaces) {
          if ({}.hasOwnProperty.call(ifaces, dev)) {
            ifaces[dev].forEach(function(details) {
              if (details && details.address && details.address === defaultIp) {
                ifacename = dev;
              }
            });
          }
        }
      }
    }
    if (_linux$8) {
      let cmd = "ip route 2> /dev/null | grep default";
      let result2 = execSync$4(cmd, util$a.execOptsLinux);
      let parts = result2.toString().split("\n")[0].split(/\s+/);
      if (parts[0] === "none" && parts[5]) {
        ifacename = parts[5];
      } else if (parts[4]) {
        ifacename = parts[4];
      }
      if (ifacename.indexOf(":") > -1) {
        ifacename = ifacename.split(":")[1].trim();
      }
    }
    if (_darwin$8 || _freebsd$7 || _openbsd$7 || _netbsd$7 || _sunos$7) {
      let cmd = "";
      if (_linux$8) {
        cmd = "ip route 2> /dev/null | grep default | awk '{print $5}'";
      }
      if (_darwin$8) {
        cmd = "route -n get default 2>/dev/null | grep interface: | awk '{print $2}'";
      }
      if (_freebsd$7 || _openbsd$7 || _netbsd$7 || _sunos$7) {
        cmd = "route get 0.0.0.0 | grep interface:";
      }
      let result2 = execSync$4(cmd);
      ifacename = result2.toString().split("\n")[0];
      if (ifacename.indexOf(":") > -1) {
        ifacename = ifacename.split(":")[1].trim();
      }
    }
  } catch (e) {
    util$a.noop();
  }
  if (ifacename) {
    _default_iface = ifacename;
  }
  return _default_iface;
}
network.getDefaultNetworkInterface = getDefaultNetworkInterface;
function getMacAddresses() {
  let iface = "";
  let mac = "";
  let result2 = {};
  if (_linux$8 || _freebsd$7 || _openbsd$7 || _netbsd$7) {
    if (typeof pathToIp === "undefined") {
      try {
        const lines = execSync$4("which ip", util$a.execOptsLinux).toString().split("\n");
        if (lines.length && lines[0].indexOf(":") === -1 && lines[0].indexOf("/") === 0) {
          pathToIp = lines[0];
        } else {
          pathToIp = "";
        }
      } catch (e) {
        pathToIp = "";
      }
    }
    try {
      const cmd = "export LC_ALL=C; " + (pathToIp ? pathToIp + " link show up" : "/sbin/ifconfig") + "; unset LC_ALL";
      let res = execSync$4(cmd, util$a.execOptsLinux);
      const lines = res.toString().split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (lines[i] && lines[i][0] !== " ") {
          if (pathToIp) {
            let nextline = lines[i + 1].trim().split(" ");
            if (nextline[0] === "link/ether") {
              iface = lines[i].split(" ")[1];
              iface = iface.slice(0, iface.length - 1);
              mac = nextline[1];
            }
          } else {
            iface = lines[i].split(" ")[0];
            mac = lines[i].split("HWaddr ")[1];
          }
          if (iface && mac) {
            result2[iface] = mac.trim();
            iface = "";
            mac = "";
          }
        }
      }
    } catch (e) {
      util$a.noop();
    }
  }
  if (_darwin$8) {
    try {
      const cmd = "/sbin/ifconfig";
      let res = execSync$4(cmd);
      const lines = res.toString().split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (lines[i] && lines[i][0] !== "	" && lines[i].indexOf(":") > 0) {
          iface = lines[i].split(":")[0];
        } else if (lines[i].indexOf("	ether ") === 0) {
          mac = lines[i].split("	ether ")[1];
          if (iface && mac) {
            result2[iface] = mac.trim();
            iface = "";
            mac = "";
          }
        }
      }
    } catch (e) {
      util$a.noop();
    }
  }
  return result2;
}
function networkInterfaceDefault(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = getDefaultNetworkInterface();
      if (callback) {
        callback(result2);
      }
      resolve(result2);
    });
  });
}
network.networkInterfaceDefault = networkInterfaceDefault;
function parseLinesWindowsNics(sections, nconfigsections) {
  let nics = [];
  for (let i in sections) {
    try {
      if ({}.hasOwnProperty.call(sections, i)) {
        if (sections[i].trim() !== "") {
          let lines = sections[i].trim().split("\r\n");
          let linesNicConfig = null;
          try {
            linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split("\r\n") : [];
          } catch (e) {
            util$a.noop();
          }
          let netEnabled = util$a.getValue(lines, "NetEnabled", ":");
          let adapterType = util$a.getValue(lines, "AdapterTypeID", ":") === "9" ? "wireless" : "wired";
          let ifacename = util$a.getValue(lines, "Name", ":").replace(/\]/g, ")").replace(/\[/g, "(");
          let iface = util$a.getValue(lines, "NetConnectionID", ":").replace(/\]/g, ")").replace(/\[/g, "(");
          if (ifacename.toLowerCase().indexOf("wi-fi") >= 0 || ifacename.toLowerCase().indexOf("wireless") >= 0) {
            adapterType = "wireless";
          }
          if (netEnabled !== "") {
            const speed = parseInt(util$a.getValue(lines, "speed", ":").trim(), 10) / 1e6;
            nics.push({
              mac: util$a.getValue(lines, "MACAddress", ":").toLowerCase(),
              dhcp: util$a.getValue(linesNicConfig, "dhcpEnabled", ":").toLowerCase() === "true",
              name: ifacename,
              iface,
              netEnabled: netEnabled === "TRUE",
              speed: isNaN(speed) ? null : speed,
              operstate: util$a.getValue(lines, "NetConnectionStatus", ":") === "2" ? "up" : "down",
              type: adapterType
            });
          }
        }
      }
    } catch (e) {
      util$a.noop();
    }
  }
  return nics;
}
function getWindowsNics() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let cmd = "Get-CimInstance Win32_NetworkAdapter | fl *; echo '#-#-#-#';";
      cmd += "Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled";
      try {
        util$a.powerShell(cmd).then((data) => {
          data = data.split("#-#-#-#");
          const nsections = (data[0] || "").split(/\n\s*\n/);
          const nconfigsections = (data[1] || "").split(/\n\s*\n/);
          resolve(parseLinesWindowsNics(nsections, nconfigsections));
        });
      } catch (e) {
        resolve([]);
      }
    });
  });
}
function getWindowsDNSsuffixes() {
  let iface = {};
  let dnsSuffixes = {
    primaryDNS: "",
    exitCode: 0,
    ifaces: []
  };
  try {
    const ipconfig = execSync$4("ipconfig /all", util$a.execOptsWin);
    const ipconfigArray = ipconfig.split("\r\n\r\n");
    ipconfigArray.forEach((element, index) => {
      if (index == 1) {
        const longPrimaryDNS = element.split("\r\n").filter((element2) => {
          return element2.toUpperCase().includes("DNS");
        });
        const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(":") + 1);
        dnsSuffixes.primaryDNS = primaryDNS.trim();
        if (!dnsSuffixes.primaryDNS) {
          dnsSuffixes.primaryDNS = "Not defined";
        }
      }
      if (index > 1) {
        if (index % 2 == 0) {
          const name = element.substring(element.lastIndexOf(" ") + 1).replace(":", "");
          iface.name = name;
        } else {
          const connectionSpecificDNS = element.split("\r\n").filter((element2) => {
            return element2.toUpperCase().includes("DNS");
          });
          const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(":") + 1);
          iface.dnsSuffix = dnsSuffix.trim();
          dnsSuffixes.ifaces.push(iface);
          iface = {};
        }
      }
    });
    return dnsSuffixes;
  } catch (error) {
    return {
      primaryDNS: "",
      exitCode: 0,
      ifaces: []
    };
  }
}
function getWindowsIfaceDNSsuffix(ifaces, ifacename) {
  let dnsSuffix = "";
  const interfaceName = ifacename + ".";
  try {
    const connectionDnsSuffix = ifaces.filter((iface) => {
      return interfaceName.includes(iface.name + ".");
    }).map((iface) => iface.dnsSuffix);
    if (connectionDnsSuffix[0]) {
      dnsSuffix = connectionDnsSuffix[0];
    }
    if (!dnsSuffix) {
      dnsSuffix = "";
    }
    return dnsSuffix;
  } catch (error) {
    return "Unknown";
  }
}
function getWindowsWiredProfilesInformation() {
  try {
    const result2 = execSync$4("netsh lan show profiles", util$a.execOptsWin);
    const profileList = result2.split("\r\nProfile on interface");
    return profileList;
  } catch (error) {
    if (error.status === 1 && error.stdout.includes("AutoConfig")) {
      return "Disabled";
    }
    return [];
  }
}
function getWindowsWirelessIfaceSSID(interfaceName) {
  try {
    const result2 = execSync$4(`netsh wlan show  interface name="${interfaceName}" | findstr "SSID"`, util$a.execOptsWin);
    const SSID = result2.split("\r\n").shift();
    const parseSSID = SSID.split(":").pop().trim();
    return parseSSID;
  } catch (error) {
    return "Unknown";
  }
}
function getWindowsIEEE8021x(connectionType, iface, ifaces) {
  let i8021x = {
    state: "Unknown",
    protocol: "Unknown"
  };
  if (ifaces === "Disabled") {
    i8021x.state = "Disabled";
    i8021x.protocol = "Not defined";
    return i8021x;
  }
  if (connectionType == "wired" && ifaces.length > 0) {
    try {
      const iface8021xInfo = ifaces.find((element) => {
        return element.includes(iface + "\r\n");
      });
      const arrayIface8021xInfo = iface8021xInfo.split("\r\n");
      const state8021x = arrayIface8021xInfo.find((element) => {
        return element.includes("802.1x");
      });
      if (state8021x.includes("Disabled")) {
        i8021x.state = "Disabled";
        i8021x.protocol = "Not defined";
      } else if (state8021x.includes("Enabled")) {
        const protocol8021x = arrayIface8021xInfo.find((element) => {
          return element.includes("EAP");
        });
        i8021x.protocol = protocol8021x.split(":").pop();
        i8021x.state = "Enabled";
      }
    } catch (error) {
      return i8021x;
    }
  } else if (connectionType == "wireless") {
    let i8021xState = "";
    let i8021xProtocol = "";
    try {
      const SSID = getWindowsWirelessIfaceSSID(iface);
      if (SSID !== "Unknown") {
        let ifaceSanitized = "";
        const s = util$a.isPrototypePolluted() ? "---" : util$a.sanitizeShellString(SSID);
        const l = util$a.mathMin(s.length, 32);
        for (let i = 0; i <= l; i++) {
          if (s[i] !== void 0) {
            ifaceSanitized = ifaceSanitized + s[i];
          }
        }
        i8021xState = execSync$4(`netsh wlan show profiles "${ifaceSanitized}" | findstr "802.1X"`, util$a.execOptsWin);
        i8021xProtocol = execSync$4(`netsh wlan show profiles "${ifaceSanitized}" | findstr "EAP"`, util$a.execOptsWin);
      }
      if (i8021xState.includes(":") && i8021xProtocol.includes(":")) {
        i8021x.state = i8021xState.split(":").pop();
        i8021x.protocol = i8021xProtocol.split(":").pop();
      }
    } catch (error) {
      if (error.status === 1 && error.stdout.includes("AutoConfig")) {
        i8021x.state = "Disabled";
        i8021x.protocol = "Not defined";
      }
      return i8021x;
    }
  }
  return i8021x;
}
function splitSectionsNics(lines) {
  const result2 = [];
  let section = [];
  lines.forEach(function(line) {
    if (!line.startsWith("	") && !line.startsWith(" ")) {
      if (section.length) {
        result2.push(section);
        section = [];
      }
    }
    section.push(line);
  });
  if (section.length) {
    result2.push(section);
  }
  return result2;
}
function parseLinesDarwinNics(sections) {
  let nics = [];
  sections.forEach((section) => {
    let nic = {
      iface: "",
      mtu: null,
      mac: "",
      ip6: "",
      ip4: "",
      speed: null,
      type: "",
      operstate: "",
      duplex: "",
      internal: false
    };
    const first = section[0];
    nic.iface = first.split(":")[0].trim();
    let parts = first.split("> mtu");
    nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;
    if (isNaN(nic.mtu)) {
      nic.mtu = null;
    }
    nic.internal = parts[0].toLowerCase().indexOf("loopback") > -1;
    section.forEach((line) => {
      if (line.trim().startsWith("ether ")) {
        nic.mac = line.split("ether ")[1].toLowerCase().trim();
      }
      if (line.trim().startsWith("inet6 ") && !nic.ip6) {
        nic.ip6 = line.split("inet6 ")[1].toLowerCase().split("%")[0].split(" ")[0];
      }
      if (line.trim().startsWith("inet ") && !nic.ip4) {
        nic.ip4 = line.split("inet ")[1].toLowerCase().split(" ")[0];
      }
    });
    let speed = util$a.getValue(section, "link rate");
    nic.speed = speed ? parseFloat(speed) : null;
    if (nic.speed === null) {
      speed = util$a.getValue(section, "uplink rate");
      nic.speed = speed ? parseFloat(speed) : null;
      if (nic.speed !== null && speed.toLowerCase().indexOf("gbps") >= 0) {
        nic.speed = nic.speed * 1e3;
      }
    } else {
      if (speed.toLowerCase().indexOf("gbps") >= 0) {
        nic.speed = nic.speed * 1e3;
      }
    }
    nic.type = util$a.getValue(section, "type").toLowerCase().indexOf("wi-fi") > -1 ? "wireless" : "wired";
    const operstate = util$a.getValue(section, "status").toLowerCase();
    nic.operstate = operstate === "active" ? "up" : operstate === "inactive" ? "down" : "unknown";
    nic.duplex = util$a.getValue(section, "media").toLowerCase().indexOf("half-duplex") > -1 ? "half" : "full";
    if (nic.ip6 || nic.ip4 || nic.mac) {
      nics.push(nic);
    }
  });
  return nics;
}
function getDarwinNics() {
  const cmd = "/sbin/ifconfig -v";
  try {
    const lines = execSync$4(cmd, { maxBuffer: 1024 * 2e4 }).toString().split("\n");
    const nsections = splitSectionsNics(lines);
    return parseLinesDarwinNics(nsections);
  } catch (e) {
    return [];
  }
}
function getLinuxIfaceConnectionName(interfaceName) {
  const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;
  try {
    const result2 = execSync$4(cmd, util$a.execOptsLinux).toString();
    const resultFormat = result2.replace(/\s+/g, " ").trim();
    const connectionNameLines = resultFormat.split(" ").slice(3);
    const connectionName = connectionNameLines.join(" ");
    return connectionName != "--" ? connectionName : "";
  } catch (e) {
    return "";
  }
}
function checkLinuxDCHPInterfaces(file) {
  let result2 = [];
  try {
    let cmd = `cat ${file} 2> /dev/null | grep 'iface\\|source'`;
    const lines = execSync$4(cmd, util$a.execOptsLinux).toString().split("\n");
    lines.forEach((line) => {
      const parts = line.replace(/\s+/g, " ").trim().split(" ");
      if (parts.length >= 4) {
        if (line.toLowerCase().indexOf(" inet ") >= 0 && line.toLowerCase().indexOf("dhcp") >= 0) {
          result2.push(parts[1]);
        }
      }
      if (line.toLowerCase().includes("source")) {
        let file2 = line.split(" ")[1];
        result2 = result2.concat(checkLinuxDCHPInterfaces(file2));
      }
    });
  } catch (e) {
    util$a.noop();
  }
  return result2;
}
function getLinuxDHCPNics() {
  let cmd = "ip a 2> /dev/null";
  let result2 = [];
  try {
    const lines = execSync$4(cmd, util$a.execOptsLinux).toString().split("\n");
    const nsections = splitSectionsNics(lines);
    result2 = parseLinuxDHCPNics(nsections);
  } catch (e) {
    util$a.noop();
  }
  try {
    result2 = checkLinuxDCHPInterfaces("/etc/network/interfaces");
  } catch (e) {
    util$a.noop();
  }
  return result2;
}
function parseLinuxDHCPNics(sections) {
  const result2 = [];
  if (sections && sections.length) {
    sections.forEach((lines) => {
      if (lines && lines.length) {
        const parts = lines[0].split(":");
        if (parts.length > 2) {
          for (let line of lines) {
            if (line.indexOf(" inet ") >= 0 && line.indexOf(" dynamic ") >= 0) {
              const parts2 = line.split(" ");
              const nic = parts2[parts2.length - 1].trim();
              result2.push(nic);
              break;
            }
          }
        }
      }
    });
  }
  return result2;
}
function getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {
  let result2 = false;
  if (connectionName) {
    const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.method;`;
    try {
      const lines = execSync$4(cmd, util$a.execOptsLinux).toString();
      const resultFormat = lines.replace(/\s+/g, " ").trim();
      let dhcStatus = resultFormat.split(" ").slice(1).toString();
      switch (dhcStatus) {
        case "auto":
          result2 = true;
          break;
        default:
          result2 = false;
          break;
      }
      return result2;
    } catch (e) {
      return DHCPNics.indexOf(iface) >= 0;
    }
  } else {
    return DHCPNics.indexOf(iface) >= 0;
  }
}
function getDarwinIfaceDHCPstatus(iface) {
  let result2 = false;
  const cmd = `ipconfig getpacket "${iface}" 2>/dev/null | grep lease_time;`;
  try {
    const lines = execSync$4(cmd).toString().split("\n");
    if (lines.length && lines[0].startsWith("lease_time")) {
      result2 = true;
    }
  } catch (e) {
    util$a.noop();
  }
  return result2;
}
function getLinuxIfaceDNSsuffix(connectionName) {
  if (connectionName) {
    const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.dns-search;`;
    try {
      const result2 = execSync$4(cmd, util$a.execOptsLinux).toString();
      const resultFormat = result2.replace(/\s+/g, " ").trim();
      const dnsSuffix = resultFormat.split(" ").slice(1).toString();
      return dnsSuffix == "--" ? "Not defined" : dnsSuffix;
    } catch (e) {
      return "Unknown";
    }
  } else {
    return "Unknown";
  }
}
function getLinuxIfaceIEEE8021xAuth(connectionName) {
  if (connectionName) {
    const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep 802-1x.eap;`;
    try {
      const result2 = execSync$4(cmd, util$a.execOptsLinux).toString();
      const resultFormat = result2.replace(/\s+/g, " ").trim();
      const authenticationProtocol = resultFormat.split(" ").slice(1).toString();
      return authenticationProtocol == "--" ? "" : authenticationProtocol;
    } catch (e) {
      return "Not defined";
    }
  } else {
    return "Not defined";
  }
}
function getLinuxIfaceIEEE8021xState(authenticationProtocol) {
  if (authenticationProtocol) {
    if (authenticationProtocol == "Not defined") {
      return "Disabled";
    }
    return "Enabled";
  } else {
    return "Unknown";
  }
}
function testVirtualNic(iface, ifaceName, mac) {
  const virtualMacs = ["00:00:00:00:00:00", "00:03:FF", "00:05:69", "00:0C:29", "00:0F:4B", "00:13:07", "00:13:BE", "00:15:5d", "00:16:3E", "00:1C:42", "00:21:F6", "00:24:0B", "00:50:56", "00:A0:B1", "00:E0:C8", "08:00:27", "0A:00:27", "18:92:2C", "16:DF:49", "3C:F3:92", "54:52:00", "FC:15:97"];
  if (mac) {
    return virtualMacs.filter((item) => {
      return mac.toUpperCase().toUpperCase().startsWith(item.substring(0, mac.length));
    }).length > 0 || iface.toLowerCase().indexOf(" virtual ") > -1 || ifaceName.toLowerCase().indexOf(" virtual ") > -1 || iface.toLowerCase().indexOf("vethernet ") > -1 || ifaceName.toLowerCase().indexOf("vethernet ") > -1 || iface.toLowerCase().startsWith("veth") || ifaceName.toLowerCase().startsWith("veth") || iface.toLowerCase().startsWith("vboxnet") || ifaceName.toLowerCase().startsWith("vboxnet");
  } else {
    return false;
  }
}
function networkInterfaces(callback, rescan, defaultString) {
  if (typeof callback === "string") {
    defaultString = callback;
    rescan = true;
    callback = null;
  }
  if (typeof callback === "boolean") {
    rescan = callback;
    callback = null;
    defaultString = "";
  }
  if (typeof rescan === "undefined") {
    rescan = true;
  }
  defaultString = defaultString || "";
  defaultString = "" + defaultString;
  return new Promise((resolve) => {
    process.nextTick(() => {
      let ifaces = os$4.networkInterfaces();
      let result2 = [];
      let nics = [];
      let dnsSuffixes = [];
      let nics8021xInfo = [];
      if (_darwin$8 || _freebsd$7 || _openbsd$7 || _netbsd$7) {
        if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
          result2 = _networkInterfaces;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        } else {
          const defaultInterface = getDefaultNetworkInterface();
          _ifaces = JSON.parse(JSON.stringify(ifaces));
          nics = getDarwinNics();
          nics.forEach((nic) => {
            if ({}.hasOwnProperty.call(ifaces, nic.iface)) {
              ifaces[nic.iface].forEach(function(details) {
                if (details.family === "IPv4" || details.family === 4) {
                  nic.ip4subnet = details.netmask;
                }
                if (details.family === "IPv6" || details.family === 6) {
                  nic.ip6subnet = details.netmask;
                }
              });
            }
            let ifaceSanitized = "";
            const s = util$a.isPrototypePolluted() ? "---" : util$a.sanitizeShellString(nic.iface);
            const l = util$a.mathMin(s.length, 2e3);
            for (let i = 0; i <= l; i++) {
              if (s[i] !== void 0) {
                ifaceSanitized = ifaceSanitized + s[i];
              }
            }
            result2.push({
              iface: nic.iface,
              ifaceName: nic.iface,
              default: nic.iface === defaultInterface,
              ip4: nic.ip4,
              ip4subnet: nic.ip4subnet || "",
              ip6: nic.ip6,
              ip6subnet: nic.ip6subnet || "",
              mac: nic.mac,
              internal: nic.internal,
              virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),
              operstate: nic.operstate,
              type: nic.type,
              duplex: nic.duplex,
              mtu: nic.mtu,
              speed: nic.speed,
              dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),
              dnsSuffix: "",
              ieee8021xAuth: "",
              ieee8021xState: "",
              carrierChanges: 0
            });
          });
          _networkInterfaces = result2;
          if (defaultString.toLowerCase().indexOf("default") >= 0) {
            result2 = result2.filter((item) => item.default);
            if (result2.length > 0) {
              result2 = result2[0];
            } else {
              result2 = [];
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_linux$8) {
        if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
          result2 = _networkInterfaces;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        } else {
          _ifaces = JSON.parse(JSON.stringify(ifaces));
          _dhcpNics = getLinuxDHCPNics();
          const defaultInterface = getDefaultNetworkInterface();
          for (let dev in ifaces) {
            let ip4 = "";
            let ip4subnet = "";
            let ip6 = "";
            let ip6subnet = "";
            let mac = "";
            let duplex = "";
            let mtu = "";
            let speed = null;
            let carrierChanges = 0;
            let dhcp = false;
            let dnsSuffix = "";
            let ieee8021xAuth = "";
            let ieee8021xState = "";
            let type = "";
            if ({}.hasOwnProperty.call(ifaces, dev)) {
              let ifaceName = dev;
              ifaces[dev].forEach(function(details) {
                if (details.family === "IPv4" || details.family === 4) {
                  ip4 = details.address;
                  ip4subnet = details.netmask;
                }
                if (details.family === "IPv6" || details.family === 6) {
                  if (!ip6 || ip6.match(/^fe80::/i)) {
                    ip6 = details.address;
                    ip6subnet = details.netmask;
                  }
                }
                mac = details.mac;
                const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                if (mac.indexOf("00:00:0") > -1 && (_linux$8 || _darwin$8) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                  if (Object.keys(_mac).length === 0) {
                    _mac = getMacAddresses();
                  }
                  mac = _mac[dev] || "";
                }
              });
              let iface = dev.split(":")[0].trim().toLowerCase();
              let ifaceSanitized = "";
              const s = util$a.isPrototypePolluted() ? "---" : util$a.sanitizeShellString(iface);
              const l = util$a.mathMin(s.length, 2e3);
              for (let i = 0; i <= l; i++) {
                if (s[i] !== void 0) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              const cmd = `echo -n "addr_assign_type: "; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;
            echo -n "address: "; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;
            echo -n "addr_len: "; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;
            echo -n "broadcast: "; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;
            echo -n "carrier: "; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;
            echo -n "carrier_changes: "; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;
            echo -n "dev_id: "; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;
            echo -n "dev_port: "; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;
            echo -n "dormant: "; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;
            echo -n "duplex: "; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;
            echo -n "flags: "; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;
            echo -n "gro_flush_timeout: "; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;
            echo -n "ifalias: "; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;
            echo -n "ifindex: "; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;
            echo -n "iflink: "; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;
            echo -n "link_mode: "; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;
            echo -n "mtu: "; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;
            echo -n "netdev_group: "; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;
            echo -n "operstate: "; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;
            echo -n "proto_down: "; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;
            echo -n "speed: "; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;
            echo -n "tx_queue_len: "; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;
            echo -n "type: "; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;
            echo -n "wireless: "; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;
            echo -n "wirelessspeed: "; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;
              let lines = [];
              try {
                lines = execSync$4(cmd, util$a.execOptsLinux).toString().split("\n");
                const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);
                dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);
                dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);
                ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);
                ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);
              } catch (e) {
                util$a.noop();
              }
              duplex = util$a.getValue(lines, "duplex");
              duplex = duplex.startsWith("cat") ? "" : duplex;
              mtu = parseInt(util$a.getValue(lines, "mtu"), 10);
              let myspeed = parseInt(util$a.getValue(lines, "speed"), 10);
              speed = isNaN(myspeed) ? null : myspeed;
              let wirelessspeed = util$a.getValue(lines, "wirelessspeed").split("tx bitrate: ");
              if (speed === null && wirelessspeed.length === 2) {
                myspeed = parseFloat(wirelessspeed[1]);
                speed = isNaN(myspeed) ? null : myspeed;
              }
              carrierChanges = parseInt(util$a.getValue(lines, "carrier_changes"), 10);
              const operstate = util$a.getValue(lines, "operstate");
              type = operstate === "up" ? util$a.getValue(lines, "wireless").trim() ? "wireless" : "wired" : "unknown";
              if (ifaceSanitized === "lo" || ifaceSanitized.startsWith("bond")) {
                type = "virtual";
              }
              let internal2 = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
              if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                internal2 = true;
              }
              const virtual = internal2 ? false : testVirtualNic(dev, ifaceName, mac);
              result2.push({
                iface: ifaceSanitized,
                ifaceName,
                default: iface === defaultInterface,
                ip4,
                ip4subnet,
                ip6,
                ip6subnet,
                mac,
                internal: internal2,
                virtual,
                operstate,
                type,
                duplex,
                mtu,
                speed,
                dhcp,
                dnsSuffix,
                ieee8021xAuth,
                ieee8021xState,
                carrierChanges
              });
            }
          }
          _networkInterfaces = result2;
          if (defaultString.toLowerCase().indexOf("default") >= 0) {
            result2 = result2.filter((item) => item.default);
            if (result2.length > 0) {
              result2 = result2[0];
            } else {
              result2 = [];
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_windows$9) {
        if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
          result2 = _networkInterfaces;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        } else {
          _ifaces = JSON.parse(JSON.stringify(ifaces));
          const defaultInterface = getDefaultNetworkInterface();
          getWindowsNics().then(function(nics2) {
            nics2.forEach((nic) => {
              let found = false;
              Object.keys(ifaces).forEach((key2) => {
                if (!found) {
                  ifaces[key2].forEach((value) => {
                    if (Object.keys(value).indexOf("mac") >= 0) {
                      found = value["mac"] === nic.mac;
                    }
                  });
                }
              });
              if (!found) {
                ifaces[nic.name] = [{ mac: nic.mac }];
              }
            });
            nics8021xInfo = getWindowsWiredProfilesInformation();
            dnsSuffixes = getWindowsDNSsuffixes();
            for (let dev in ifaces) {
              let ifaceSanitized = "";
              const s = util$a.isPrototypePolluted() ? "---" : util$a.sanitizeShellString(dev);
              const l = util$a.mathMin(s.length, 2e3);
              for (let i = 0; i <= l; i++) {
                if (s[i] !== void 0) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              let iface = dev;
              let ip4 = "";
              let ip4subnet = "";
              let ip6 = "";
              let ip6subnet = "";
              let mac = "";
              let duplex = "";
              let mtu = "";
              let speed = null;
              let carrierChanges = 0;
              let operstate = "down";
              let dhcp = false;
              let dnsSuffix = "";
              let ieee8021xAuth = "";
              let ieee8021xState = "";
              let type = "";
              if ({}.hasOwnProperty.call(ifaces, dev)) {
                let ifaceName = dev;
                ifaces[dev].forEach(function(details) {
                  if (details.family === "IPv4" || details.family === 4) {
                    ip4 = details.address;
                    ip4subnet = details.netmask;
                  }
                  if (details.family === "IPv6" || details.family === 6) {
                    if (!ip6 || ip6.match(/^fe80::/i)) {
                      ip6 = details.address;
                      ip6subnet = details.netmask;
                    }
                  }
                  mac = details.mac;
                  const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                  if (mac.indexOf("00:00:0") > -1 && (_linux$8 || _darwin$8) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                    if (Object.keys(_mac).length === 0) {
                      _mac = getMacAddresses();
                    }
                    mac = _mac[dev] || "";
                  }
                });
                dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);
                let foundFirst = false;
                nics2.forEach((detail) => {
                  if (detail.mac === mac && !foundFirst) {
                    iface = detail.iface || iface;
                    ifaceName = detail.name;
                    dhcp = detail.dhcp;
                    operstate = detail.operstate;
                    speed = operstate === "up" ? detail.speed : 0;
                    type = detail.type;
                    foundFirst = true;
                  }
                });
                if (dev.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("802.11n") >= 0 || ifaceName.toLowerCase().indexOf("wireless") >= 0 || ifaceName.toLowerCase().indexOf("wi-fi") >= 0 || ifaceName.toLowerCase().indexOf("wifi") >= 0) {
                  type = "wireless";
                }
                const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);
                ieee8021xAuth = IEEE8021x.protocol;
                ieee8021xState = IEEE8021x.state;
                let internal2 = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                  internal2 = true;
                }
                const virtual = internal2 ? false : testVirtualNic(dev, ifaceName, mac);
                result2.push({
                  iface,
                  ifaceName,
                  default: iface === defaultInterface,
                  ip4,
                  ip4subnet,
                  ip6,
                  ip6subnet,
                  mac,
                  internal: internal2,
                  virtual,
                  operstate,
                  type,
                  duplex,
                  mtu,
                  speed,
                  dhcp,
                  dnsSuffix,
                  ieee8021xAuth,
                  ieee8021xState,
                  carrierChanges
                });
              }
            }
            _networkInterfaces = result2;
            if (defaultString.toLowerCase().indexOf("default") >= 0) {
              result2 = result2.filter((item) => item.default);
              if (result2.length > 0) {
                result2 = result2[0];
              } else {
                result2 = [];
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
      }
    });
  });
}
network.networkInterfaces = networkInterfaces;
function calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {
  let result2 = {
    iface,
    operstate,
    rx_bytes,
    rx_dropped,
    rx_errors,
    tx_bytes,
    tx_dropped,
    tx_errors,
    rx_sec: null,
    tx_sec: null,
    ms: 0
  };
  if (_network[iface] && _network[iface].ms) {
    result2.ms = Date.now() - _network[iface].ms;
    result2.rx_sec = rx_bytes - _network[iface].rx_bytes >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result2.ms / 1e3) : 0;
    result2.tx_sec = tx_bytes - _network[iface].tx_bytes >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result2.ms / 1e3) : 0;
    _network[iface].rx_bytes = rx_bytes;
    _network[iface].tx_bytes = tx_bytes;
    _network[iface].rx_sec = result2.rx_sec;
    _network[iface].tx_sec = result2.tx_sec;
    _network[iface].ms = Date.now();
    _network[iface].last_ms = result2.ms;
    _network[iface].operstate = operstate;
  } else {
    if (!_network[iface]) {
      _network[iface] = {};
    }
    _network[iface].rx_bytes = rx_bytes;
    _network[iface].tx_bytes = tx_bytes;
    _network[iface].rx_sec = null;
    _network[iface].tx_sec = null;
    _network[iface].ms = Date.now();
    _network[iface].last_ms = 0;
    _network[iface].operstate = operstate;
  }
  return result2;
}
function networkStats(ifaces, callback) {
  let ifacesArray = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (util$a.isFunction(ifaces) && !callback) {
        callback = ifaces;
        ifacesArray = [getDefaultNetworkInterface()];
      } else {
        if (typeof ifaces !== "string" && ifaces !== void 0) {
          if (callback) {
            callback([]);
          }
          return resolve([]);
        }
        ifaces = ifaces || getDefaultNetworkInterface();
        try {
          ifaces.__proto__.toLowerCase = util$a.stringToLower;
          ifaces.__proto__.replace = util$a.stringReplace;
          ifaces.__proto__.toString = util$a.stringToString;
          ifaces.__proto__.substr = util$a.stringSubstr;
          ifaces.__proto__.substring = util$a.stringSubstring;
          ifaces.__proto__.trim = util$a.stringTrim;
          ifaces.__proto__.startsWith = util$a.stringStartWith;
        } catch (e) {
          Object.setPrototypeOf(ifaces, util$a.stringObj);
        }
        ifaces = ifaces.trim().toLowerCase().replace(/,+/g, "|");
        ifacesArray = ifaces.split("|");
      }
      const result2 = [];
      const workload = [];
      if (ifacesArray.length && ifacesArray[0].trim() === "*") {
        ifacesArray = [];
        networkInterfaces(false).then((allIFaces) => {
          for (let iface of allIFaces) {
            ifacesArray.push(iface.iface);
          }
          networkStats(ifacesArray.join(",")).then((result3) => {
            if (callback) {
              callback(result3);
            }
            resolve(result3);
          });
        });
      } else {
        for (let iface of ifacesArray) {
          workload.push(networkStatsSingle(iface.trim()));
        }
        if (workload.length) {
          Promise.all(
            workload
          ).then((data) => {
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
function networkStatsSingle(iface) {
  function parseLinesWindowsPerfData(sections) {
    let perfData = [];
    for (let i in sections) {
      if ({}.hasOwnProperty.call(sections, i)) {
        if (sections[i].trim() !== "") {
          let lines = sections[i].trim().split("\r\n");
          perfData.push({
            name: util$a.getValue(lines, "Name", ":").replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase(),
            rx_bytes: parseInt(util$a.getValue(lines, "BytesReceivedPersec", ":"), 10),
            rx_errors: parseInt(util$a.getValue(lines, "PacketsReceivedErrors", ":"), 10),
            rx_dropped: parseInt(util$a.getValue(lines, "PacketsReceivedDiscarded", ":"), 10),
            tx_bytes: parseInt(util$a.getValue(lines, "BytesSentPersec", ":"), 10),
            tx_errors: parseInt(util$a.getValue(lines, "PacketsOutboundErrors", ":"), 10),
            tx_dropped: parseInt(util$a.getValue(lines, "PacketsOutboundDiscarded", ":"), 10)
          });
        }
      }
    }
    return perfData;
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      let ifaceSanitized = "";
      const s = util$a.isPrototypePolluted() ? "---" : util$a.sanitizeShellString(iface);
      const l = util$a.mathMin(s.length, 2e3);
      for (let i = 0; i <= l; i++) {
        if (s[i] !== void 0) {
          ifaceSanitized = ifaceSanitized + s[i];
        }
      }
      let result2 = {
        iface: ifaceSanitized,
        operstate: "unknown",
        rx_bytes: 0,
        rx_dropped: 0,
        rx_errors: 0,
        tx_bytes: 0,
        tx_dropped: 0,
        tx_errors: 0,
        rx_sec: null,
        tx_sec: null,
        ms: 0
      };
      let operstate = "unknown";
      let rx_bytes = 0;
      let tx_bytes = 0;
      let rx_dropped = 0;
      let rx_errors = 0;
      let tx_dropped = 0;
      let tx_errors = 0;
      let cmd, lines, stats;
      if (!_network[ifaceSanitized] || _network[ifaceSanitized] && !_network[ifaceSanitized].ms || _network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500) {
        if (_linux$8) {
          if (fs$2.existsSync("/sys/class/net/" + ifaceSanitized)) {
            cmd = "cat /sys/class/net/" + ifaceSanitized + "/operstate; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_errors; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_errors; ";
            exec$8(cmd, function(error, stdout) {
              if (!error) {
                lines = stdout.toString().split("\n");
                operstate = lines[0].trim();
                rx_bytes = parseInt(lines[1], 10);
                tx_bytes = parseInt(lines[2], 10);
                rx_dropped = parseInt(lines[3], 10);
                rx_errors = parseInt(lines[4], 10);
                tx_dropped = parseInt(lines[5], 10);
                tx_errors = parseInt(lines[6], 10);
                result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
              }
              resolve(result2);
            });
          } else {
            resolve(result2);
          }
        }
        if (_freebsd$7 || _openbsd$7 || _netbsd$7) {
          cmd = "netstat -ibndI " + ifaceSanitized;
          exec$8(cmd, function(error, stdout) {
            if (!error) {
              lines = stdout.toString().split("\n");
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i].replace(/ +/g, " ").split(" ");
                if (line && line[0] && line[7] && line[10]) {
                  rx_bytes = rx_bytes + parseInt(line[7]);
                  if (line[6].trim() !== "-") {
                    rx_dropped = rx_dropped + parseInt(line[6]);
                  }
                  if (line[5].trim() !== "-") {
                    rx_errors = rx_errors + parseInt(line[5]);
                  }
                  tx_bytes = tx_bytes + parseInt(line[10]);
                  if (line[12].trim() !== "-") {
                    tx_dropped = tx_dropped + parseInt(line[12]);
                  }
                  if (line[9].trim() !== "-") {
                    tx_errors = tx_errors + parseInt(line[9]);
                  }
                  operstate = "up";
                }
              }
              result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
            }
            resolve(result2);
          });
        }
        if (_darwin$8) {
          cmd = "ifconfig " + ifaceSanitized + ' | grep "status"';
          exec$8(cmd, function(error, stdout) {
            result2.operstate = (stdout.toString().split(":")[1] || "").trim();
            result2.operstate = (result2.operstate || "").toLowerCase();
            result2.operstate = result2.operstate === "active" ? "up" : result2.operstate === "inactive" ? "down" : "unknown";
            cmd = "netstat -bdI " + ifaceSanitized;
            exec$8(cmd, function(error2, stdout2) {
              if (!error2) {
                lines = stdout2.toString().split("\n");
                if (lines.length > 1 && lines[1].trim() !== "") {
                  stats = lines[1].replace(/ +/g, " ").split(" ");
                  const offset = stats.length > 11 ? 1 : 0;
                  rx_bytes = parseInt(stats[offset + 5]);
                  rx_dropped = parseInt(stats[offset + 10]);
                  rx_errors = parseInt(stats[offset + 4]);
                  tx_bytes = parseInt(stats[offset + 8]);
                  tx_dropped = parseInt(stats[offset + 10]);
                  tx_errors = parseInt(stats[offset + 7]);
                  result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result2.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
              }
              resolve(result2);
            });
          });
        }
        if (_windows$9) {
          let perfData = [];
          let ifaceName = ifaceSanitized;
          util$a.powerShell("Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl").then((stdout, error) => {
            if (!error) {
              const psections = stdout.toString().split(/\n\s*\n/);
              perfData = parseLinesWindowsPerfData(psections);
            }
            networkInterfaces(false).then((interfaces) => {
              rx_bytes = 0;
              tx_bytes = 0;
              perfData.forEach((detail) => {
                interfaces.forEach((det) => {
                  if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() || det.mac.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() || det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === ifaceSanitized.replace(/[()[\] ]+/g, "").replace("#", "_").toLowerCase()) && det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === detail.name) {
                    ifaceName = det.iface;
                    rx_bytes = detail.rx_bytes;
                    rx_dropped = detail.rx_dropped;
                    rx_errors = detail.rx_errors;
                    tx_bytes = detail.tx_bytes;
                    tx_dropped = detail.tx_dropped;
                    tx_errors = detail.tx_errors;
                    operstate = det.operstate;
                  }
                });
              });
              if (rx_bytes && tx_bytes) {
                result2 = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
              }
              resolve(result2);
            });
          });
        }
      } else {
        result2.rx_bytes = _network[ifaceSanitized].rx_bytes;
        result2.tx_bytes = _network[ifaceSanitized].tx_bytes;
        result2.rx_sec = _network[ifaceSanitized].rx_sec;
        result2.tx_sec = _network[ifaceSanitized].tx_sec;
        result2.ms = _network[ifaceSanitized].last_ms;
        result2.operstate = _network[ifaceSanitized].operstate;
        resolve(result2);
      }
    });
  });
}
network.networkStats = networkStats;
function getProcessName(processes2, pid) {
  let cmd = "";
  processes2.forEach((line) => {
    const parts = line.split(" ");
    const id = parseInt(parts[0], 10) || -1;
    if (id === pid) {
      parts.shift();
      cmd = parts.join(" ").split(":")[0];
    }
  });
  cmd = cmd.split(" -")[0];
  cmd = cmd.split(" /")[0];
  return cmd;
}
function networkConnections(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$8 || _freebsd$7 || _openbsd$7 || _netbsd$7) {
        let cmd = 'export LC_ALL=C; netstat -tunap | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
        if (_freebsd$7 || _openbsd$7 || _netbsd$7) {
          cmd = 'export LC_ALL=C; netstat -na | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
        }
        exec$8(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
          let lines = stdout.toString().split("\n");
          if (!error && (lines.length > 1 || lines[0] != "")) {
            lines.forEach(function(line) {
              line = line.replace(/ +/g, " ").split(" ");
              if (line.length >= 7) {
                let localip = line[3];
                let localport = "";
                let localaddress = line[3].split(":");
                if (localaddress.length > 1) {
                  localport = localaddress[localaddress.length - 1];
                  localaddress.pop();
                  localip = localaddress.join(":");
                }
                let peerip = line[4];
                let peerport = "";
                let peeraddress = line[4].split(":");
                if (peeraddress.length > 1) {
                  peerport = peeraddress[peeraddress.length - 1];
                  peeraddress.pop();
                  peerip = peeraddress.join(":");
                }
                let connstate = line[5];
                let proc = line[6].split("/");
                if (connstate) {
                  result2.push({
                    protocol: line[0],
                    localAddress: localip,
                    localPort: localport,
                    peerAddress: peerip,
                    peerPort: peerport,
                    state: connstate,
                    pid: proc[0] && proc[0] !== "-" ? parseInt(proc[0], 10) : null,
                    process: proc[1] ? proc[1].split(" ")[0].split(":")[0] : ""
                  });
                }
              }
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          } else {
            cmd = 'ss -tunap | grep "ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-ACK\\|LISTEN\\|CLOSING"';
            exec$8(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
              if (!error2) {
                let lines2 = stdout2.toString().split("\n");
                lines2.forEach(function(line) {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 6) {
                    let localip = line[4];
                    let localport = "";
                    let localaddress = line[4].split(":");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(":");
                    }
                    let peerip = line[5];
                    let peerport = "";
                    let peeraddress = line[5].split(":");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(":");
                    }
                    let connstate = line[1];
                    if (connstate === "ESTAB") {
                      connstate = "ESTABLISHED";
                    }
                    if (connstate === "TIME-WAIT") {
                      connstate = "TIME_WAIT";
                    }
                    let pid = null;
                    let process2 = "";
                    if (line.length >= 7 && line[6].indexOf("users:") > -1) {
                      let proc = line[6].replace('users:(("', "").replace(/"/g, "").split(",");
                      if (proc.length > 2) {
                        process2 = proc[0].split(" ")[0].split(":")[0];
                        pid = parseInt(proc[1], 10);
                      }
                    }
                    if (connstate) {
                      result2.push({
                        protocol: line[0],
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid,
                        process: process2
                      });
                    }
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
        });
      }
      if (_darwin$8) {
        let cmd = 'netstat -natvln | head -n2; netstat -natvln | grep "tcp4\\|tcp6\\|udp4\\|udp6"';
        const states = "ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT_1|FIN_WAIT2|FIN_WAIT_2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN".split("|");
        exec$8(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
          if (!error) {
            exec$8("ps -axo pid,command", { maxBuffer: 1024 * 2e4 }, function(err2, stdout2) {
              let processes2 = stdout2.toString().split("\n");
              processes2 = processes2.map((line) => {
                return line.trim().replace(/ +/g, " ");
              });
              let lines = stdout.toString().split("\n");
              lines.shift();
              let pidPos = 8;
              if (lines.length > 1 && lines[0].indexOf("pid") > 0) {
                const header = (lines.shift() || "").replace(/ Address/g, "_Address").replace(/ +/g, " ").split(" ");
                pidPos = header.indexOf("pid");
              }
              lines.forEach(function(line) {
                line = line.replace(/ +/g, " ").split(" ");
                if (line.length >= 8) {
                  let localip = line[3];
                  let localport = "";
                  let localaddress = line[3].split(".");
                  if (localaddress.length > 1) {
                    localport = localaddress[localaddress.length - 1];
                    localaddress.pop();
                    localip = localaddress.join(".");
                  }
                  let peerip = line[4];
                  let peerport = "";
                  let peeraddress = line[4].split(".");
                  if (peeraddress.length > 1) {
                    peerport = peeraddress[peeraddress.length - 1];
                    peeraddress.pop();
                    peerip = peeraddress.join(".");
                  }
                  const hasState = states.indexOf(line[5]) >= 0;
                  let connstate = hasState ? line[5] : "UNKNOWN";
                  let pid = parseInt(line[pidPos + (hasState ? 0 : -1)], 10);
                  if (connstate) {
                    result2.push({
                      protocol: line[0],
                      localAddress: localip,
                      localPort: localport,
                      peerAddress: peerip,
                      peerPort: peerport,
                      state: connstate,
                      pid,
                      process: getProcessName(processes2, pid)
                    });
                  }
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
        });
      }
      if (_windows$9) {
        let cmd = "netstat -nao";
        try {
          exec$8(cmd, util$a.execOptsWin, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\r\n");
              lines.forEach(function(line) {
                line = line.trim().replace(/ +/g, " ").split(" ");
                if (line.length >= 4) {
                  let localip = line[1];
                  let localport = "";
                  let localaddress = line[1].split(":");
                  if (localaddress.length > 1) {
                    localport = localaddress[localaddress.length - 1];
                    localaddress.pop();
                    localip = localaddress.join(":");
                  }
                  localip = localip.replace(/\[/g, "").replace(/\]/g, "");
                  let peerip = line[2];
                  let peerport = "";
                  let peeraddress = line[2].split(":");
                  if (peeraddress.length > 1) {
                    peerport = peeraddress[peeraddress.length - 1];
                    peeraddress.pop();
                    peerip = peeraddress.join(":");
                  }
                  peerip = peerip.replace(/\[/g, "").replace(/\]/g, "");
                  let pid = util$a.toInt(line[4]);
                  let connstate = line[3];
                  if (connstate === "HERGESTELLT") {
                    connstate = "ESTABLISHED";
                  }
                  if (connstate.startsWith("ABH")) {
                    connstate = "LISTEN";
                  }
                  if (connstate === "SCHLIESSEN_WARTEN") {
                    connstate = "CLOSE_WAIT";
                  }
                  if (connstate === "WARTEND") {
                    connstate = "TIME_WAIT";
                  }
                  if (connstate === "SYN_GESENDET") {
                    connstate = "SYN_SENT";
                  }
                  if (connstate === "LISTENING") {
                    connstate = "LISTEN";
                  }
                  if (connstate === "SYN_RECEIVED") {
                    connstate = "SYN_RECV";
                  }
                  if (connstate === "FIN_WAIT_1") {
                    connstate = "FIN_WAIT1";
                  }
                  if (connstate === "FIN_WAIT_2") {
                    connstate = "FIN_WAIT2";
                  }
                  if (line[0].toLowerCase() !== "udp" && connstate) {
                    result2.push({
                      protocol: line[0].toLowerCase(),
                      localAddress: localip,
                      localPort: localport,
                      peerAddress: peerip,
                      peerPort: peerport,
                      state: connstate,
                      pid,
                      process: ""
                    });
                  } else if (line[0].toLowerCase() === "udp") {
                    result2.push({
                      protocol: line[0].toLowerCase(),
                      localAddress: localip,
                      localPort: localport,
                      peerAddress: peerip,
                      peerPort: peerport,
                      state: "",
                      pid: parseInt(line[3], 10),
                      process: ""
                    });
                  }
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
network.networkConnections = networkConnections;
function networkGatewayDefault(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = "";
      if (_linux$8 || _freebsd$7 || _openbsd$7 || _netbsd$7) {
        let cmd = "ip route get 1";
        try {
          exec$8(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              const line = lines && lines[0] ? lines[0] : "";
              let parts = line.split(" via ");
              if (parts && parts[1]) {
                parts = parts[1].split(" ");
                result2 = parts[0];
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_darwin$8) {
        let cmd = "route -n get default";
        try {
          exec$8(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
            if (!error) {
              const lines = stdout.toString().split("\n").map((line) => line.trim());
              result2 = util$a.getValue(lines, "gateway");
            }
            if (!result2) {
              cmd = "netstat -rn | awk '/default/ {print $2}'";
              exec$8(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                const lines = stdout2.toString().split("\n").map((line) => line.trim());
                result2 = lines.find((line) => /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line));
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_windows$9) {
        try {
          exec$8("netstat -r", util$a.execOptsWin, function(error, stdout) {
            const lines = stdout.toString().split(os$4.EOL);
            lines.forEach((line) => {
              line = line.replace(/\s+/g, " ").trim();
              if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
                const parts = line.split(" ");
                if (parts.length >= 5 && parts[parts.length - 3].indexOf(".") > -1) {
                  result2 = parts[parts.length - 3];
                }
              }
            });
            if (!result2) {
              util$a.powerShell("Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq '0.0.0.0' -and $_.Mask -eq '0.0.0.0' }").then((data) => {
                let lines2 = data.toString().split("\r\n");
                if (lines2.length > 1 && !result2) {
                  result2 = util$a.getValue(lines2, "NextHop");
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
network.networkGatewayDefault = networkGatewayDefault;
var wifi = {};
const os$3 = os$a;
const exec$7 = require$$1$1.exec;
const execSync$3 = require$$1$1.execSync;
const util$9 = util$j;
let _platform$8 = process.platform;
const _linux$7 = _platform$8 === "linux" || _platform$8 === "android";
const _darwin$7 = _platform$8 === "darwin";
const _windows$8 = _platform$8 === "win32";
function wifiDBFromQuality(quality) {
  const qual = parseFloat(quality);
  if (qual < 0) {
    return 0;
  }
  if (qual >= 100) {
    return -50;
  }
  return qual / 2 - 100;
}
function wifiQualityFromDB(db) {
  const result2 = 2 * (parseFloat(db) + 100);
  return result2 <= 100 ? result2 : 100;
}
const _wifi_frequencies = {
  1: 2412,
  2: 2417,
  3: 2422,
  4: 2427,
  5: 2432,
  6: 2437,
  7: 2442,
  8: 2447,
  9: 2452,
  10: 2457,
  11: 2462,
  12: 2467,
  13: 2472,
  14: 2484,
  32: 5160,
  34: 5170,
  36: 5180,
  38: 5190,
  40: 5200,
  42: 5210,
  44: 5220,
  46: 5230,
  48: 5240,
  50: 5250,
  52: 5260,
  54: 5270,
  56: 5280,
  58: 5290,
  60: 5300,
  62: 5310,
  64: 5320,
  68: 5340,
  96: 5480,
  100: 5500,
  102: 5510,
  104: 5520,
  106: 5530,
  108: 5540,
  110: 5550,
  112: 5560,
  114: 5570,
  116: 5580,
  118: 5590,
  120: 5600,
  122: 5610,
  124: 5620,
  126: 5630,
  128: 5640,
  132: 5660,
  134: 5670,
  136: 5680,
  138: 5690,
  140: 5700,
  142: 5710,
  144: 5720,
  149: 5745,
  151: 5755,
  153: 5765,
  155: 5775,
  157: 5785,
  159: 5795,
  161: 5805,
  165: 5825,
  169: 5845,
  173: 5865,
  183: 4915,
  184: 4920,
  185: 4925,
  187: 4935,
  188: 4940,
  189: 4945,
  192: 4960,
  196: 4980
};
function wifiFrequencyFromChannel(channel) {
  return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;
}
function wifiChannelFromFrequencs(frequency) {
  let channel = 0;
  for (let key2 in _wifi_frequencies) {
    if ({}.hasOwnProperty.call(_wifi_frequencies, key2)) {
      if (_wifi_frequencies[key2] === frequency) {
        channel = util$9.toInt(key2);
      }
    }
  }
  return channel;
}
function ifaceListLinux() {
  const result2 = [];
  const cmd = "iw dev 2>/dev/null";
  try {
    const all = execSync$3(cmd, util$9.execOptsLinux).toString().split("\n").map((line) => line.trim()).join("\n");
    const parts = all.split("\nInterface ");
    parts.shift();
    parts.forEach((ifaceDetails) => {
      const lines = ifaceDetails.split("\n");
      const iface = lines[0];
      const id = util$9.toInt(util$9.getValue(lines, "ifindex", " "));
      const mac = util$9.getValue(lines, "addr", " ");
      const channel = util$9.toInt(util$9.getValue(lines, "channel", " "));
      result2.push({
        id,
        iface,
        mac,
        channel
      });
    });
    return result2;
  } catch (e) {
    try {
      const all = execSync$3("nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null", util$9.execOptsLinux).toString();
      const parts = all.split("\n\n");
      let i = 1;
      parts.forEach((ifaceDetails) => {
        const lines = ifaceDetails.split("\n");
        const iface = util$9.getValue(lines, "GENERAL.DEVICE");
        const type = util$9.getValue(lines, "GENERAL.TYPE");
        const id = i++;
        const mac = util$9.getValue(lines, "GENERAL.HWADDR");
        const channel = "";
        if (type.toLowerCase() === "wifi") {
          result2.push({
            id,
            iface,
            mac,
            channel
          });
        }
      });
      return result2;
    } catch (e2) {
      return [];
    }
  }
}
function nmiDeviceLinux(iface) {
  const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2> /dev/null`;
  try {
    const lines = execSync$3(cmd, util$9.execOptsLinux).toString().split("\n");
    const ssid = util$9.getValue(lines, "GENERAL.CONNECTION");
    return {
      iface,
      type: util$9.getValue(lines, "GENERAL.TYPE"),
      vendor: util$9.getValue(lines, "GENERAL.VENDOR"),
      product: util$9.getValue(lines, "GENERAL.PRODUCT"),
      mac: util$9.getValue(lines, "GENERAL.HWADDR").toLowerCase(),
      ssid: ssid !== "--" ? ssid : null
    };
  } catch (e) {
    return {};
  }
}
function nmiConnectionLinux(ssid) {
  const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;
  try {
    const lines = execSync$3(cmd, util$9.execOptsLinux).toString().split("\n");
    const bssid = util$9.getValue(lines, "802-11-wireless.seen-bssids").toLowerCase();
    return {
      ssid: ssid !== "--" ? ssid : null,
      uuid: util$9.getValue(lines, "connection.uuid"),
      type: util$9.getValue(lines, "connection.type"),
      autoconnect: util$9.getValue(lines, "connection.autoconnect") === "yes",
      security: util$9.getValue(lines, "802-11-wireless-security.key-mgmt"),
      bssid: bssid !== "--" ? bssid : null
    };
  } catch (e) {
    return {};
  }
}
function wpaConnectionLinux(iface) {
  if (!iface) {
    return {};
  }
  const cmd = `wpa_cli -i ${iface} status 2>&1`;
  try {
    const lines = execSync$3(cmd, util$9.execOptsLinux).toString().split("\n");
    const freq = util$9.toInt(util$9.getValue(lines, "freq", "="));
    return {
      ssid: util$9.getValue(lines, "ssid", "="),
      uuid: util$9.getValue(lines, "uuid", "="),
      security: util$9.getValue(lines, "key_mgmt", "="),
      freq,
      channel: wifiChannelFromFrequencs(freq),
      bssid: util$9.getValue(lines, "bssid", "=").toLowerCase()
    };
  } catch (e) {
    return {};
  }
}
function getWifiNetworkListNmi() {
  const result2 = [];
  const cmd = "nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null";
  try {
    const stdout = execSync$3(cmd, util$9.execOptsLinux);
    const parts = stdout.toString().split("ACTIVE:");
    parts.shift();
    parts.forEach((part) => {
      part = "ACTIVE:" + part;
      const lines = part.split(os$3.EOL);
      const channel = util$9.getValue(lines, "CHAN");
      const frequency = util$9.getValue(lines, "FREQ").toLowerCase().replace("mhz", "").trim();
      const security = util$9.getValue(lines, "SECURITY").replace("(", "").replace(")", "");
      const wpaFlags = util$9.getValue(lines, "WPA-FLAGS").replace("(", "").replace(")", "");
      const rsnFlags = util$9.getValue(lines, "RSN-FLAGS").replace("(", "").replace(")", "");
      const quality = util$9.getValue(lines, "SIGNAL");
      result2.push({
        ssid: util$9.getValue(lines, "SSID"),
        bssid: util$9.getValue(lines, "BSSID").toLowerCase(),
        mode: util$9.getValue(lines, "MODE"),
        channel: channel ? parseInt(channel, 10) : null,
        frequency: frequency ? parseInt(frequency, 10) : null,
        signalLevel: wifiDBFromQuality(quality),
        quality: quality ? parseInt(quality, 10) : null,
        security: security && security !== "none" ? security.split(" ") : [],
        wpaFlags: wpaFlags && wpaFlags !== "none" ? wpaFlags.split(" ") : [],
        rsnFlags: rsnFlags && rsnFlags !== "none" ? rsnFlags.split(" ") : []
      });
    });
    return result2;
  } catch (e) {
    return [];
  }
}
function getWifiNetworkListIw(iface) {
  const result2 = [];
  try {
    let iwlistParts = execSync$3(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`, util$9.execOptsLinux).toString().split("        Cell ");
    if (iwlistParts[0].indexOf("resource busy") >= 0) {
      return -1;
    }
    if (iwlistParts.length > 1) {
      iwlistParts.shift();
      iwlistParts.forEach((element) => {
        const lines = element.split("\n");
        const channel = util$9.getValue(lines, "channel", ":", true);
        const address = lines && lines.length && lines[0].indexOf("Address:") >= 0 ? lines[0].split("Address:")[1].trim().toLowerCase() : "";
        const mode = util$9.getValue(lines, "mode", ":", true);
        const frequency = util$9.getValue(lines, "frequency", ":", true);
        const qualityString = util$9.getValue(lines, "Quality", "=", true);
        const dbParts = qualityString.toLowerCase().split("signal level=");
        const db = dbParts.length > 1 ? util$9.toInt(dbParts[1]) : 0;
        const quality = db ? wifiQualityFromDB(db) : 0;
        const ssid = util$9.getValue(lines, "essid", ":", true);
        const isWpa = element.indexOf(" WPA ") >= 0;
        const isWpa2 = element.indexOf("WPA2 ") >= 0;
        const security = [];
        if (isWpa) {
          security.push("WPA");
        }
        if (isWpa2) {
          security.push("WPA2");
        }
        const wpaFlags = [];
        let wpaFlag = "";
        lines.forEach(function(line) {
          const l = line.trim().toLowerCase();
          if (l.indexOf("group cipher") >= 0) {
            if (wpaFlag) {
              wpaFlags.push(wpaFlag);
            }
            const parts = l.split(":");
            if (parts.length > 1) {
              wpaFlag = parts[1].trim().toUpperCase();
            }
          }
          if (l.indexOf("pairwise cipher") >= 0) {
            const parts = l.split(":");
            if (parts.length > 1) {
              if (parts[1].indexOf("tkip")) {
                wpaFlag = wpaFlag ? "TKIP/" + wpaFlag : "TKIP";
              } else if (parts[1].indexOf("ccmp")) {
                wpaFlag = wpaFlag ? "CCMP/" + wpaFlag : "CCMP";
              } else if (parts[1].indexOf("proprietary")) {
                wpaFlag = wpaFlag ? "PROP/" + wpaFlag : "PROP";
              }
            }
          }
          if (l.indexOf("authentication suites") >= 0) {
            const parts = l.split(":");
            if (parts.length > 1) {
              if (parts[1].indexOf("802.1x")) {
                wpaFlag = wpaFlag ? "802.1x/" + wpaFlag : "802.1x";
              } else if (parts[1].indexOf("psk")) {
                wpaFlag = wpaFlag ? "PSK/" + wpaFlag : "PSK";
              }
            }
          }
        });
        if (wpaFlag) {
          wpaFlags.push(wpaFlag);
        }
        result2.push({
          ssid,
          bssid: address,
          mode,
          channel: channel ? util$9.toInt(channel) : null,
          frequency: frequency ? util$9.toInt(frequency.replace(".", "")) : null,
          signalLevel: db,
          quality,
          security,
          wpaFlags,
          rsnFlags: []
        });
      });
    }
    return result2;
  } catch (e) {
    return -1;
  }
}
function parseWifiDarwin(wifiStr) {
  const result2 = [];
  try {
    let wifiObj = JSON.parse(wifiStr);
    wifiObj = wifiObj.SPAirPortDataType[0].spairport_airport_interfaces[0].spairport_airport_other_local_wireless_networks;
    wifiObj.forEach(function(wifiItem) {
      let security = [];
      const sm = wifiItem.spairport_security_mode;
      if (sm === "spairport_security_mode_wep") {
        security.push("WEP");
      } else if (sm === "spairport_security_mode_wpa2_personal") {
        security.push("WPA2");
      } else if (sm.startsWith("spairport_security_mode_wpa2_enterprise")) {
        security.push("WPA2 EAP");
      } else if (sm.startsWith("pairport_security_mode_wpa3_transition")) {
        security.push("WPA2/WPA3");
      } else if (sm.startsWith("pairport_security_mode_wpa3")) {
        security.push("WPA3");
      }
      const channel = parseInt(("" + wifiItem.spairport_network_channel).split(" ")[0]) || 0;
      const signalLevel = wifiItem.spairport_signal_noise || null;
      result2.push({
        ssid: wifiItem._name || "",
        bssid: wifiItem.spairport_network_bssid || null,
        mode: wifiItem.spairport_network_phymode,
        channel,
        frequency: wifiFrequencyFromChannel(channel),
        signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
        quality: wifiQualityFromDB(signalLevel),
        security,
        wpaFlags: [],
        rsnFlags: []
      });
    });
    return result2;
  } catch (e) {
    return result2;
  }
}
function wifiNetworks(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$7) {
        result2 = getWifiNetworkListNmi();
        if (result2.length === 0) {
          try {
            const iwconfigParts = execSync$3("export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL", util$9.execOptsLinux).toString().split("\n\n");
            let iface = "";
            iwconfigParts.forEach((element) => {
              if (element.indexOf("no wireless") === -1 && element.trim() !== "") {
                iface = element.split(" ")[0];
              }
            });
            if (iface) {
              let ifaceSanitized = "";
              const s = util$9.isPrototypePolluted() ? "---" : util$9.sanitizeShellString(iface, true);
              const l = util$9.mathMin(s.length, 2e3);
              for (let i = 0; i <= l; i++) {
                if (s[i] !== void 0) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              const res = getWifiNetworkListIw(ifaceSanitized);
              if (res === -1) {
                setTimeout(function(iface2) {
                  const res2 = getWifiNetworkListIw(iface2);
                  if (res2 != -1) {
                    result2 = res2;
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }, 4e3);
              } else {
                result2 = res;
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      } else if (_darwin$7) {
        let cmd = "system_profiler SPAirPortDataType -json 2>/dev/null";
        exec$7(cmd, { maxBuffer: 1024 * 4e4 }, function(error, stdout) {
          result2 = parseWifiDarwin(stdout.toString());
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else if (_windows$8) {
        let cmd = "netsh wlan show networks mode=Bssid";
        util$9.powerShell(cmd).then((stdout) => {
          const ssidParts = stdout.toString("utf8").split(os$3.EOL + os$3.EOL + "SSID ");
          ssidParts.shift();
          ssidParts.forEach((ssidPart) => {
            const ssidLines = ssidPart.split(os$3.EOL);
            if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(":") >= 0) {
              const bssidsParts = ssidPart.split(" BSSID");
              bssidsParts.shift();
              bssidsParts.forEach((bssidPart) => {
                const bssidLines = bssidPart.split(os$3.EOL);
                const bssidLine = bssidLines[0].split(":");
                bssidLine.shift();
                const bssid = bssidLine.join(":").trim().toLowerCase();
                const channel = bssidLines[3].split(":").pop().trim();
                const quality = bssidLines[1].split(":").pop().trim();
                result2.push({
                  ssid: ssidLines[0].split(":").pop().trim(),
                  bssid,
                  mode: "",
                  channel: channel ? parseInt(channel, 10) : null,
                  frequency: wifiFrequencyFromChannel(channel),
                  signalLevel: wifiDBFromQuality(quality),
                  quality: quality ? parseInt(quality, 10) : null,
                  security: [ssidLines[2].split(":").pop().trim()],
                  wpaFlags: [ssidLines[3].split(":").pop().trim()],
                  rsnFlags: []
                });
              });
            }
          });
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
wifi.wifiNetworks = wifiNetworks;
function getVendor(model) {
  model = model.toLowerCase();
  let result2 = "";
  if (model.indexOf("intel") >= 0) {
    result2 = "Intel";
  } else if (model.indexOf("realtek") >= 0) {
    result2 = "Realtek";
  } else if (model.indexOf("qualcom") >= 0) {
    result2 = "Qualcom";
  } else if (model.indexOf("broadcom") >= 0) {
    result2 = "Broadcom";
  } else if (model.indexOf("cavium") >= 0) {
    result2 = "Cavium";
  } else if (model.indexOf("cisco") >= 0) {
    result2 = "Cisco";
  } else if (model.indexOf("marvel") >= 0) {
    result2 = "Marvel";
  } else if (model.indexOf("zyxel") >= 0) {
    result2 = "Zyxel";
  } else if (model.indexOf("melanox") >= 0) {
    result2 = "Melanox";
  } else if (model.indexOf("d-link") >= 0) {
    result2 = "D-Link";
  } else if (model.indexOf("tp-link") >= 0) {
    result2 = "TP-Link";
  } else if (model.indexOf("asus") >= 0) {
    result2 = "Asus";
  } else if (model.indexOf("linksys") >= 0) {
    result2 = "Linksys";
  }
  return result2;
}
function wifiConnections(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      const result2 = [];
      if (_linux$7) {
        const ifaces = ifaceListLinux();
        const networkList = getWifiNetworkListNmi();
        ifaces.forEach((ifaceDetail) => {
          let ifaceSanitized = "";
          const s = util$9.isPrototypePolluted() ? "---" : util$9.sanitizeShellString(ifaceDetail.iface, true);
          const ll = util$9.mathMin(s.length, 2e3);
          for (let i = 0; i <= ll; i++) {
            if (s[i] !== void 0) {
              ifaceSanitized = ifaceSanitized + s[i];
            }
          }
          const nmiDetails = nmiDeviceLinux(ifaceSanitized);
          const wpaDetails = wpaConnectionLinux(ifaceSanitized);
          const ssid = nmiDetails.ssid || wpaDetails.ssid;
          const network2 = networkList.filter((nw) => nw.ssid === ssid);
          let ssidSanitized = "";
          const t = util$9.isPrototypePolluted() ? "---" : util$9.sanitizeShellString(ssid, true);
          const l = util$9.mathMin(t.length, 32);
          for (let i = 0; i <= l; i++) {
            if (t[i] !== void 0) {
              ssidSanitized = ssidSanitized + t[i];
            }
          }
          const nmiConnection = nmiConnectionLinux(ssidSanitized);
          const channel = network2 && network2.length && network2[0].channel ? network2[0].channel : wpaDetails.channel ? wpaDetails.channel : null;
          const bssid = network2 && network2.length && network2[0].bssid ? network2[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null;
          const signalLevel = network2 && network2.length && network2[0].signalLevel ? network2[0].signalLevel : null;
          if (ssid && bssid) {
            result2.push({
              id: ifaceDetail.id,
              iface: ifaceDetail.iface,
              model: nmiDetails.product,
              ssid,
              bssid: network2 && network2.length && network2[0].bssid ? network2[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null,
              channel,
              frequency: channel ? wifiFrequencyFromChannel(channel) : null,
              type: nmiConnection.type ? nmiConnection.type : "802.11",
              security: nmiConnection.security ? nmiConnection.security : wpaDetails.security ? wpaDetails.security : null,
              signalLevel,
              quality: wifiQualityFromDB(signalLevel),
              txRate: null
            });
          }
        });
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      } else if (_darwin$7) {
        let cmd = 'system_profiler SPNetworkDataType SPAirPortDataType -xml 2>/dev/null; echo "######" ; ioreg -n AppleBCMWLANSkywalkInterface -r 2>/dev/null';
        exec$7(cmd, function(error, stdout) {
          try {
            const parts = stdout.toString().split("######");
            const profilerObj = util$9.plistParser(parts[0]);
            const networkObj = profilerObj[0]._SPCommandLineArguments.indexOf("SPNetworkDataType") >= 0 ? profilerObj[0]._items : profilerObj[1]._items;
            const airportObj = profilerObj[0]._SPCommandLineArguments.indexOf("SPAirPortDataType") >= 0 ? profilerObj[0]._items[0].spairport_airport_interfaces : profilerObj[1]._items[0].spairport_airport_interfaces;
            let lines3 = [];
            if (parts[1].indexOf("  | {") > 0 && parts[1].indexOf("  | }") > parts[1].indexOf("  | {")) {
              lines3 = parts[1].split("  | {")[1].split("  | }")[0].replace(/ \| /g, "").replace(/"/g, "").split("\n");
            }
            const networkWifiObj = networkObj.find((item) => {
              return item._name === "Wi-Fi";
            });
            const airportWifiObj = airportObj[0].spairport_current_network_information;
            const channel = parseInt(("" + airportWifiObj.spairport_network_channel).split(" ")[0]) || 0;
            const signalLevel = airportWifiObj.spairport_signal_noise || null;
            let security = [];
            const sm = airportWifiObj.spairport_security_mode;
            if (sm === "spairport_security_mode_wep") {
              security.push("WEP");
            } else if (sm === "spairport_security_mode_wpa2_personal") {
              security.push("WPA2");
            } else if (sm.startsWith("spairport_security_mode_wpa2_enterprise")) {
              security.push("WPA2 EAP");
            } else if (sm.startsWith("pairport_security_mode_wpa3_transition")) {
              security.push("WPA2/WPA3");
            } else if (sm.startsWith("pairport_security_mode_wpa3")) {
              security.push("WPA3");
            }
            result2.push({
              id: networkWifiObj._name || "Wi-Fi",
              iface: networkWifiObj.interface || "",
              model: networkWifiObj.hardware || "",
              ssid: airportWifiObj._name || "",
              bssid: airportWifiObj.spairport_network_bssid || "",
              channel,
              frequency: channel ? wifiFrequencyFromChannel(channel) : null,
              type: airportWifiObj.spairport_network_phymode || "802.11",
              security,
              signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
              quality: wifiQualityFromDB(signalLevel),
              txRate: airportWifiObj.spairport_network_rate || null
            });
          } catch (e) {
            util$9.noop();
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else if (_windows$8) {
        let cmd = "netsh wlan show interfaces";
        util$9.powerShell(cmd).then(function(stdout) {
          const allLines = stdout.toString().split("\r\n");
          for (let i = 0; i < allLines.length; i++) {
            allLines[i] = allLines[i].trim();
          }
          const parts = allLines.join("\r\n").split(":\r\n\r\n");
          parts.shift();
          parts.forEach((part) => {
            const lines = part.split("\r\n");
            if (lines.length >= 5) {
              const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
              const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
              const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
              const ssid = util$9.getValue(lines, "SSID", ":", true);
              const bssid = util$9.getValue(lines, "BSSID", ":", true) || util$9.getValue(lines, "AP BSSID", ":", true);
              const quality = util$9.getValue(lines, "Signal", ":", true);
              const signalLevel = wifiDBFromQuality(quality);
              const type = util$9.getValue(lines, "Radio type", ":", true) || util$9.getValue(lines, "Type de radio", ":", true) || util$9.getValue(lines, "Funktyp", ":", true) || null;
              const security = util$9.getValue(lines, "authentication", ":", true) || util$9.getValue(lines, "Authentification", ":", true) || util$9.getValue(lines, "Authentifizierung", ":", true) || null;
              const channel = util$9.getValue(lines, "Channel", ":", true) || util$9.getValue(lines, "Canal", ":", true) || util$9.getValue(lines, "Kanal", ":", true) || null;
              const txRate = util$9.getValue(lines, "Transmit rate (mbps)", ":", true) || util$9.getValue(lines, "Transmission (mbit/s)", ":", true) || util$9.getValue(lines, "Empfangsrate (MBit/s)", ":", true) || null;
              if (model && id && ssid && bssid) {
                result2.push({
                  id,
                  iface,
                  model,
                  ssid,
                  bssid,
                  channel: util$9.toInt(channel),
                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                  type,
                  security,
                  signalLevel,
                  quality: quality ? parseInt(quality, 10) : null,
                  txRate: util$9.toInt(txRate) || null
                });
              }
            }
          });
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
wifi.wifiConnections = wifiConnections;
function wifiInterfaces(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      const result2 = [];
      if (_linux$7) {
        const ifaces = ifaceListLinux();
        ifaces.forEach((ifaceDetail) => {
          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);
          result2.push({
            id: ifaceDetail.id,
            iface: ifaceDetail.iface,
            model: nmiDetails.product ? nmiDetails.product : null,
            vendor: nmiDetails.vendor ? nmiDetails.vendor : null,
            mac: ifaceDetail.mac
          });
        });
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      } else if (_darwin$7) {
        let cmd = "system_profiler SPNetworkDataType";
        exec$7(cmd, function(error, stdout) {
          const parts1 = stdout.toString().split("\n\n    Wi-Fi:\n\n");
          if (parts1.length > 1) {
            const lines = parts1[1].split("\n\n")[0].split("\n");
            const iface = util$9.getValue(lines, "BSD Device Name", ":", true);
            const mac = util$9.getValue(lines, "MAC Address", ":", true);
            const model = util$9.getValue(lines, "hardware", ":", true);
            result2.push({
              id: "Wi-Fi",
              iface,
              model,
              vendor: "",
              mac
            });
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else if (_windows$8) {
        let cmd = "netsh wlan show interfaces";
        util$9.powerShell(cmd).then(function(stdout) {
          const allLines = stdout.toString().split("\r\n");
          for (let i = 0; i < allLines.length; i++) {
            allLines[i] = allLines[i].trim();
          }
          const parts = allLines.join("\r\n").split(":\r\n\r\n");
          parts.shift();
          parts.forEach((part) => {
            const lines = part.split("\r\n");
            if (lines.length >= 5) {
              const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
              const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
              const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
              const macParts = lines[3].indexOf(":") >= 0 ? lines[3].split(":") : [];
              macParts.shift();
              const mac = macParts.join(":").trim();
              const vendor = getVendor(model);
              if (iface && model && id && mac) {
                result2.push({
                  id,
                  iface,
                  model,
                  vendor,
                  mac
                });
              }
            }
          });
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
wifi.wifiInterfaces = wifiInterfaces;
var processes$1 = {};
const os$2 = os$a;
const fs$1 = require$$1$2;
const path$1 = require$$2$1;
const exec$6 = require$$1$1.exec;
const execSync$2 = require$$1$1.execSync;
const util$8 = util$j;
let _platform$7 = process.platform;
const _linux$6 = _platform$7 === "linux" || _platform$7 === "android";
const _darwin$6 = _platform$7 === "darwin";
const _windows$7 = _platform$7 === "win32";
const _freebsd$6 = _platform$7 === "freebsd";
const _openbsd$6 = _platform$7 === "openbsd";
const _netbsd$6 = _platform$7 === "netbsd";
const _sunos$6 = _platform$7 === "sunos";
const _processes_cpu = {
  all: 0,
  all_utime: 0,
  all_stime: 0,
  list: {},
  ms: 0,
  result: {}
};
const _services_cpu = {
  all: 0,
  list: {},
  ms: 0,
  result: {}
};
const _process_cpu = {
  all: 0,
  all_utime: 0,
  all_stime: 0,
  list: {},
  ms: 0,
  result: {}
};
const _winStatusValues = {
  "0": "unknown",
  "1": "other",
  "2": "ready",
  "3": "running",
  "4": "blocked",
  "5": "suspended blocked",
  "6": "suspended ready",
  "7": "terminated",
  "8": "stopped",
  "9": "growing"
};
function parseTimeUnix(time2) {
  let result2 = time2;
  let parts = time2.replace(/ +/g, " ").split(" ");
  if (parts.length === 5) {
    result2 = parts[4] + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + parts[2]).slice(-2) + " " + parts[3];
  }
  return result2;
}
function parseElapsedTime(etime) {
  let current = /* @__PURE__ */ new Date();
  current = new Date(current.getTime() - current.getTimezoneOffset() * 6e4);
  const elapsed = etime.split("-");
  const timeIndex = elapsed.length - 1;
  const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;
  const timeStr = elapsed[timeIndex].split(":");
  const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;
  const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);
  const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);
  const ms = (((days * 24 + hours) * 60 + mins) * 60 + secs) * 1e3;
  let res = new Date(current.getTime());
  let result2 = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
  try {
    res = new Date(current.getTime() - ms);
    result2 = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
  } catch (e) {
    util$8.noop();
  }
  return result2;
}
function services(srv, callback) {
  if (util$8.isFunction(srv) && !callback) {
    callback = srv;
    srv = "";
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (typeof srv !== "string") {
        if (callback) {
          callback([]);
        }
        return resolve([]);
      }
      if (srv) {
        let srvString = "";
        try {
          srvString.__proto__.toLowerCase = util$8.stringToLower;
          srvString.__proto__.replace = util$8.stringReplace;
          srvString.__proto__.toString = util$8.stringToString;
          srvString.__proto__.substr = util$8.stringSubstr;
          srvString.__proto__.substring = util$8.stringSubstring;
          srvString.__proto__.trim = util$8.stringTrim;
          srvString.__proto__.startsWith = util$8.stringStartWith;
        } catch (e) {
          Object.setPrototypeOf(srvString, util$8.stringObj);
        }
        const s = util$8.sanitizeShellString(srv);
        const l = util$8.mathMin(s.length, 2e3);
        for (let i = 0; i <= l; i++) {
          if (s[i] !== void 0) {
            srvString = srvString + s[i];
          }
        }
        srvString = srvString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
        if (srvString === "") {
          srvString = "*";
        }
        if (util$8.isPrototypePolluted() && srvString !== "*") {
          srvString = "------";
        }
        let srvs = srvString.split("|");
        let result2 = [];
        let dataSrv = [];
        if (_linux$6 || _freebsd$6 || _openbsd$6 || _netbsd$6 || _darwin$6) {
          if ((_linux$6 || _freebsd$6 || _openbsd$6 || _netbsd$6) && srvString === "*") {
            try {
              const tmpsrv = execSync$2("systemctl --all --type=service --no-legend 2> /dev/null", util$8.execOptsLinux).toString().split("\n");
              srvs = [];
              for (const s2 of tmpsrv) {
                const name = s2.split(".service")[0];
                if (name && s2.indexOf(" not-found ") === -1) {
                  srvs.push(name.trim());
                }
              }
              srvString = srvs.join("|");
            } catch (d) {
              try {
                srvString = "";
                const tmpsrv = execSync$2("service --status-all 2> /dev/null", util$8.execOptsLinux).toString().split("\n");
                for (const s2 of tmpsrv) {
                  const parts = s2.split("]");
                  if (parts.length === 2) {
                    srvString += (srvString !== "" ? "|" : "") + parts[1].trim();
                  }
                }
                srvs = srvString.split("|");
              } catch (e) {
                try {
                  const srvStr = execSync$2("ls /etc/init.d/ -m 2> /dev/null", util$8.execOptsLinux).toString().split("\n").join("");
                  srvString = "";
                  if (srvStr) {
                    const tmpsrv = srvStr.split(",");
                    for (const s2 of tmpsrv) {
                      const name = s2.trim();
                      if (name) {
                        srvString += (srvString !== "" ? "|" : "") + name;
                      }
                    }
                    srvs = srvString.split("|");
                  }
                } catch (f) {
                  srvString = "";
                  srvs = [];
                }
              }
            }
          }
          if (_darwin$6 && srvString === "*") {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
          let args = _darwin$6 ? ["-caxo", "pcpu,pmem,pid,command"] : ["-axo", "pcpu,pmem,pid,command"];
          if (srvString !== "" && srvs.length > 0) {
            util$8.execSafe("ps", args).then((stdout) => {
              if (stdout) {
                let lines = stdout.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                srvs.forEach(function(srv2) {
                  let ps;
                  if (_darwin$6) {
                    ps = lines.filter(function(e) {
                      return e.toLowerCase().indexOf(srv2) !== -1;
                    });
                  } else {
                    ps = lines.filter(function(e) {
                      return e.toLowerCase().indexOf(" " + srv2.toLowerCase() + ":") !== -1 || e.toLowerCase().indexOf("/" + srv2.toLowerCase()) !== -1;
                    });
                  }
                  const pids = [];
                  for (const p of ps) {
                    const pid = p.trim().split(" ")[2];
                    if (pid) {
                      pids.push(parseInt(pid, 10));
                    }
                  }
                  result2.push({
                    name: srv2,
                    running: ps.length > 0,
                    startmode: "",
                    pids,
                    cpu: parseFloat(ps.reduce(function(pv, cv) {
                      return pv + parseFloat(cv.trim().split(" ")[0]);
                    }, 0).toFixed(2)),
                    mem: parseFloat(ps.reduce(function(pv, cv) {
                      return pv + parseFloat(cv.trim().split(" ")[1]);
                    }, 0).toFixed(2))
                  });
                });
                if (_linux$6) {
                  let cmd = 'cat /proc/stat | grep "cpu "';
                  for (let i in result2) {
                    for (let j in result2[i].pids) {
                      cmd += ";cat /proc/" + result2[i].pids[j] + "/stat";
                    }
                  }
                  exec$6(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout2) {
                    let curr_processes = stdout2.toString().split("\n");
                    let all = parseProcStat(curr_processes.shift());
                    let list_new = {};
                    let resultProcess = {};
                    curr_processes.forEach((element) => {
                      resultProcess = calcProcStatLinux(element, all, _services_cpu);
                      if (resultProcess.pid) {
                        let listPos = -1;
                        for (let i in result2) {
                          for (let j in result2[i].pids) {
                            if (parseInt(result2[i].pids[j]) === parseInt(resultProcess.pid)) {
                              listPos = i;
                            }
                          }
                        }
                        if (listPos >= 0) {
                          result2[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                        }
                        list_new[resultProcess.pid] = {
                          cpuu: resultProcess.cpuu,
                          cpus: resultProcess.cpus,
                          utime: resultProcess.utime,
                          stime: resultProcess.stime,
                          cutime: resultProcess.cutime,
                          cstime: resultProcess.cstime
                        };
                      }
                    });
                    _services_cpu.all = all;
                    _services_cpu.list = Object.assign({}, list_new);
                    _services_cpu.ms = Date.now() - _services_cpu.ms;
                    _services_cpu.result = Object.assign({}, result2);
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              } else {
                args = ["-o", "comm"];
                util$8.execSafe("ps", args).then((stdout2) => {
                  if (stdout2) {
                    let lines = stdout2.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                    srvs.forEach(function(srv2) {
                      let ps = lines.filter(function(e) {
                        return e.indexOf(srv2) !== -1;
                      });
                      result2.push({
                        name: srv2,
                        running: ps.length > 0,
                        startmode: "",
                        cpu: 0,
                        mem: 0
                      });
                    });
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  } else {
                    srvs.forEach(function(srv2) {
                      result2.push({
                        name: srv2,
                        running: false,
                        startmode: "",
                        cpu: 0,
                        mem: 0
                      });
                    });
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }
                });
              }
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_windows$7) {
          try {
            let wincommand = "Get-CimInstance Win32_Service";
            if (srvs[0] !== "*") {
              wincommand += ' -Filter "';
              srvs.forEach((srv2) => {
                wincommand += `Name='${srv2}' or `;
              });
              wincommand = `${wincommand.slice(0, -4)}"`;
            }
            wincommand += " | select Name,Caption,Started,StartMode,ProcessId | fl";
            util$8.powerShell(wincommand).then((stdout, error) => {
              if (!error) {
                let serviceSections = stdout.split(/\n\s*\n/);
                serviceSections.forEach((element) => {
                  if (element.trim() !== "") {
                    let lines = element.trim().split("\r\n");
                    let srvName = util$8.getValue(lines, "Name", ":", true).toLowerCase();
                    let srvCaption = util$8.getValue(lines, "Caption", ":", true).toLowerCase();
                    let started = util$8.getValue(lines, "Started", ":", true);
                    let startMode = util$8.getValue(lines, "StartMode", ":", true);
                    let pid = util$8.getValue(lines, "ProcessId", ":", true);
                    if (srvString === "*" || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {
                      result2.push({
                        name: srvName,
                        running: started.toLowerCase() === "true",
                        startmode: startMode,
                        pids: [pid],
                        cpu: 0,
                        mem: 0
                      });
                      dataSrv.push(srvName);
                      dataSrv.push(srvCaption);
                    }
                  }
                });
                if (srvString !== "*") {
                  let srvsMissing = srvs.filter(function(e) {
                    return dataSrv.indexOf(e) === -1;
                  });
                  srvsMissing.forEach(function(srvName) {
                    result2.push({
                      name: srvName,
                      running: false,
                      startmode: "",
                      pids: [],
                      cpu: 0,
                      mem: 0
                    });
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              } else {
                srvs.forEach(function(srvName) {
                  result2.push({
                    name: srvName,
                    running: false,
                    startmode: "",
                    cpu: 0,
                    mem: 0
                  });
                });
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      } else {
        if (callback) {
          callback([]);
        }
        resolve([]);
      }
    });
  });
}
processes$1.services = services;
function parseProcStat(line) {
  let parts = line.replace(/ +/g, " ").split(" ");
  let user = parts.length >= 2 ? parseInt(parts[1]) : 0;
  let nice = parts.length >= 3 ? parseInt(parts[2]) : 0;
  let system2 = parts.length >= 4 ? parseInt(parts[3]) : 0;
  let idle = parts.length >= 5 ? parseInt(parts[4]) : 0;
  let iowait = parts.length >= 6 ? parseInt(parts[5]) : 0;
  let irq = parts.length >= 7 ? parseInt(parts[6]) : 0;
  let softirq = parts.length >= 8 ? parseInt(parts[7]) : 0;
  let steal = parts.length >= 9 ? parseInt(parts[8]) : 0;
  let guest = parts.length >= 10 ? parseInt(parts[9]) : 0;
  let guest_nice = parts.length >= 11 ? parseInt(parts[10]) : 0;
  return user + nice + system2 + idle + iowait + irq + softirq + steal + guest + guest_nice;
}
function calcProcStatLinux(line, all, _cpu_old) {
  let statparts = line.replace(/ +/g, " ").split(")");
  if (statparts.length >= 2) {
    let parts = statparts[1].split(" ");
    if (parts.length >= 16) {
      let pid = parseInt(statparts[0].split(" ")[0]);
      let utime = parseInt(parts[12]);
      let stime = parseInt(parts[13]);
      let cutime = parseInt(parts[14]);
      let cstime = parseInt(parts[15]);
      let cpuu = 0;
      let cpus = 0;
      if (_cpu_old.all > 0 && _cpu_old.list[pid]) {
        cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100;
        cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100;
      } else {
        cpuu = (utime + cutime) / all * 100;
        cpus = (stime + cstime) / all * 100;
      }
      return {
        pid,
        utime,
        stime,
        cutime,
        cstime,
        cpuu,
        cpus
      };
    } else {
      return {
        pid: 0,
        utime: 0,
        stime: 0,
        cutime: 0,
        cstime: 0,
        cpuu: 0,
        cpus: 0
      };
    }
  } else {
    return {
      pid: 0,
      utime: 0,
      stime: 0,
      cutime: 0,
      cstime: 0,
      cpuu: 0,
      cpus: 0
    };
  }
}
function calcProcStatWin(procStat, all, _cpu_old) {
  let cpuu = 0;
  let cpus = 0;
  if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {
    cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100;
    cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100;
  } else {
    cpuu = procStat.utime / all * 100;
    cpus = procStat.stime / all * 100;
  }
  return {
    pid: procStat.pid,
    utime: procStat.utime,
    stime: procStat.stime,
    cpuu: cpuu > 0 ? cpuu : 0,
    cpus: cpus > 0 ? cpus : 0
  };
}
function processes(callback) {
  let parsedhead = [];
  function getName(command) {
    command = command || "";
    let result2 = command.split(" ")[0];
    if (result2.substr(-1) === ":") {
      result2 = result2.substr(0, result2.length - 1);
    }
    if (result2.substr(0, 1) !== "[") {
      let parts = result2.split("/");
      if (isNaN(parseInt(parts[parts.length - 1]))) {
        result2 = parts[parts.length - 1];
      } else {
        result2 = parts[0];
      }
    }
    return result2;
  }
  function parseLine(line) {
    let offset = 0;
    let offset2 = 0;
    function checkColumn(i) {
      offset = offset2;
      if (parsedhead[i]) {
        offset2 = line.substring(parsedhead[i].to + offset, 1e4).indexOf(" ");
      } else {
        offset2 = 1e4;
      }
    }
    checkColumn(0);
    const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));
    checkColumn(1);
    const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));
    checkColumn(2);
    const cpu2 = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, "."));
    checkColumn(3);
    const mem2 = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, "."));
    checkColumn(4);
    const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));
    checkColumn(5);
    const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));
    checkColumn(6);
    const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));
    checkColumn(7);
    const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;
    checkColumn(8);
    const started = !_sunos$6 ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());
    checkColumn(9);
    let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();
    state = state[0] === "R" ? "running" : state[0] === "S" ? "sleeping" : state[0] === "T" ? "stopped" : state[0] === "W" ? "paging" : state[0] === "X" ? "dead" : state[0] === "Z" ? "zombie" : state[0] === "D" || state[0] === "U" ? "blocked" : "unknown";
    checkColumn(10);
    let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();
    if (tty === "?" || tty === "??") {
      tty = "";
    }
    checkColumn(11);
    const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();
    checkColumn(12);
    let cmdPath = "";
    let command = "";
    let params = "";
    let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();
    if (fullcommand.substr(fullcommand.length - 1) === "]") {
      fullcommand = fullcommand.slice(0, -1);
    }
    if (fullcommand.substr(0, 1) === "[") {
      command = fullcommand.substring(1);
    } else {
      const p1 = fullcommand.indexOf("(");
      const p2 = fullcommand.indexOf(")");
      const p3 = fullcommand.indexOf("/");
      const p4 = fullcommand.indexOf(":");
      if (p1 < p2 && p1 < p3 && p3 < p2) {
        command = fullcommand.split(" ")[0];
        command = command.replace(/:/g, "");
      } else {
        if (p4 > 0 && (p3 === -1 || p3 > 3)) {
          command = fullcommand.split(" ")[0];
          command = command.replace(/:/g, "");
        } else {
          let firstParamPos = fullcommand.indexOf(" -");
          let firstParamPathPos = fullcommand.indexOf(" /");
          firstParamPos = firstParamPos >= 0 ? firstParamPos : 1e4;
          firstParamPathPos = firstParamPathPos >= 0 ? firstParamPathPos : 1e4;
          const firstPos = Math.min(firstParamPos, firstParamPathPos);
          let tmpCommand = fullcommand.substr(0, firstPos);
          const tmpParams = fullcommand.substr(firstPos);
          const lastSlashPos = tmpCommand.lastIndexOf("/");
          if (lastSlashPos >= 0) {
            cmdPath = tmpCommand.substr(0, lastSlashPos);
            tmpCommand = tmpCommand.substr(lastSlashPos + 1);
          }
          if (firstPos === 1e4 && tmpCommand.indexOf(" ") > -1) {
            const parts = tmpCommand.split(" ");
            if (fs$1.existsSync(path$1.join(cmdPath, parts[0]))) {
              command = parts.shift();
              params = (parts.join(" ") + " " + tmpParams).trim();
            } else {
              command = tmpCommand.trim();
              params = tmpParams.trim();
            }
          } else {
            command = tmpCommand.trim();
            params = tmpParams.trim();
          }
        }
      }
    }
    return {
      pid,
      parentPid: ppid,
      name: _linux$6 ? getName(command) : command,
      cpu: cpu2,
      cpuu: 0,
      cpus: 0,
      mem: mem2,
      priority,
      memVsz: vsz,
      memRss: rss,
      nice,
      started,
      state,
      tty,
      user,
      command,
      params,
      path: cmdPath
    };
  }
  function parseProcesses(lines) {
    let result2 = [];
    if (lines.length > 1) {
      let head = lines[0];
      parsedhead = util$8.parseHead(head, 8);
      lines.shift();
      lines.forEach(function(line) {
        if (line.trim() !== "") {
          result2.push(parseLine(line));
        }
      });
    }
    return result2;
  }
  function parseProcesses2(lines) {
    function formatDateTime(time2) {
      const month = ("0" + (time2.getMonth() + 1).toString()).slice(-2);
      const year = time2.getFullYear().toString();
      const day = ("0" + time2.getDate().toString()).slice(-2);
      const hours = ("0" + time2.getHours().toString()).slice(-2);
      const mins = ("0" + time2.getMinutes().toString()).slice(-2);
      const secs = ("0" + time2.getSeconds().toString()).slice(-2);
      return year + "-" + month + "-" + day + " " + hours + ":" + mins + ":" + secs;
    }
    function parseElapsed(etime) {
      let started = "";
      if (etime.indexOf("d") >= 0) {
        const elapsed_parts = etime.split("d");
        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1e3));
      } else if (etime.indexOf("h") >= 0) {
        const elapsed_parts = etime.split("h");
        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1e3));
      } else if (etime.indexOf(":") >= 0) {
        const elapsed_parts = etime.split(":");
        started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1e3 : elapsed_parts[0] * 1e3)));
      }
      return started;
    }
    let result2 = [];
    lines.forEach(function(line) {
      if (line.trim() !== "") {
        line = line.trim().replace(/ +/g, " ").replace(/,+/g, ".");
        const parts = line.split(" ");
        const command = parts.slice(9).join(" ");
        const pmem = parseFloat((1 * parseInt(parts[3]) * 1024 / os$2.totalmem()).toFixed(1));
        const started = parseElapsed(parts[5]);
        result2.push({
          pid: parseInt(parts[0]),
          parentPid: parseInt(parts[1]),
          name: getName(command),
          cpu: 0,
          cpuu: 0,
          cpus: 0,
          mem: pmem,
          priority: 0,
          memVsz: parseInt(parts[2]),
          memRss: parseInt(parts[3]),
          nice: parseInt(parts[4]),
          started,
          state: parts[6] === "R" ? "running" : parts[6] === "S" ? "sleeping" : parts[6] === "T" ? "stopped" : parts[6] === "W" ? "paging" : parts[6] === "X" ? "dead" : parts[6] === "Z" ? "zombie" : parts[6] === "D" || parts[6] === "U" ? "blocked" : "unknown",
          tty: parts[7],
          user: parts[8],
          command
        });
      }
    });
    return result2;
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        all: 0,
        running: 0,
        blocked: 0,
        sleeping: 0,
        unknown: 0,
        list: []
      };
      let cmd = "";
      if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {
        if (_linux$6 || _freebsd$6 || _openbsd$6 || _netbsd$6 || _darwin$6 || _sunos$6) {
          if (_linux$6) {
            cmd = "export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL";
          }
          if (_freebsd$6 || _openbsd$6 || _netbsd$6) {
            cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL";
          }
          if (_darwin$6) {
            cmd = "ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r";
          }
          if (_sunos$6) {
            cmd = "ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm";
          }
          exec$6(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
            if (!error && stdout.toString().trim()) {
              result2.list = parseProcesses(stdout.toString().split("\n")).slice();
              result2.all = result2.list.length;
              result2.running = result2.list.filter(function(e) {
                return e.state === "running";
              }).length;
              result2.blocked = result2.list.filter(function(e) {
                return e.state === "blocked";
              }).length;
              result2.sleeping = result2.list.filter(function(e) {
                return e.state === "sleeping";
              }).length;
              if (_linux$6) {
                cmd = 'cat /proc/stat | grep "cpu "';
                result2.list.forEach((element) => {
                  cmd += ";cat /proc/" + element.pid + "/stat";
                });
                exec$6(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                  let curr_processes = stdout2.toString().split("\n");
                  let all = parseProcStat(curr_processes.shift());
                  let list_new = {};
                  let resultProcess = {};
                  curr_processes.forEach((element) => {
                    resultProcess = calcProcStatLinux(element, all, _processes_cpu);
                    if (resultProcess.pid) {
                      let listPos = result2.list.map(function(e) {
                        return e.pid;
                      }).indexOf(resultProcess.pid);
                      if (listPos >= 0) {
                        result2.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                        result2.list[listPos].cpuu = resultProcess.cpuu;
                        result2.list[listPos].cpus = resultProcess.cpus;
                      }
                      list_new[resultProcess.pid] = {
                        cpuu: resultProcess.cpuu,
                        cpus: resultProcess.cpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime,
                        cutime: resultProcess.cutime,
                        cstime: resultProcess.cstime
                      };
                    }
                  });
                  _processes_cpu.all = all;
                  _processes_cpu.list = Object.assign({}, list_new);
                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                  _processes_cpu.result = Object.assign({}, result2);
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              cmd = "ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm";
              if (_sunos$6) {
                cmd = "ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm";
              }
              exec$6(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  lines.shift();
                  result2.list = parseProcesses2(lines).slice();
                  result2.all = result2.list.length;
                  result2.running = result2.list.filter(function(e) {
                    return e.state === "running";
                  }).length;
                  result2.blocked = result2.list.filter(function(e) {
                    return e.state === "blocked";
                  }).length;
                  result2.sleeping = result2.list.filter(function(e) {
                    return e.state === "sleeping";
                  }).length;
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              });
            }
          });
        } else if (_windows$7) {
          try {
            util$8.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n="CreationDate";e={$_.CreationDate.ToString("yyyy-MM-dd HH:mm:ss")}} | fl').then((stdout, error) => {
              if (!error) {
                let processSections = stdout.split(/\n\s*\n/);
                let procs = [];
                let procStats = [];
                let list_new = {};
                let allcpuu = 0;
                let allcpus = 0;
                processSections.forEach((element) => {
                  if (element.trim() !== "") {
                    let lines = element.trim().split("\r\n");
                    let pid = parseInt(util$8.getValue(lines, "ProcessId", ":", true), 10);
                    let parentPid = parseInt(util$8.getValue(lines, "ParentProcessId", ":", true), 10);
                    let statusValue = util$8.getValue(lines, "ExecutionState", ":");
                    let name = util$8.getValue(lines, "Caption", ":", true);
                    let commandLine = util$8.getValue(lines, "CommandLine", ":", true);
                    let additionalCommand = false;
                    lines.forEach((line) => {
                      if (additionalCommand && line.toLowerCase().startsWith(" ")) {
                        commandLine += " " + line.trim();
                      } else {
                        additionalCommand = false;
                      }
                      if (line.toLowerCase().startsWith("commandline")) {
                        additionalCommand = true;
                      }
                    });
                    let commandPath = util$8.getValue(lines, "ExecutablePath", ":", true);
                    let utime = parseInt(util$8.getValue(lines, "UserModeTime", ":", true), 10);
                    let stime = parseInt(util$8.getValue(lines, "KernelModeTime", ":", true), 10);
                    let memw = parseInt(util$8.getValue(lines, "WorkingSetSize", ":", true), 10);
                    allcpuu = allcpuu + utime;
                    allcpus = allcpus + stime;
                    result2.all++;
                    if (!statusValue) {
                      result2.unknown++;
                    }
                    if (statusValue === "3") {
                      result2.running++;
                    }
                    if (statusValue === "4" || statusValue === "5") {
                      result2.blocked++;
                    }
                    procStats.push({
                      pid,
                      utime,
                      stime,
                      cpu: 0,
                      cpuu: 0,
                      cpus: 0
                    });
                    procs.push({
                      pid,
                      parentPid,
                      name,
                      cpu: 0,
                      cpuu: 0,
                      cpus: 0,
                      mem: memw / os$2.totalmem() * 100,
                      priority: parseInt(util$8.getValue(lines, "Priority", ":", true), 10),
                      memVsz: parseInt(util$8.getValue(lines, "PageFileUsage", ":", true), 10),
                      memRss: Math.floor(parseInt(util$8.getValue(lines, "WorkingSetSize", ":", true), 10) / 1024),
                      nice: 0,
                      started: util$8.getValue(lines, "CreationDate", ":", true),
                      state: !statusValue ? _winStatusValues[0] : _winStatusValues[statusValue],
                      tty: "",
                      user: "",
                      command: commandLine || name,
                      path: commandPath,
                      params: ""
                    });
                  }
                });
                result2.sleeping = result2.all - result2.running - result2.blocked - result2.unknown;
                result2.list = procs;
                procStats.forEach((element) => {
                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);
                  let listPos = result2.list.map(function(e) {
                    return e.pid;
                  }).indexOf(resultProcess.pid);
                  if (listPos >= 0) {
                    result2.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                    result2.list[listPos].cpuu = resultProcess.cpuu;
                    result2.list[listPos].cpus = resultProcess.cpus;
                  }
                  list_new[resultProcess.pid] = {
                    cpuu: resultProcess.cpuu,
                    cpus: resultProcess.cpus,
                    utime: resultProcess.utime,
                    stime: resultProcess.stime
                  };
                });
                _processes_cpu.all = allcpuu + allcpus;
                _processes_cpu.all_utime = allcpuu;
                _processes_cpu.all_stime = allcpus;
                _processes_cpu.list = Object.assign({}, list_new);
                _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                _processes_cpu.result = Object.assign({}, result2);
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      } else {
        if (callback) {
          callback(_processes_cpu.result);
        }
        resolve(_processes_cpu.result);
      }
    });
  });
}
processes$1.processes = processes;
function processLoad(proc, callback) {
  if (util$8.isFunction(proc) && !callback) {
    callback = proc;
    proc = "";
  }
  return new Promise((resolve) => {
    process.nextTick(() => {
      proc = proc || "";
      if (typeof proc !== "string") {
        if (callback) {
          callback([]);
        }
        return resolve([]);
      }
      let processesString = "";
      try {
        processesString.__proto__.toLowerCase = util$8.stringToLower;
        processesString.__proto__.replace = util$8.stringReplace;
        processesString.__proto__.toString = util$8.stringToString;
        processesString.__proto__.substr = util$8.stringSubstr;
        processesString.__proto__.substring = util$8.stringSubstring;
        processesString.__proto__.trim = util$8.stringTrim;
        processesString.__proto__.startsWith = util$8.stringStartWith;
      } catch (e) {
        Object.setPrototypeOf(processesString, util$8.stringObj);
      }
      const s = util$8.sanitizeShellString(proc);
      const l = util$8.mathMin(s.length, 2e3);
      for (let i = 0; i <= l; i++) {
        if (s[i] !== void 0) {
          processesString = processesString + s[i];
        }
      }
      processesString = processesString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
      if (processesString === "") {
        processesString = "*";
      }
      if (util$8.isPrototypePolluted() && processesString !== "*") {
        processesString = "------";
      }
      let processes2 = processesString.split("|");
      let result2 = [];
      const procSanitized = util$8.isPrototypePolluted() ? "" : util$8.sanitizeShellString(proc) || "*";
      if (procSanitized && processes2.length && processes2[0] !== "------") {
        if (_windows$7) {
          try {
            util$8.powerShell("Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl").then((stdout, error) => {
              if (!error) {
                let processSections = stdout.split(/\n\s*\n/);
                let procStats = [];
                let list_new = {};
                let allcpuu = 0;
                let allcpus = 0;
                processSections.forEach((element) => {
                  if (element.trim() !== "") {
                    let lines = element.trim().split("\r\n");
                    let pid = parseInt(util$8.getValue(lines, "ProcessId", ":", true), 10);
                    let name = util$8.getValue(lines, "Caption", ":", true);
                    let utime = parseInt(util$8.getValue(lines, "UserModeTime", ":", true), 10);
                    let stime = parseInt(util$8.getValue(lines, "KernelModeTime", ":", true), 10);
                    let mem2 = parseInt(util$8.getValue(lines, "WorkingSetSize", ":", true), 10);
                    allcpuu = allcpuu + utime;
                    allcpus = allcpus + stime;
                    procStats.push({
                      pid,
                      name,
                      utime,
                      stime,
                      cpu: 0,
                      cpuu: 0,
                      cpus: 0,
                      mem: mem2
                    });
                    let pname = "";
                    let inList = false;
                    processes2.forEach(function(proc2) {
                      if (name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                        inList = true;
                        pname = proc2;
                      }
                    });
                    if (processesString === "*" || inList) {
                      let processFound = false;
                      result2.forEach(function(item) {
                        if (item.proc.toLowerCase() === pname.toLowerCase()) {
                          item.pids.push(pid);
                          item.mem += mem2 / os$2.totalmem() * 100;
                          processFound = true;
                        }
                      });
                      if (!processFound) {
                        result2.push({
                          proc: pname,
                          pid,
                          pids: [pid],
                          cpu: 0,
                          mem: mem2 / os$2.totalmem() * 100
                        });
                      }
                    }
                  }
                });
                if (processesString !== "*") {
                  let processesMissing = processes2.filter(function(name) {
                    return procStats.filter(function(item) {
                      return item.name.toLowerCase().indexOf(name) >= 0;
                    }).length === 0;
                  });
                  processesMissing.forEach(function(procName) {
                    result2.push({
                      proc: procName,
                      pid: null,
                      pids: [],
                      cpu: 0,
                      mem: 0
                    });
                  });
                }
                procStats.forEach((element) => {
                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);
                  let listPos = -1;
                  for (let j = 0; j < result2.length; j++) {
                    if (result2[j].pid === resultProcess.pid || result2[j].pids.indexOf(resultProcess.pid) >= 0) {
                      listPos = j;
                    }
                  }
                  if (listPos >= 0) {
                    result2[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                  }
                  list_new[resultProcess.pid] = {
                    cpuu: resultProcess.cpuu,
                    cpus: resultProcess.cpus,
                    utime: resultProcess.utime,
                    stime: resultProcess.stime
                  };
                });
                _process_cpu.all = allcpuu + allcpus;
                _process_cpu.all_utime = allcpuu;
                _process_cpu.all_stime = allcpus;
                _process_cpu.list = Object.assign({}, list_new);
                _process_cpu.ms = Date.now() - _process_cpu.ms;
                _process_cpu.result = JSON.parse(JSON.stringify(result2));
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_darwin$6 || _linux$6 || _freebsd$6 || _openbsd$6 || _netbsd$6) {
          const params = ["-axo", "pid,ppid,pcpu,pmem,comm"];
          util$8.execSafe("ps", params).then((stdout) => {
            if (stdout) {
              let procStats = [];
              let lines = stdout.toString().split("\n").filter(function(line) {
                if (processesString === "*") {
                  return true;
                }
                if (line.toLowerCase().indexOf("grep") !== -1) {
                  return false;
                }
                let found = false;
                processes2.forEach(function(item) {
                  found = found || line.toLowerCase().indexOf(item.toLowerCase()) >= 0;
                });
                return found;
              });
              lines.shift();
              lines.forEach(function(line) {
                let data = line.trim().replace(/ +/g, " ").split(" ");
                if (data.length > 4) {
                  const linuxName = data[4].indexOf("/") >= 0 ? data[4].substring(0, data[4].indexOf("/")) : data[4];
                  const name = _linux$6 ? linuxName : data[4].substring(data[4].lastIndexOf("/") + 1);
                  procStats.push({
                    name,
                    pid: parseInt(data[0]) || 0,
                    ppid: parseInt(data[1]) || 0,
                    cpu: parseFloat(data[2].replace(",", ".")),
                    mem: parseFloat(data[3].replace(",", "."))
                  });
                }
              });
              procStats.forEach(function(item) {
                let listPos = -1;
                let inList = false;
                let name = item.name;
                for (let j = 0; j < result2.length; j++) {
                  if (item.name.toLowerCase().indexOf(result2[j].proc.toLowerCase()) >= 0) {
                    listPos = j;
                  }
                }
                processes2.forEach(function(proc2) {
                  if (item.name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                    inList = true;
                    name = proc2;
                  }
                });
                if (processesString === "*" || inList) {
                  if (listPos < 0) {
                    if (name) {
                      result2.push({
                        proc: name,
                        pid: item.pid,
                        pids: [item.pid],
                        cpu: item.cpu,
                        mem: item.mem
                      });
                    }
                  } else {
                    if (item.ppid < 10) {
                      result2[listPos].pid = item.pid;
                    }
                    result2[listPos].pids.push(item.pid);
                    result2[listPos].cpu += item.cpu;
                    result2[listPos].mem += item.mem;
                  }
                }
              });
              if (processesString !== "*") {
                let processesMissing = processes2.filter(function(name) {
                  return procStats.filter(function(item) {
                    return item.name.toLowerCase().indexOf(name) >= 0;
                  }).length === 0;
                });
                processesMissing.forEach(function(procName) {
                  result2.push({
                    proc: procName,
                    pid: null,
                    pids: [],
                    cpu: 0,
                    mem: 0
                  });
                });
              }
              if (_linux$6) {
                result2.forEach(function(item) {
                  item.cpu = 0;
                });
                let cmd = 'cat /proc/stat | grep "cpu "';
                for (let i in result2) {
                  for (let j in result2[i].pids) {
                    cmd += ";cat /proc/" + result2[i].pids[j] + "/stat";
                  }
                }
                exec$6(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout2) {
                  let curr_processes = stdout2.toString().split("\n");
                  let all = parseProcStat(curr_processes.shift());
                  let list_new = {};
                  let resultProcess = {};
                  curr_processes.forEach((element) => {
                    resultProcess = calcProcStatLinux(element, all, _process_cpu);
                    if (resultProcess.pid) {
                      let resultItemId = -1;
                      for (let i in result2) {
                        if (result2[i].pids.indexOf(resultProcess.pid) >= 0) {
                          resultItemId = i;
                        }
                      }
                      if (resultItemId >= 0) {
                        result2[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;
                      }
                      list_new[resultProcess.pid] = {
                        cpuu: resultProcess.cpuu,
                        cpus: resultProcess.cpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime,
                        cutime: resultProcess.cutime,
                        cstime: resultProcess.cstime
                      };
                    }
                  });
                  result2.forEach(function(item) {
                    item.cpu = Math.round(item.cpu * 100) / 100;
                  });
                  _process_cpu.all = all;
                  _process_cpu.list = Object.assign({}, list_new);
                  _process_cpu.ms = Date.now() - _process_cpu.ms;
                  _process_cpu.result = Object.assign({}, result2);
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        }
      }
    });
  });
}
processes$1.processLoad = processLoad;
var users$1 = {};
const exec$5 = require$$1$1.exec;
const util$7 = util$j;
let _platform$6 = process.platform;
const _linux$5 = _platform$6 === "linux" || _platform$6 === "android";
const _darwin$5 = _platform$6 === "darwin";
const _windows$6 = _platform$6 === "win32";
const _freebsd$5 = _platform$6 === "freebsd";
const _openbsd$5 = _platform$6 === "openbsd";
const _netbsd$5 = _platform$6 === "netbsd";
const _sunos$5 = _platform$6 === "sunos";
function parseUsersLinux(lines, phase) {
  let result2 = [];
  let result_who = [];
  let result_w = {};
  let w_first = true;
  let w_header = [];
  let w_pos = [];
  let who_line = {};
  let is_whopart = true;
  lines.forEach(function(line) {
    if (line === "---") {
      is_whopart = false;
    } else {
      let l = line.replace(/ +/g, " ").split(" ");
      if (is_whopart) {
        result_who.push({
          user: l[0],
          tty: l[1],
          date: l[2],
          time: l[3],
          ip: l && l.length > 4 ? l[4].replace(/\(/g, "").replace(/\)/g, "") : ""
        });
      } else {
        if (w_first) {
          w_header = l;
          w_header.forEach(function(item) {
            w_pos.push(line.indexOf(item));
          });
          w_first = false;
        } else {
          result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();
          result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();
          result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\(/g, "").replace(/\)/g, "").trim();
          result_w.command = line.substring(w_pos[7], 1e3).trim();
          who_line = result_who.filter(function(obj) {
            return obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty;
          });
          if (who_line.length === 1) {
            result2.push({
              user: who_line[0].user,
              tty: who_line[0].tty,
              date: who_line[0].date,
              time: who_line[0].time,
              ip: who_line[0].ip,
              command: result_w.command
            });
          }
        }
      }
    }
  });
  if (result2.length === 0 && phase === 2) {
    return result_who;
  } else {
    return result2;
  }
}
function parseUsersDarwin(lines) {
  let result2 = [];
  let result_who = [];
  let result_w = {};
  let who_line = {};
  let is_whopart = true;
  lines.forEach(function(line) {
    if (line === "---") {
      is_whopart = false;
    } else {
      let l = line.replace(/ +/g, " ").split(" ");
      if (is_whopart) {
        let dt = "" + (/* @__PURE__ */ new Date()).getFullYear() + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2);
        try {
          if (new Date(dt) > /* @__PURE__ */ new Date()) {
            dt = "" + ((/* @__PURE__ */ new Date()).getFullYear() - 1) + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2);
          }
        } catch {
          util$7.noop();
        }
        result_who.push({
          user: l[0],
          tty: l[1],
          date: dt,
          time: l[4]
        });
      } else {
        result_w.user = l[0];
        result_w.tty = l[1];
        result_w.ip = l[2] !== "-" ? l[2] : "";
        result_w.command = l.slice(5, 1e3).join(" ");
        who_line = result_who.filter(function(obj) {
          return obj.user.substring(0, 10) === result_w.user.substring(0, 10) && (obj.tty.substring(3, 1e3) === result_w.tty || obj.tty === result_w.tty);
        });
        if (who_line.length === 1) {
          result2.push({
            user: who_line[0].user,
            tty: who_line[0].tty,
            date: who_line[0].date,
            time: who_line[0].time,
            ip: result_w.ip,
            command: result_w.command
          });
        }
      }
    }
  });
  return result2;
}
function users(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$5) {
        exec$5('export LC_ALL=C; who --ips; echo "---"; w; unset LC_ALL | tail -n +2', function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            result2 = parseUsersLinux(lines, 1);
            if (result2.length === 0) {
              exec$5('who; echo "---"; w | tail -n +2', function(error2, stdout2) {
                if (!error2) {
                  lines = stdout2.toString().split("\n");
                  result2 = parseUsersLinux(lines, 2);
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      }
      if (_freebsd$5 || _openbsd$5 || _netbsd$5) {
        exec$5('who; echo "---"; w -ih', function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            result2 = parseUsersDarwin(lines);
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$5) {
        exec$5('who; echo "---"; w -h', function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            result2 = parseUsersDarwin(lines);
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$5) {
        exec$5('export LC_ALL=C; who; echo "---"; w -ih; unset LC_ALL', function(error, stdout) {
          if (!error) {
            let lines = stdout.toString().split("\n");
            result2 = parseUsersDarwin(lines);
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$6) {
        try {
          let cmd = `Get-CimInstance Win32_LogonSession | select LogonId,@{n="StartTime";e={$_.StartTime.ToString("yyyy-MM-dd HH:mm:ss")}} | fl; echo '#-#-#-#';`;
          cmd += "Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl ; echo '#-#-#-#';";
          cmd += `$process = (Get-CimInstance Win32_Process -Filter "name = 'explorer.exe'"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo '#-#-#-#';`;
          cmd += "query user";
          util$7.powerShell(cmd).then((data) => {
            if (data) {
              data = data.split("#-#-#-#");
              let sessions = parseWinSessions((data[0] || "").split(/\n\s*\n/));
              let loggedons = parseWinLoggedOn((data[1] || "").split(/\n\s*\n/));
              let queryUser = parseWinUsersQuery((data[3] || "").split("\r\n"));
              let users2 = parseWinUsers((data[2] || "").split(/\n\s*\n/), queryUser);
              for (let id in loggedons) {
                if ({}.hasOwnProperty.call(loggedons, id)) {
                  loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : "";
                }
              }
              users2.forEach((user) => {
                let dateTime = "";
                for (let id in loggedons) {
                  if ({}.hasOwnProperty.call(loggedons, id)) {
                    if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {
                      dateTime = loggedons[id].dateTime;
                    }
                  }
                }
                result2.push({
                  user: user.user,
                  tty: user.tty,
                  date: `${dateTime.substring(0, 10)}`,
                  time: `${dateTime.substring(11, 19)}`,
                  ip: "",
                  command: ""
                });
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
function parseWinSessions(sessionParts) {
  const sessions = {};
  sessionParts.forEach((session) => {
    const lines = session.split("\r\n");
    const id = util$7.getValue(lines, "LogonId");
    const starttime = util$7.getValue(lines, "starttime");
    if (id) {
      sessions[id] = starttime;
    }
  });
  return sessions;
}
function fuzzyMatch(name1, name2) {
  name1 = name1.toLowerCase();
  name2 = name2.toLowerCase();
  let eq = 0;
  let len = name1.length;
  if (name2.length > len) {
    len = name2.length;
  }
  for (let i = 0; i < len; i++) {
    const c1 = name1[i] || "";
    const c2 = name2[i] || "";
    if (c1 === c2) {
      eq++;
    }
  }
  return len > 10 ? eq / len > 0.9 : len > 0 ? eq / len > 0.8 : false;
}
function parseWinUsers(userParts, userQuery) {
  const users2 = [];
  userParts.forEach((user) => {
    const lines = user.split("\r\n");
    const domain = util$7.getValue(lines, "domain", ":", true);
    const username = util$7.getValue(lines, "user", ":", true);
    const sessionid = util$7.getValue(lines, "sessionid", ":", true);
    if (username) {
      const quser = userQuery.filter((item) => fuzzyMatch(item.user, username));
      users2.push({
        domain,
        user: username,
        tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid
      });
    }
  });
  return users2;
}
function parseWinLoggedOn(loggedonParts) {
  const loggedons = {};
  loggedonParts.forEach((loggedon) => {
    const lines = loggedon.split("\r\n");
    const antecendent = util$7.getValue(lines, "antecedent", ":", true);
    let parts = antecendent.split("=");
    const name = parts.length > 2 ? parts[1].split(",")[0].replace(/"/g, "").trim() : "";
    const domain = parts.length > 2 ? parts[2].replace(/"/g, "").replace(/\)/g, "").trim() : "";
    const dependent = util$7.getValue(lines, "dependent", ":", true);
    parts = dependent.split("=");
    const id = parts.length > 1 ? parts[1].replace(/"/g, "").replace(/\)/g, "").trim() : "";
    if (id) {
      loggedons[id] = {
        domain,
        user: name
      };
    }
  });
  return loggedons;
}
function parseWinUsersQuery(lines) {
  lines = lines.filter((item) => item);
  let result2 = [];
  const header = lines[0];
  const headerDelimiter = [];
  if (header) {
    const start = header[0] === " " ? 1 : 0;
    headerDelimiter.push(start - 1);
    let nextSpace = 0;
    for (let i = start + 1; i < header.length; i++) {
      if (header[i] === " " && (header[i - 1] === " " || header[i - 1] === ".")) {
        nextSpace = i;
      } else {
        if (nextSpace) {
          headerDelimiter.push(nextSpace);
          nextSpace = 0;
        }
      }
    }
    for (let i = 1; i < lines.length; i++) {
      if (lines[i].trim()) {
        const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || "";
        const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || "";
        result2.push({
          user,
          tty
        });
      }
    }
  }
  return result2;
}
users$1.users = users;
var internet = {};
const util$6 = util$j;
let _platform$5 = process.platform;
const _linux$4 = _platform$5 === "linux" || _platform$5 === "android";
const _darwin$4 = _platform$5 === "darwin";
const _windows$5 = _platform$5 === "win32";
const _freebsd$4 = _platform$5 === "freebsd";
const _openbsd$4 = _platform$5 === "openbsd";
const _netbsd$4 = _platform$5 === "netbsd";
const _sunos$4 = _platform$5 === "sunos";
function inetChecksite(url, callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        url,
        ok: false,
        status: 404,
        ms: null
      };
      if (typeof url !== "string") {
        if (callback) {
          callback(result2);
        }
        return resolve(result2);
      }
      let urlSanitized = "";
      const s = util$6.sanitizeShellString(url, true);
      const l = util$6.mathMin(s.length, 2e3);
      for (let i = 0; i <= l; i++) {
        if (s[i] !== void 0) {
          try {
            s[i].__proto__.toLowerCase = util$6.stringToLower;
          } catch (e) {
            Object.setPrototypeOf(s[i], util$6.stringObj);
          }
          const sl = s[i].toLowerCase();
          if (sl && sl[0] && !sl[1] && sl[0].length === 1) {
            urlSanitized = urlSanitized + sl[0];
          }
        }
      }
      result2.url = urlSanitized;
      try {
        if (urlSanitized && !util$6.isPrototypePolluted()) {
          try {
            urlSanitized.__proto__.startsWith = util$6.stringStartWith;
          } catch (e) {
            Object.setPrototypeOf(urlSanitized, util$6.stringObj);
          }
          if (urlSanitized.startsWith("file:") || urlSanitized.startsWith("gopher:") || urlSanitized.startsWith("telnet:") || urlSanitized.startsWith("mailto:") || urlSanitized.startsWith("news:") || urlSanitized.startsWith("nntp:")) {
            if (callback) {
              callback(result2);
            }
            return resolve(result2);
          }
          util$6.checkWebsite(urlSanitized).then((res) => {
            result2.status = res.statusCode;
            result2.ok = res.statusCode >= 200 && res.statusCode <= 399;
            ;
            result2.ms = result2.ok ? res.time : null;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      } catch (err) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
internet.inetChecksite = inetChecksite;
function inetLatency(host, callback) {
  if (util$6.isFunction(host) && !callback) {
    callback = host;
    host = "";
  }
  host = host || "8.8.8.8";
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (typeof host !== "string") {
        if (callback) {
          callback(null);
        }
        return resolve(null);
      }
      let hostSanitized = "";
      const s = (util$6.isPrototypePolluted() ? "8.8.8.8" : util$6.sanitizeShellString(host, true)).trim();
      const l = util$6.mathMin(s.length, 2e3);
      for (let i = 0; i <= l; i++) {
        if (!(s[i] === void 0)) {
          try {
            s[i].__proto__.toLowerCase = util$6.stringToLower;
          } catch (e) {
            Object.setPrototypeOf(s[i], util$6.stringObj);
          }
          const sl = s[i].toLowerCase();
          if (sl && sl[0] && !sl[1]) {
            hostSanitized = hostSanitized + sl[0];
          }
        }
      }
      try {
        hostSanitized.__proto__.startsWith = util$6.stringStartWith;
      } catch (e) {
        Object.setPrototypeOf(hostSanitized, util$6.stringObj);
      }
      if (hostSanitized.startsWith("file:") || hostSanitized.startsWith("gopher:") || hostSanitized.startsWith("telnet:") || hostSanitized.startsWith("mailto:") || hostSanitized.startsWith("news:") || hostSanitized.startsWith("nntp:")) {
        if (callback) {
          callback(null);
        }
        return resolve(null);
      }
      let params;
      if (_linux$4 || _freebsd$4 || _openbsd$4 || _netbsd$4 || _darwin$4) {
        if (_linux$4) {
          params = ["-c", "2", "-w", "3", hostSanitized];
        }
        if (_freebsd$4 || _openbsd$4 || _netbsd$4) {
          params = ["-c", "2", "-t", "3", hostSanitized];
        }
        if (_darwin$4) {
          params = ["-c2", "-t3", hostSanitized];
        }
        util$6.execSafe("ping", params).then((stdout) => {
          let result2 = null;
          if (stdout) {
            const lines = stdout.split("\n").filter((line2) => line2.indexOf("rtt") >= 0 || line2.indexOf("round-trip") >= 0 || line2.indexOf("avg") >= 0).join("\n");
            const line = lines.split("=");
            if (line.length > 1) {
              const parts = line[1].split("/");
              if (parts.length > 1) {
                result2 = parseFloat(parts[1]);
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$4) {
        const params2 = ["-s", "-a", hostSanitized, "56", "2"];
        const filt = "avg";
        util$6.execSafe("ping", params2, { timeout: 3e3 }).then((stdout) => {
          let result2 = null;
          if (stdout) {
            const lines = stdout.split("\n").filter((line2) => line2.indexOf(filt) >= 0).join("\n");
            const line = lines.split("=");
            if (line.length > 1) {
              const parts = line[1].split("/");
              if (parts.length > 1) {
                result2 = parseFloat(parts[1].replace(",", "."));
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$5) {
        let result2 = null;
        try {
          const params2 = [hostSanitized, "-n", "1"];
          util$6.execSafe("ping", params2, util$6.execOptsWin).then((stdout) => {
            if (stdout) {
              let lines = stdout.split("\r\n");
              lines.shift();
              lines.forEach(function(line) {
                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {
                  let l2 = line.replace(/ +/g, " ").split(" ");
                  if (l2.length > 6) {
                    result2 = parseFloat(l2[l2.length - 1]);
                  }
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch (e) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
internet.inetLatency = inetLatency;
var docker = {};
const net = require$$0$2;
const isWin = os$a.type() === "Windows_NT";
const socketPath = isWin ? "//./pipe/docker_engine" : "/var/run/docker.sock";
let DockerSocket$1 = class DockerSocket {
  getInfo(callback) {
    try {
      let socket = net.createConnection({ path: socketPath });
      let alldata = "";
      let data;
      socket.on("connect", () => {
        socket.write("GET http:/info HTTP/1.0\r\n\r\n");
      });
      socket.on("data", (data2) => {
        alldata = alldata + data2.toString();
      });
      socket.on("error", () => {
        socket = false;
        callback({});
      });
      socket.on("end", () => {
        let startbody = alldata.indexOf("\r\n\r\n");
        alldata = alldata.substring(startbody + 4);
        socket = false;
        try {
          data = JSON.parse(alldata);
          callback(data);
        } catch (err) {
          callback({});
        }
      });
    } catch (err) {
      callback({});
    }
  }
  listImages(all, callback) {
    try {
      let socket = net.createConnection({ path: socketPath });
      let alldata = "";
      let data;
      socket.on("connect", () => {
        socket.write("GET http:/images/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
      });
      socket.on("data", (data2) => {
        alldata = alldata + data2.toString();
      });
      socket.on("error", () => {
        socket = false;
        callback({});
      });
      socket.on("end", () => {
        let startbody = alldata.indexOf("\r\n\r\n");
        alldata = alldata.substring(startbody + 4);
        socket = false;
        try {
          data = JSON.parse(alldata);
          callback(data);
        } catch (err) {
          callback({});
        }
      });
    } catch (err) {
      callback({});
    }
  }
  inspectImage(id, callback) {
    id = id || "";
    if (id) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/images/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }
  listContainers(all, callback) {
    try {
      let socket = net.createConnection({ path: socketPath });
      let alldata = "";
      let data;
      socket.on("connect", () => {
        socket.write("GET http:/containers/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
      });
      socket.on("data", (data2) => {
        alldata = alldata + data2.toString();
      });
      socket.on("error", () => {
        socket = false;
        callback({});
      });
      socket.on("end", () => {
        let startbody = alldata.indexOf("\r\n\r\n");
        alldata = alldata.substring(startbody + 4);
        socket = false;
        try {
          data = JSON.parse(alldata);
          callback(data);
        } catch (err) {
          callback({});
        }
      });
    } catch (err) {
      callback({});
    }
  }
  getStats(id, callback) {
    id = id || "";
    if (id) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/containers/" + id + "/stats?stream=0 HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }
  getInspect(id, callback) {
    id = id || "";
    if (id) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/containers/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }
  getProcesses(id, callback) {
    id = id || "";
    if (id) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/containers/" + id + "/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }
  listVolumes(callback) {
    try {
      let socket = net.createConnection({ path: socketPath });
      let alldata = "";
      let data;
      socket.on("connect", () => {
        socket.write("GET http:/volumes HTTP/1.0\r\n\r\n");
      });
      socket.on("data", (data2) => {
        alldata = alldata + data2.toString();
      });
      socket.on("error", () => {
        socket = false;
        callback({});
      });
      socket.on("end", () => {
        let startbody = alldata.indexOf("\r\n\r\n");
        alldata = alldata.substring(startbody + 4);
        socket = false;
        try {
          data = JSON.parse(alldata);
          callback(data);
        } catch (err) {
          callback({});
        }
      });
    } catch (err) {
      callback({});
    }
  }
};
var dockerSocket = DockerSocket$1;
const util$5 = util$j;
const DockerSocket2 = dockerSocket;
let _platform$4 = process.platform;
const _windows$4 = _platform$4 === "win32";
let _docker_container_stats = {};
let _docker_socket;
let _docker_last_read = 0;
function dockerInfo(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (!_docker_socket) {
        _docker_socket = new DockerSocket2();
      }
      const result2 = {};
      _docker_socket.getInfo((data) => {
        result2.id = data.ID;
        result2.containers = data.Containers;
        result2.containersRunning = data.ContainersRunning;
        result2.containersPaused = data.ContainersPaused;
        result2.containersStopped = data.ContainersStopped;
        result2.images = data.Images;
        result2.driver = data.Driver;
        result2.memoryLimit = data.MemoryLimit;
        result2.swapLimit = data.SwapLimit;
        result2.kernelMemory = data.KernelMemory;
        result2.cpuCfsPeriod = data.CpuCfsPeriod;
        result2.cpuCfsQuota = data.CpuCfsQuota;
        result2.cpuShares = data.CPUShares;
        result2.cpuSet = data.CPUSet;
        result2.ipv4Forwarding = data.IPv4Forwarding;
        result2.bridgeNfIptables = data.BridgeNfIptables;
        result2.bridgeNfIp6tables = data.BridgeNfIp6tables;
        result2.debug = data.Debug;
        result2.nfd = data.NFd;
        result2.oomKillDisable = data.OomKillDisable;
        result2.ngoroutines = data.NGoroutines;
        result2.systemTime = data.SystemTime;
        result2.loggingDriver = data.LoggingDriver;
        result2.cgroupDriver = data.CgroupDriver;
        result2.nEventsListener = data.NEventsListener;
        result2.kernelVersion = data.KernelVersion;
        result2.operatingSystem = data.OperatingSystem;
        result2.osType = data.OSType;
        result2.architecture = data.Architecture;
        result2.ncpu = data.NCPU;
        result2.memTotal = data.MemTotal;
        result2.dockerRootDir = data.DockerRootDir;
        result2.httpProxy = data.HttpProxy;
        result2.httpsProxy = data.HttpsProxy;
        result2.noProxy = data.NoProxy;
        result2.name = data.Name;
        result2.labels = data.Labels;
        result2.experimentalBuild = data.ExperimentalBuild;
        result2.serverVersion = data.ServerVersion;
        result2.clusterStore = data.ClusterStore;
        result2.clusterAdvertise = data.ClusterAdvertise;
        result2.defaultRuntime = data.DefaultRuntime;
        result2.liveRestoreEnabled = data.LiveRestoreEnabled;
        result2.isolation = data.Isolation;
        result2.initBinary = data.InitBinary;
        result2.productLicense = data.ProductLicense;
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      });
    });
  });
}
docker.dockerInfo = dockerInfo;
function dockerImages(all, callback) {
  if (util$5.isFunction(all) && !callback) {
    callback = all;
    all = false;
  }
  if (typeof all === "string" && all === "true") {
    all = true;
  }
  if (typeof all !== "boolean" && all !== void 0) {
    all = false;
  }
  all = all || false;
  let result2 = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (!_docker_socket) {
        _docker_socket = new DockerSocket2();
      }
      const workload = [];
      _docker_socket.listImages(all, (data) => {
        let dockerImages2 = {};
        try {
          dockerImages2 = data;
          if (dockerImages2 && Object.prototype.toString.call(dockerImages2) === "[object Array]" && dockerImages2.length > 0) {
            dockerImages2.forEach(function(element) {
              if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, "");
              }
              workload.push(dockerImagesInspect(element.Id.trim(), element));
            });
            if (workload.length) {
              Promise.all(
                workload
              ).then((data2) => {
                if (callback) {
                  callback(data2);
                }
                resolve(data2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } catch (err) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  });
}
function dockerImagesInspect(imageID, payload) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      imageID = imageID || "";
      if (typeof imageID !== "string") {
        return resolve();
      }
      const imageIDSanitized = (util$5.isPrototypePolluted() ? "" : util$5.sanitizeShellString(imageID, true)).trim();
      if (imageIDSanitized) {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket2();
        }
        _docker_socket.inspectImage(imageIDSanitized.trim(), (data) => {
          try {
            resolve({
              id: payload.Id,
              container: data.Container,
              comment: data.Comment,
              os: data.Os,
              architecture: data.Architecture,
              parent: data.Parent,
              dockerVersion: data.DockerVersion,
              size: data.Size,
              sharedSize: payload.SharedSize,
              virtualSize: data.VirtualSize,
              author: data.Author,
              created: data.Created ? Math.round(new Date(data.Created).getTime() / 1e3) : 0,
              containerConfig: data.ContainerConfig ? data.ContainerConfig : {},
              graphDriver: data.GraphDriver ? data.GraphDriver : {},
              repoDigests: data.RepoDigests ? data.RepoDigests : {},
              repoTags: data.RepoTags ? data.RepoTags : {},
              config: data.Config ? data.Config : {},
              rootFS: data.RootFS ? data.RootFS : {}
            });
          } catch (err) {
            resolve();
          }
        });
      } else {
        resolve();
      }
    });
  });
}
docker.dockerImages = dockerImages;
function dockerContainers(all, callback) {
  function inContainers(containers, id) {
    let filtered = containers.filter((obj) => {
      return obj.Id && obj.Id === id;
    });
    return filtered.length > 0;
  }
  if (util$5.isFunction(all) && !callback) {
    callback = all;
    all = false;
  }
  if (typeof all === "string" && all === "true") {
    all = true;
  }
  if (typeof all !== "boolean" && all !== void 0) {
    all = false;
  }
  all = all || false;
  let result2 = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (!_docker_socket) {
        _docker_socket = new DockerSocket2();
      }
      const workload = [];
      _docker_socket.listContainers(all, (data) => {
        let docker_containers = {};
        try {
          docker_containers = data;
          if (docker_containers && Object.prototype.toString.call(docker_containers) === "[object Array]" && docker_containers.length > 0) {
            for (let key2 in _docker_container_stats) {
              if ({}.hasOwnProperty.call(_docker_container_stats, key2)) {
                if (!inContainers(docker_containers, key2)) {
                  delete _docker_container_stats[key2];
                }
              }
            }
            docker_containers.forEach(function(element) {
              if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, "");
              }
              workload.push(dockerContainerInspect(element.Id.trim(), element));
            });
            if (workload.length) {
              Promise.all(
                workload
              ).then((data2) => {
                if (callback) {
                  callback(data2);
                }
                resolve(data2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } catch (err) {
          for (let key2 in _docker_container_stats) {
            if ({}.hasOwnProperty.call(_docker_container_stats, key2)) {
              if (!inContainers(docker_containers, key2)) {
                delete _docker_container_stats[key2];
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  });
}
function dockerContainerInspect(containerID, payload) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      containerID = containerID || "";
      if (typeof containerID !== "string") {
        return resolve();
      }
      const containerIdSanitized = (util$5.isPrototypePolluted() ? "" : util$5.sanitizeShellString(containerID, true)).trim();
      if (containerIdSanitized) {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket2();
        }
        _docker_socket.getInspect(containerIdSanitized.trim(), (data) => {
          try {
            resolve({
              id: payload.Id,
              name: payload.Name,
              image: payload.Image,
              imageID: payload.ImageID,
              command: payload.Command,
              created: payload.Created,
              started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1e3) : 0,
              finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? Math.round(new Date(data.State.FinishedAt).getTime() / 1e3) : 0,
              createdAt: data.Created ? data.Created : "",
              startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : "",
              finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? data.State.FinishedAt : "",
              state: payload.State,
              restartCount: data.RestartCount || 0,
              platform: data.Platform || "",
              driver: data.Driver || "",
              ports: payload.Ports,
              mounts: payload.Mounts
              // hostconfig: payload.HostConfig,
              // network: payload.NetworkSettings
            });
          } catch (err) {
            resolve();
          }
        });
      } else {
        resolve();
      }
    });
  });
}
docker.dockerContainers = dockerContainers;
function docker_calcCPUPercent(cpu_stats, precpu_stats) {
  if (!_windows$4) {
    let cpuPercent = 0;
    let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
    let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;
    if (systemDelta > 0 && cpuDelta > 0) {
      if (precpu_stats.online_cpus) {
        cpuPercent = cpuDelta / systemDelta * precpu_stats.online_cpus * 100;
      } else {
        cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100;
      }
    }
    return cpuPercent;
  } else {
    let nanoSecNow = util$5.nanoSeconds();
    let cpuPercent = 0;
    if (_docker_last_read > 0) {
      let possIntervals = nanoSecNow - _docker_last_read;
      let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
      if (possIntervals > 0) {
        cpuPercent = 100 * intervalsUsed / possIntervals;
      }
    }
    _docker_last_read = nanoSecNow;
    return cpuPercent;
  }
}
function docker_calcNetworkIO(networks) {
  let rx;
  let wx;
  for (let key2 in networks) {
    if (!{}.hasOwnProperty.call(networks, key2)) {
      continue;
    }
    let obj = networks[key2];
    rx = +obj.rx_bytes;
    wx = +obj.tx_bytes;
  }
  return {
    rx,
    wx
  };
}
function docker_calcBlockIO(blkio_stats) {
  let result2 = {
    r: 0,
    w: 0
  };
  if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === "[object Array]" && blkio_stats.io_service_bytes_recursive.length > 0) {
    blkio_stats.io_service_bytes_recursive.forEach(function(element) {
      if (element.op && element.op.toLowerCase() === "read" && element.value) {
        result2.r += element.value;
      }
      if (element.op && element.op.toLowerCase() === "write" && element.value) {
        result2.w += element.value;
      }
    });
  }
  return result2;
}
function dockerContainerStats(containerIDs, callback) {
  let containerArray = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (util$5.isFunction(containerIDs) && !callback) {
        callback = containerIDs;
        containerArray = ["*"];
      } else {
        containerIDs = containerIDs || "*";
        if (typeof containerIDs !== "string") {
          if (callback) {
            callback([]);
          }
          return resolve([]);
        }
        let containerIDsSanitized = "";
        try {
          containerIDsSanitized.__proto__.toLowerCase = util$5.stringToLower;
          containerIDsSanitized.__proto__.replace = util$5.stringReplace;
          containerIDsSanitized.__proto__.toString = util$5.stringToString;
          containerIDsSanitized.__proto__.substr = util$5.stringSubstr;
          containerIDsSanitized.__proto__.substring = util$5.stringSubstring;
          containerIDsSanitized.__proto__.trim = util$5.stringTrim;
          containerIDsSanitized.__proto__.startsWith = util$5.stringStartWith;
        } catch (e) {
          Object.setPrototypeOf(containerIDsSanitized, util$5.stringObj);
        }
        containerIDsSanitized = containerIDs;
        containerIDsSanitized = containerIDsSanitized.trim();
        if (containerIDsSanitized !== "*") {
          containerIDsSanitized = "";
          const s = (util$5.isPrototypePolluted() ? "" : util$5.sanitizeShellString(containerIDs, true)).trim();
          const l = util$5.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              s[i].__proto__.toLowerCase = util$5.stringToLower;
              const sl = s[i].toLowerCase();
              if (sl && sl[0] && !sl[1]) {
                containerIDsSanitized = containerIDsSanitized + sl[0];
              }
            }
          }
        }
        containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, "|");
        containerArray = containerIDsSanitized.split("|");
      }
      const result2 = [];
      const workload = [];
      if (containerArray.length && containerArray[0].trim() === "*") {
        containerArray = [];
        dockerContainers().then((allContainers) => {
          for (let container of allContainers) {
            containerArray.push(container.id.substring(0, 12));
          }
          if (containerArray.length) {
            dockerContainerStats(containerArray.join(",")).then((result3) => {
              if (callback) {
                callback(result3);
              }
              resolve(result3);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      } else {
        for (let containerID of containerArray) {
          workload.push(dockerContainerStatsSingle(containerID.trim()));
        }
        if (workload.length) {
          Promise.all(
            workload
          ).then((data) => {
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
}
function dockerContainerStatsSingle(containerID) {
  containerID = containerID || "";
  let result2 = {
    id: containerID,
    memUsage: 0,
    memLimit: 0,
    memPercent: 0,
    cpuPercent: 0,
    pids: 0,
    netIO: {
      rx: 0,
      wx: 0
    },
    blockIO: {
      r: 0,
      w: 0
    },
    restartCount: 0,
    cpuStats: {},
    precpuStats: {},
    memoryStats: {},
    networks: {}
  };
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (containerID) {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket2();
        }
        _docker_socket.getInspect(containerID, (dataInspect) => {
          try {
            _docker_socket.getStats(containerID, (data) => {
              try {
                let stats = data;
                if (!stats.message) {
                  if (data.id) {
                    result2.id = data.id;
                  }
                  result2.memUsage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;
                  result2.memLimit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;
                  result2.memPercent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100 : 0;
                  result2.cpuPercent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;
                  result2.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;
                  result2.restartCount = dataInspect.RestartCount ? dataInspect.RestartCount : 0;
                  if (stats.networks) {
                    result2.netIO = docker_calcNetworkIO(stats.networks);
                  }
                  if (stats.blkio_stats) {
                    result2.blockIO = docker_calcBlockIO(stats.blkio_stats);
                  }
                  result2.cpuStats = stats.cpu_stats ? stats.cpu_stats : {};
                  result2.precpuStats = stats.precpu_stats ? stats.precpu_stats : {};
                  result2.memoryStats = stats.memory_stats ? stats.memory_stats : {};
                  result2.networks = stats.networks ? stats.networks : {};
                }
              } catch (err) {
                util$5.noop();
              }
              resolve(result2);
            });
          } catch (err) {
            util$5.noop();
          }
        });
      } else {
        resolve(result2);
      }
    });
  });
}
docker.dockerContainerStats = dockerContainerStats;
function dockerContainerProcesses(containerID, callback) {
  let result2 = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      containerID = containerID || "";
      if (typeof containerID !== "string") {
        return resolve(result2);
      }
      const containerIdSanitized = (util$5.isPrototypePolluted() ? "" : util$5.sanitizeShellString(containerID, true)).trim();
      if (containerIdSanitized) {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket2();
        }
        _docker_socket.getProcesses(containerIdSanitized, (data) => {
          try {
            if (data && data.Titles && data.Processes) {
              let titles = data.Titles.map(function(value) {
                return value.toUpperCase();
              });
              let pos_pid = titles.indexOf("PID");
              let pos_ppid = titles.indexOf("PPID");
              let pos_pgid = titles.indexOf("PGID");
              let pos_vsz = titles.indexOf("VSZ");
              let pos_time = titles.indexOf("TIME");
              let pos_elapsed = titles.indexOf("ELAPSED");
              let pos_ni = titles.indexOf("NI");
              let pos_ruser = titles.indexOf("RUSER");
              let pos_user = titles.indexOf("USER");
              let pos_rgroup = titles.indexOf("RGROUP");
              let pos_group = titles.indexOf("GROUP");
              let pos_stat = titles.indexOf("STAT");
              let pos_rss = titles.indexOf("RSS");
              let pos_command = titles.indexOf("COMMAND");
              data.Processes.forEach((process2) => {
                result2.push({
                  pidHost: pos_pid >= 0 ? process2[pos_pid] : "",
                  ppid: pos_ppid >= 0 ? process2[pos_ppid] : "",
                  pgid: pos_pgid >= 0 ? process2[pos_pgid] : "",
                  user: pos_user >= 0 ? process2[pos_user] : "",
                  ruser: pos_ruser >= 0 ? process2[pos_ruser] : "",
                  group: pos_group >= 0 ? process2[pos_group] : "",
                  rgroup: pos_rgroup >= 0 ? process2[pos_rgroup] : "",
                  stat: pos_stat >= 0 ? process2[pos_stat] : "",
                  time: pos_time >= 0 ? process2[pos_time] : "",
                  elapsed: pos_elapsed >= 0 ? process2[pos_elapsed] : "",
                  nice: pos_ni >= 0 ? process2[pos_ni] : "",
                  rss: pos_rss >= 0 ? process2[pos_rss] : "",
                  vsz: pos_vsz >= 0 ? process2[pos_vsz] : "",
                  command: pos_command >= 0 ? process2[pos_command] : ""
                });
              });
            }
          } catch (err) {
            util$5.noop();
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } else {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
docker.dockerContainerProcesses = dockerContainerProcesses;
function dockerVolumes(callback) {
  let result2 = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      if (!_docker_socket) {
        _docker_socket = new DockerSocket2();
      }
      _docker_socket.listVolumes((data) => {
        let dockerVolumes2 = {};
        try {
          dockerVolumes2 = data;
          if (dockerVolumes2 && dockerVolumes2.Volumes && Object.prototype.toString.call(dockerVolumes2.Volumes) === "[object Array]" && dockerVolumes2.Volumes.length > 0) {
            dockerVolumes2.Volumes.forEach(function(element) {
              result2.push({
                name: element.Name,
                driver: element.Driver,
                labels: element.Labels,
                mountpoint: element.Mountpoint,
                options: element.Options,
                scope: element.Scope,
                created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1e3) : 0
              });
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } catch (err) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  });
}
docker.dockerVolumes = dockerVolumes;
function dockerAll(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      dockerContainers(true).then((result2) => {
        if (result2 && Object.prototype.toString.call(result2) === "[object Array]" && result2.length > 0) {
          let l = result2.length;
          result2.forEach(function(element) {
            dockerContainerStats(element.id).then((res) => {
              element.memUsage = res[0].memUsage;
              element.memLimit = res[0].memLimit;
              element.memPercent = res[0].memPercent;
              element.cpuPercent = res[0].cpuPercent;
              element.pids = res[0].pids;
              element.netIO = res[0].netIO;
              element.blockIO = res[0].blockIO;
              element.cpuStats = res[0].cpuStats;
              element.precpuStats = res[0].precpuStats;
              element.memoryStats = res[0].memoryStats;
              element.networks = res[0].networks;
              dockerContainerProcesses(element.id).then((processes2) => {
                element.processes = processes2;
                l -= 1;
                if (l === 0) {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              });
            });
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  });
}
docker.dockerAll = dockerAll;
var virtualbox = {};
const os$1 = os$a;
const exec$4 = require$$1$1.exec;
const util$4 = util$j;
function vboxInfo(callback) {
  let result2 = [];
  return new Promise((resolve) => {
    process.nextTick(() => {
      try {
        exec$4(util$4.getVboxmanage() + " list vms --long", function(error, stdout) {
          let parts = (os$1.EOL + stdout.toString()).split(os$1.EOL + "Name:");
          parts.shift();
          parts.forEach((part) => {
            const lines = ("Name:" + part).split(os$1.EOL);
            const state = util$4.getValue(lines, "State");
            const running = state.startsWith("running");
            const runningSinceString = running ? state.replace("running (since ", "").replace(")", "").trim() : "";
            let runningSince = 0;
            try {
              if (running) {
                const sinceDateObj = new Date(runningSinceString);
                const offset = sinceDateObj.getTimezoneOffset();
                runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
              }
            } catch (e) {
              util$4.noop();
            }
            const stoppedSinceString = !running ? state.replace("powered off (since", "").replace(")", "").trim() : "";
            let stoppedSince = 0;
            try {
              if (!running) {
                const sinceDateObj = new Date(stoppedSinceString);
                const offset = sinceDateObj.getTimezoneOffset();
                stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
              }
            } catch (e) {
              util$4.noop();
            }
            result2.push({
              id: util$4.getValue(lines, "UUID"),
              name: util$4.getValue(lines, "Name"),
              running,
              started: runningSinceString,
              runningSince,
              stopped: stoppedSinceString,
              stoppedSince,
              guestOS: util$4.getValue(lines, "Guest OS"),
              hardwareUUID: util$4.getValue(lines, "Hardware UUID"),
              memory: parseInt(util$4.getValue(lines, "Memory size", "     "), 10),
              vram: parseInt(util$4.getValue(lines, "VRAM size"), 10),
              cpus: parseInt(util$4.getValue(lines, "Number of CPUs"), 10),
              cpuExepCap: util$4.getValue(lines, "CPU exec cap"),
              cpuProfile: util$4.getValue(lines, "CPUProfile"),
              chipset: util$4.getValue(lines, "Chipset"),
              firmware: util$4.getValue(lines, "Firmware"),
              pageFusion: util$4.getValue(lines, "Page Fusion") === "enabled",
              configFile: util$4.getValue(lines, "Config file"),
              snapshotFolder: util$4.getValue(lines, "Snapshot folder"),
              logFolder: util$4.getValue(lines, "Log folder"),
              hpet: util$4.getValue(lines, "HPET") === "enabled",
              pae: util$4.getValue(lines, "PAE") === "enabled",
              longMode: util$4.getValue(lines, "Long Mode") === "enabled",
              tripleFaultReset: util$4.getValue(lines, "Triple Fault Reset") === "enabled",
              apic: util$4.getValue(lines, "APIC") === "enabled",
              x2Apic: util$4.getValue(lines, "X2APIC") === "enabled",
              acpi: util$4.getValue(lines, "ACPI") === "enabled",
              ioApic: util$4.getValue(lines, "IOAPIC") === "enabled",
              biosApicMode: util$4.getValue(lines, "BIOS APIC mode"),
              bootMenuMode: util$4.getValue(lines, "Boot menu mode"),
              bootDevice1: util$4.getValue(lines, "Boot Device 1"),
              bootDevice2: util$4.getValue(lines, "Boot Device 2"),
              bootDevice3: util$4.getValue(lines, "Boot Device 3"),
              bootDevice4: util$4.getValue(lines, "Boot Device 4"),
              timeOffset: util$4.getValue(lines, "Time offset"),
              rtc: util$4.getValue(lines, "RTC")
            });
          });
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      } catch (e) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
    });
  });
}
virtualbox.vboxInfo = vboxInfo;
var printer$1 = {};
const exec$3 = require$$1$1.exec;
const util$3 = util$j;
let _platform$3 = process.platform;
const _linux$3 = _platform$3 === "linux" || _platform$3 === "android";
const _darwin$3 = _platform$3 === "darwin";
const _windows$3 = _platform$3 === "win32";
const _freebsd$3 = _platform$3 === "freebsd";
const _openbsd$3 = _platform$3 === "openbsd";
const _netbsd$3 = _platform$3 === "netbsd";
const _sunos$3 = _platform$3 === "sunos";
const winPrinterStatus = {
  1: "Other",
  2: "Unknown",
  3: "Idle",
  4: "Printing",
  5: "Warmup",
  6: "Stopped Printing",
  7: "Offline"
};
function parseLinuxCupsHeader(lines) {
  const result2 = {};
  if (lines && lines.length) {
    if (lines[0].indexOf(" CUPS v") > 0) {
      const parts = lines[0].split(" CUPS v");
      result2.cupsVersion = parts[1];
    }
  }
  return result2;
}
function parseLinuxCupsPrinter(lines) {
  const result2 = {};
  const printerId = util$3.getValue(lines, "PrinterId", " ");
  result2.id = printerId ? parseInt(printerId, 10) : null;
  result2.name = util$3.getValue(lines, "Info", " ");
  result2.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
  result2.uri = util$3.getValue(lines, "DeviceURI", " ");
  result2.uuid = util$3.getValue(lines, "UUID", " ");
  result2.status = util$3.getValue(lines, "State", " ");
  result2.local = util$3.getValue(lines, "Location", " ").toLowerCase().startsWith("local");
  result2.default = null;
  result2.shared = util$3.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
  return result2;
}
function parseLinuxLpstatPrinter(lines, id) {
  const result2 = {};
  result2.id = id;
  result2.name = util$3.getValue(lines, "Description", ":", true);
  result2.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
  result2.uri = null;
  result2.uuid = null;
  result2.status = lines.length > 0 && lines[0] ? lines[0].indexOf(" idle") > 0 ? "idle" : lines[0].indexOf(" printing") > 0 ? "printing" : "unknown" : null;
  result2.local = util$3.getValue(lines, "Location", ":", true).toLowerCase().startsWith("local");
  result2.default = null;
  result2.shared = util$3.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
  return result2;
}
function parseDarwinPrinters(printerObject, id) {
  const result2 = {};
  const uriParts = printerObject.uri.split("/");
  result2.id = id;
  result2.name = printerObject._name;
  result2.model = uriParts.length ? uriParts[uriParts.length - 1] : "";
  result2.uri = printerObject.uri;
  result2.uuid = null;
  result2.status = printerObject.status;
  result2.local = printerObject.printserver === "local";
  result2.default = printerObject.default === "yes";
  result2.shared = printerObject.shared === "yes";
  return result2;
}
function parseWindowsPrinters(lines, id) {
  const result2 = {};
  const status = parseInt(util$3.getValue(lines, "PrinterStatus", ":"), 10);
  result2.id = id;
  result2.name = util$3.getValue(lines, "name", ":");
  result2.model = util$3.getValue(lines, "DriverName", ":");
  result2.uri = null;
  result2.uuid = null;
  result2.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;
  result2.local = util$3.getValue(lines, "Local", ":").toUpperCase() === "TRUE";
  result2.default = util$3.getValue(lines, "Default", ":").toUpperCase() === "TRUE";
  result2.shared = util$3.getValue(lines, "Shared", ":").toUpperCase() === "TRUE";
  return result2;
}
function printer(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$3 || _freebsd$3 || _openbsd$3 || _netbsd$3) {
        let cmd = "cat /etc/cups/printers.conf 2>/dev/null";
        exec$3(cmd, function(error, stdout) {
          if (!error) {
            const parts = stdout.toString().split("<Printer ");
            const printerHeader = parseLinuxCupsHeader(parts[0]);
            for (let i = 1; i < parts.length; i++) {
              const printers = parseLinuxCupsPrinter(parts[i].split("\n"));
              if (printers.name) {
                printers.engine = "CUPS";
                printers.engineVersion = printerHeader.cupsVersion;
                result2.push(printers);
              }
            }
          }
          if (result2.length === 0) {
            if (_linux$3) {
              cmd = "export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL";
              exec$3(cmd, function(error2, stdout2) {
                const parts = ("\n" + stdout2.toString()).split("\nprinter ");
                for (let i = 1; i < parts.length; i++) {
                  const printers = parseLinuxLpstatPrinter(parts[i].split("\n"), i);
                  result2.push(printers);
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      }
      if (_darwin$3) {
        let cmd = "system_profiler SPPrintersDataType -json";
        exec$3(cmd, function(error, stdout) {
          if (!error) {
            try {
              const outObj = JSON.parse(stdout.toString());
              if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {
                for (let i = 0; i < outObj.SPPrintersDataType.length; i++) {
                  const printer2 = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);
                  result2.push(printer2);
                }
              }
            } catch (e) {
              util$3.noop();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$3) {
        util$3.powerShell("Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl").then((stdout, error) => {
          if (!error) {
            const parts = stdout.toString().split(/\n\s*\n/);
            for (let i = 0; i < parts.length; i++) {
              const printer2 = parseWindowsPrinters(parts[i].split("\n"), i);
              if (printer2.name || printer2.model) {
                result2.push(printer2);
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$3) {
        resolve(null);
      }
    });
  });
}
printer$1.printer = printer;
var usb$1 = {};
const exec$2 = require$$1$1.exec;
const util$2 = util$j;
let _platform$2 = process.platform;
const _linux$2 = _platform$2 === "linux" || _platform$2 === "android";
const _darwin$2 = _platform$2 === "darwin";
const _windows$2 = _platform$2 === "win32";
const _freebsd$2 = _platform$2 === "freebsd";
const _openbsd$2 = _platform$2 === "openbsd";
const _netbsd$2 = _platform$2 === "netbsd";
const _sunos$2 = _platform$2 === "sunos";
function getLinuxUsbType(type, name) {
  let result2 = type;
  const str = (name + " " + type).toLowerCase();
  if (str.indexOf("camera") >= 0) {
    result2 = "Camera";
  } else if (str.indexOf("hub") >= 0) {
    result2 = "Hub";
  } else if (str.indexOf("keybrd") >= 0) {
    result2 = "Keyboard";
  } else if (str.indexOf("keyboard") >= 0) {
    result2 = "Keyboard";
  } else if (str.indexOf("mouse") >= 0) {
    result2 = "Mouse";
  } else if (str.indexOf("stora") >= 0) {
    result2 = "Storage";
  } else if (str.indexOf("microp") >= 0) {
    result2 = "Microphone";
  } else if (str.indexOf("headset") >= 0) {
    result2 = "Audio";
  } else if (str.indexOf("audio") >= 0) {
    result2 = "Audio";
  }
  return result2;
}
function parseLinuxUsb(usb2) {
  const result2 = {};
  const lines = usb2.split("\n");
  if (lines && lines.length && lines[0].indexOf("Device") >= 0) {
    const parts = lines[0].split(" ");
    result2.bus = parseInt(parts[0], 10);
    if (parts[2]) {
      result2.deviceId = parseInt(parts[2], 10);
    } else {
      result2.deviceId = null;
    }
  } else {
    result2.bus = null;
    result2.deviceId = null;
  }
  const idVendor = util$2.getValue(lines, "idVendor", " ", true).trim();
  let vendorParts = idVendor.split(" ");
  vendorParts.shift();
  const vendor = vendorParts.join(" ");
  const idProduct = util$2.getValue(lines, "idProduct", " ", true).trim();
  let productParts = idProduct.split(" ");
  productParts.shift();
  const product = productParts.join(" ");
  const interfaceClass = util$2.getValue(lines, "bInterfaceClass", " ", true).trim();
  let interfaceClassParts = interfaceClass.split(" ");
  interfaceClassParts.shift();
  const usbType = interfaceClassParts.join(" ");
  const iManufacturer = util$2.getValue(lines, "iManufacturer", " ", true).trim();
  let iManufacturerParts = iManufacturer.split(" ");
  iManufacturerParts.shift();
  const manufacturer = iManufacturerParts.join(" ");
  const iSerial = util$2.getValue(lines, "iSerial", " ", true).trim();
  let iSerialParts = iSerial.split(" ");
  iSerialParts.shift();
  const serial = iSerialParts.join(" ");
  result2.id = (idVendor.startsWith("0x") ? idVendor.split(" ")[0].substr(2, 10) : "") + ":" + (idProduct.startsWith("0x") ? idProduct.split(" ")[0].substr(2, 10) : "");
  result2.name = product;
  result2.type = getLinuxUsbType(usbType, product);
  result2.removable = null;
  result2.vendor = vendor;
  result2.manufacturer = manufacturer;
  result2.maxPower = util$2.getValue(lines, "MaxPower", " ", true);
  result2.serialNumber = serial;
  return result2;
}
function getDarwinUsbType(name) {
  let result2 = "";
  if (name.indexOf("camera") >= 0) {
    result2 = "Camera";
  } else if (name.indexOf("touch bar") >= 0) {
    result2 = "Touch Bar";
  } else if (name.indexOf("controller") >= 0) {
    result2 = "Controller";
  } else if (name.indexOf("headset") >= 0) {
    result2 = "Audio";
  } else if (name.indexOf("keyboard") >= 0) {
    result2 = "Keyboard";
  } else if (name.indexOf("trackpad") >= 0) {
    result2 = "Trackpad";
  } else if (name.indexOf("sensor") >= 0) {
    result2 = "Sensor";
  } else if (name.indexOf("bthusb") >= 0) {
    result2 = "Bluetooth";
  } else if (name.indexOf("bth") >= 0) {
    result2 = "Bluetooth";
  } else if (name.indexOf("rfcomm") >= 0) {
    result2 = "Bluetooth";
  } else if (name.indexOf("usbhub") >= 0) {
    result2 = "Hub";
  } else if (name.indexOf(" hub") >= 0) {
    result2 = "Hub";
  } else if (name.indexOf("mouse") >= 0) {
    result2 = "Mouse";
  } else if (name.indexOf("microp") >= 0) {
    result2 = "Microphone";
  } else if (name.indexOf("removable") >= 0) {
    result2 = "Storage";
  }
  return result2;
}
function parseDarwinUsb(usb2, id) {
  const result2 = {};
  result2.id = id;
  usb2 = usb2.replace(/ \|/g, "");
  usb2 = usb2.trim();
  let lines = usb2.split("\n");
  lines.shift();
  try {
    for (let i = 0; i < lines.length; i++) {
      lines[i] = lines[i].trim();
      lines[i] = lines[i].replace(/=/g, ":");
      if (lines[i] !== "{" && lines[i] !== "}" && lines[i + 1] && lines[i + 1].trim() !== "}") {
        lines[i] = lines[i] + ",";
      }
      lines[i] = lines[i].replace(":Yes,", ':"Yes",');
      lines[i] = lines[i].replace(": Yes,", ': "Yes",');
      lines[i] = lines[i].replace(": Yes", ': "Yes"');
      lines[i] = lines[i].replace(":No,", ':"No",');
      lines[i] = lines[i].replace(": No,", ': "No",');
      lines[i] = lines[i].replace(": No", ': "No"');
      lines[i] = lines[i].replace("((", "").replace("))", "");
      const match = /<(\w+)>/.exec(lines[i]);
      if (match) {
        const number = match[0];
        lines[i] = lines[i].replace(number, `"${number}"`);
      }
    }
    const usbObj = JSON.parse(lines.join("\n"));
    const removableDrive = (usbObj["Built-In"] ? usbObj["Built-In"].toLowerCase() !== "yes" : true) && (usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() === "no" : true);
    result2.bus = null;
    result2.deviceId = null;
    result2.id = usbObj["USB Address"] || null;
    result2.name = usbObj["kUSBProductString"] || usbObj["USB Product Name"] || null;
    result2.type = getDarwinUsbType((usbObj["kUSBProductString"] || usbObj["USB Product Name"] || "").toLowerCase() + (removableDrive ? " removable" : ""));
    result2.removable = usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() || false : true;
    result2.vendor = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
    result2.manufacturer = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
    result2.maxPower = null;
    result2.serialNumber = usbObj["kUSBSerialNumberString"] || null;
    if (result2.name) {
      return result2;
    } else {
      return null;
    }
  } catch (e) {
    return null;
  }
}
function getWindowsUsbTypeCreation(creationclass, name) {
  let result2 = "";
  if (name.indexOf("storage") >= 0) {
    result2 = "Storage";
  } else if (name.indexOf("speicher") >= 0) {
    result2 = "Storage";
  } else if (creationclass.indexOf("usbhub") >= 0) {
    result2 = "Hub";
  } else if (creationclass.indexOf("storage") >= 0) {
    result2 = "Storage";
  } else if (creationclass.indexOf("usbcontroller") >= 0) {
    result2 = "Controller";
  } else if (creationclass.indexOf("keyboard") >= 0) {
    result2 = "Keyboard";
  } else if (creationclass.indexOf("pointing") >= 0) {
    result2 = "Mouse";
  } else if (creationclass.indexOf("microp") >= 0) {
    result2 = "Microphone";
  } else if (creationclass.indexOf("disk") >= 0) {
    result2 = "Storage";
  }
  return result2;
}
function parseWindowsUsb(lines, id) {
  const usbType = getWindowsUsbTypeCreation(util$2.getValue(lines, "CreationClassName", ":").toLowerCase(), util$2.getValue(lines, "name", ":").toLowerCase());
  if (usbType) {
    const result2 = {};
    result2.bus = null;
    result2.deviceId = util$2.getValue(lines, "deviceid", ":");
    result2.id = id;
    result2.name = util$2.getValue(lines, "name", ":");
    result2.type = usbType;
    result2.removable = null;
    result2.vendor = null;
    result2.manufacturer = util$2.getValue(lines, "Manufacturer", ":");
    result2.maxPower = null;
    result2.serialNumber = null;
    return result2;
  } else {
    return null;
  }
}
function usb(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$2) {
        const cmd = "export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL";
        exec$2(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error, stdout) {
          if (!error) {
            const parts = ("\n\n" + stdout.toString()).split("\n\nBus ");
            for (let i = 1; i < parts.length; i++) {
              const usb2 = parseLinuxUsb(parts[i]);
              result2.push(usb2);
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$2) {
        let cmd = "ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l";
        exec$2(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error, stdout) {
          if (!error) {
            const parts = stdout.toString().split(" +-o ");
            for (let i = 1; i < parts.length; i++) {
              const usb2 = parseDarwinUsb(parts[i]);
              if (usb2) {
                result2.push(usb2);
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$2) {
        util$2.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match "USB"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {
          if (!error) {
            const parts = stdout.toString().split(/\n\s*\n/);
            for (let i = 0; i < parts.length; i++) {
              const usb2 = parseWindowsUsb(parts[i].split("\n"), i);
              if (usb2 && result2.filter((x) => x.deviceId === usb2.deviceId).length === 0) {
                result2.push(usb2);
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$2 || _freebsd$2 || _openbsd$2 || _netbsd$2) {
        resolve(null);
      }
    });
  });
}
usb$1.usb = usb;
var audio$1 = {};
const exec$1 = require$$1$1.exec;
const execSync$1 = require$$1$1.execSync;
const util$1 = util$j;
let _platform$1 = process.platform;
const _linux$1 = _platform$1 === "linux" || _platform$1 === "android";
const _darwin$1 = _platform$1 === "darwin";
const _windows$1 = _platform$1 === "win32";
const _freebsd$1 = _platform$1 === "freebsd";
const _openbsd$1 = _platform$1 === "openbsd";
const _netbsd$1 = _platform$1 === "netbsd";
const _sunos$1 = _platform$1 === "sunos";
function parseAudioType(str, input, output) {
  str = str.toLowerCase();
  let result2 = "";
  if (str.indexOf("input") >= 0) {
    result2 = "Microphone";
  }
  if (str.indexOf("display audio") >= 0) {
    result2 = "Speaker";
  }
  if (str.indexOf("speak") >= 0) {
    result2 = "Speaker";
  }
  if (str.indexOf("laut") >= 0) {
    result2 = "Speaker";
  }
  if (str.indexOf("loud") >= 0) {
    result2 = "Speaker";
  }
  if (str.indexOf("head") >= 0) {
    result2 = "Headset";
  }
  if (str.indexOf("mic") >= 0) {
    result2 = "Microphone";
  }
  if (str.indexOf("mikr") >= 0) {
    result2 = "Microphone";
  }
  if (str.indexOf("phone") >= 0) {
    result2 = "Phone";
  }
  if (str.indexOf("controll") >= 0) {
    result2 = "Controller";
  }
  if (str.indexOf("line o") >= 0) {
    result2 = "Line Out";
  }
  if (str.indexOf("digital o") >= 0) {
    result2 = "Digital Out";
  }
  if (str.indexOf("smart sound technology") >= 0) {
    result2 = "Digital Signal Processor";
  }
  if (str.indexOf("high definition audio") >= 0) {
    result2 = "Sound Driver";
  }
  if (!result2 && output) {
    result2 = "Speaker";
  } else if (!result2 && input) {
    result2 = "Microphone";
  }
  return result2;
}
function getLinuxAudioPci() {
  let cmd = "lspci -v 2>/dev/null";
  let result2 = [];
  try {
    const parts = execSync$1(cmd, util$1.execOptsLinux).toString().split("\n\n");
    parts.forEach((element) => {
      const lines = element.split("\n");
      if (lines && lines.length && lines[0].toLowerCase().indexOf("audio") >= 0) {
        const audio2 = {};
        audio2.slotId = lines[0].split(" ")[0];
        audio2.driver = util$1.getValue(lines, "Kernel driver in use", ":", true) || util$1.getValue(lines, "Kernel modules", ":", true);
        result2.push(audio2);
      }
    });
    return result2;
  } catch (e) {
    return result2;
  }
}
function parseLinuxAudioPciMM(lines, audioPCI) {
  const result2 = {};
  const slotId = util$1.getValue(lines, "Slot");
  const pciMatch = audioPCI.filter(function(item) {
    return item.slotId === slotId;
  });
  result2.id = slotId;
  result2.name = util$1.getValue(lines, "SDevice");
  result2.manufacturer = util$1.getValue(lines, "SVendor");
  result2.revision = util$1.getValue(lines, "Rev");
  result2.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : "";
  result2.default = null;
  result2.channel = "PCIe";
  result2.type = parseAudioType(result2.name, null, null);
  result2.in = null;
  result2.out = null;
  result2.status = "online";
  return result2;
}
function parseDarwinChannel(str) {
  let result2 = "";
  if (str.indexOf("builtin") >= 0) {
    result2 = "Built-In";
  }
  if (str.indexOf("extern") >= 0) {
    result2 = "Audio-Jack";
  }
  if (str.indexOf("hdmi") >= 0) {
    result2 = "HDMI";
  }
  if (str.indexOf("displayport") >= 0) {
    result2 = "Display-Port";
  }
  if (str.indexOf("usb") >= 0) {
    result2 = "USB";
  }
  if (str.indexOf("pci") >= 0) {
    result2 = "PCIe";
  }
  return result2;
}
function parseDarwinAudio(audioObject, id) {
  const result2 = {};
  const channelStr = ((audioObject.coreaudio_device_transport || "") + " " + (audioObject._name || "")).toLowerCase();
  result2.id = id;
  result2.name = audioObject._name;
  result2.manufacturer = audioObject.coreaudio_device_manufacturer;
  result2.revision = null;
  result2.driver = null;
  result2.default = !!(audioObject.coreaudio_default_audio_input_device || "") || !!(audioObject.coreaudio_default_audio_output_device || "");
  result2.channel = parseDarwinChannel(channelStr);
  result2.type = parseAudioType(result2.name, !!(audioObject.coreaudio_device_input || ""), !!(audioObject.coreaudio_device_output || ""));
  result2.in = !!(audioObject.coreaudio_device_input || "");
  result2.out = !!(audioObject.coreaudio_device_output || "");
  result2.status = "online";
  return result2;
}
function parseWindowsAudio(lines) {
  const result2 = {};
  const status = util$1.getValue(lines, "StatusInfo", ":");
  result2.id = util$1.getValue(lines, "DeviceID", ":");
  result2.name = util$1.getValue(lines, "name", ":");
  result2.manufacturer = util$1.getValue(lines, "manufacturer", ":");
  result2.revision = null;
  result2.driver = null;
  result2.default = null;
  result2.channel = null;
  result2.type = parseAudioType(result2.name, null, null);
  result2.in = null;
  result2.out = null;
  result2.status = status;
  return result2;
}
function audio(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux$1 || _freebsd$1 || _openbsd$1 || _netbsd$1) {
        let cmd = "lspci -vmm 2>/dev/null";
        exec$1(cmd, function(error, stdout) {
          if (!error) {
            const audioPCI = getLinuxAudioPci();
            const parts = stdout.toString().split("\n\n");
            parts.forEach((element) => {
              const lines = element.split("\n");
              if (util$1.getValue(lines, "class", ":", true).toLowerCase().indexOf("audio") >= 0) {
                const audio2 = parseLinuxAudioPciMM(lines, audioPCI);
                result2.push(audio2);
              }
            });
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin$1) {
        let cmd = "system_profiler SPAudioDataType -json";
        exec$1(cmd, function(error, stdout) {
          if (!error) {
            try {
              const outObj = JSON.parse(stdout.toString());
              if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]["_items"] && outObj.SPAudioDataType[0]["_items"].length) {
                for (let i = 0; i < outObj.SPAudioDataType[0]["_items"].length; i++) {
                  const audio2 = parseDarwinAudio(outObj.SPAudioDataType[0]["_items"][i], i);
                  result2.push(audio2);
                }
              }
            } catch (e) {
              util$1.noop();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows$1) {
        util$1.powerShell("Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl").then((stdout, error) => {
          if (!error) {
            const parts = stdout.toString().split(/\n\s*\n/);
            parts.forEach((element) => {
              const lines = element.split("\n");
              if (util$1.getValue(lines, "name", ":")) {
                result2.push(parseWindowsAudio(lines));
              }
            });
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos$1) {
        resolve(null);
      }
    });
  });
}
audio$1.audio = audio;
var bluetooth = {};
var bluetoothVendors$1 = {
  0: "Ericsson Technology Licensing",
  1: "Nokia Mobile Phones",
  2: "Intel Corp.",
  3: "IBM Corp.",
  4: "Toshiba Corp.",
  5: "3Com",
  6: "Microsoft",
  7: "Lucent",
  8: "Motorola",
  9: "Infineon Technologies AG",
  10: "Cambridge Silicon Radio",
  11: "Silicon Wave",
  12: "Digianswer A/S",
  13: "Texas Instruments Inc.",
  14: "Ceva, Inc. (formerly Parthus Technologies, Inc.)",
  15: "Broadcom Corporation",
  16: "Mitel Semiconductor",
  17: "Widcomm, Inc",
  18: "Zeevo, Inc.",
  19: "Atmel Corporation",
  20: "Mitsubishi Electric Corporation",
  21: "RTX Telecom A/S",
  22: "KC Technology Inc.",
  23: "NewLogic",
  24: "Transilica, Inc.",
  25: "Rohde & Schwarz GmbH & Co. KG",
  26: "TTPCom Limited",
  27: "Signia Technologies, Inc.",
  28: "Conexant Systems Inc.",
  29: "Qualcomm",
  30: "Inventel",
  31: "AVM Berlin",
  32: "BandSpeed, Inc.",
  33: "Mansella Ltd",
  34: "NEC Corporation",
  35: "WavePlus Technology Co., Ltd.",
  36: "Alcatel",
  37: "NXP Semiconductors (formerly Philips Semiconductors)",
  38: "C Technologies",
  39: "Open Interface",
  40: "R F Micro Devices",
  41: "Hitachi Ltd",
  42: "Symbol Technologies, Inc.",
  43: "Tenovis",
  44: "Macronix International Co. Ltd.",
  45: "GCT Semiconductor",
  46: "Norwood Systems",
  47: "MewTel Technology Inc.",
  48: "ST Microelectronics",
  49: "Synopsis",
  50: "Red-M (Communications) Ltd",
  51: "Commil Ltd",
  52: "Computer Access Technology Corporation (CATC)",
  53: "Eclipse (HQ Espana) S.L.",
  54: "Renesas Electronics Corporation",
  55: "Mobilian Corporation",
  56: "Terax",
  57: "Integrated System Solution Corp.",
  58: "Matsushita Electric Industrial Co., Ltd.",
  59: "Gennum Corporation",
  60: "BlackBerry Limited (formerly Research In Motion)",
  61: "IPextreme, Inc.",
  62: "Systems and Chips, Inc.",
  63: "Bluetooth SIG, Inc.",
  64: "Seiko Epson Corporation",
  65: "Integrated Silicon Solution Taiwan, Inc.",
  66: "CONWISE Technology Corporation Ltd",
  67: "PARROT SA",
  68: "Socket Mobile",
  69: "Atheros Communications, Inc.",
  70: "MediaTek, Inc.",
  71: "Bluegiga",
  72: "Marvell Technology Group Ltd.",
  73: "3DSP Corporation",
  74: "Accel Semiconductor Ltd.",
  75: "Continental Automotive Systems",
  76: "Apple, Inc.",
  77: "Staccato Communications, Inc.",
  78: "Avago Technologies",
  79: "APT Licensing Ltd.",
  80: "SiRF Technology",
  81: "Tzero Technologies, Inc.",
  82: "J&M Corporation",
  83: "Free2move AB",
  84: "3DiJoy Corporation",
  85: "Plantronics, Inc.",
  86: "Sony Ericsson Mobile Communications",
  87: "Harman International Industries, Inc.",
  88: "Vizio, Inc.",
  89: "Nordic Semiconductor ASA",
  90: "EM Microelectronic-Marin SA",
  91: "Ralink Technology Corporation",
  92: "Belkin International, Inc.",
  93: "Realtek Semiconductor Corporation",
  94: "Stonestreet One, LLC",
  95: "Wicentric, Inc.",
  96: "RivieraWaves S.A.S",
  97: "RDA Microelectronics",
  98: "Gibson Guitars",
  99: "MiCommand Inc.",
  100: "Band XI International, LLC",
  101: "Hewlett-Packard Company",
  102: "9Solutions Oy",
  103: "GN Netcom A/S",
  104: "General Motors",
  105: "A&D Engineering, Inc.",
  106: "MindTree Ltd.",
  107: "Polar Electro OY",
  108: "Beautiful Enterprise Co., Ltd.",
  109: "BriarTek, Inc.",
  110: "Summit Data Communications, Inc.",
  111: "Sound ID",
  112: "Monster, LLC",
  113: "connectBlue AB",
  114: "ShangHai Super Smart Electronics Co. Ltd.",
  115: "Group Sense Ltd.",
  116: "Zomm, LLC",
  117: "Samsung Electronics Co. Ltd.",
  118: "Creative Technology Ltd.",
  119: "Laird Technologies",
  120: "Nike, Inc.",
  121: "lesswire AG",
  122: "MStar Semiconductor, Inc.",
  123: "Hanlynn Technologies",
  124: "A & R Cambridge",
  125: "Seers Technology Co. Ltd",
  126: "Sports Tracking Technologies Ltd.",
  127: "Autonet Mobile",
  128: "DeLorme Publishing Company, Inc.",
  129: "WuXi Vimicro",
  130: "Sennheiser Communications A/S",
  131: "TimeKeeping Systems, Inc.",
  132: "Ludus Helsinki Ltd.",
  133: "BlueRadios, Inc.",
  134: "equinox AG",
  135: "Garmin International, Inc.",
  136: "Ecotest",
  137: "GN ReSound A/S",
  138: "Jawbone",
  139: "Topcorn Positioning Systems, LLC",
  140: "Gimbal Inc. (formerly Qualcomm Labs, Inc. and Qualcomm Retail Solutions, Inc.)",
  141: "Zscan Software",
  142: "Quintic Corp.",
  143: "Stollman E+V GmbH",
  144: "Funai Electric Co., Ltd.",
  145: "Advanced PANMOBIL Systems GmbH & Co. KG",
  146: "ThinkOptics, Inc.",
  147: "Universal Electronics, Inc.",
  148: "Airoha Technology Corp.",
  149: "NEC Lighting, Ltd.",
  150: "ODM Technology, Inc.",
  151: "ConnecteDevice Ltd.",
  152: "zer01.tv GmbH",
  153: "i.Tech Dynamic Global Distribution Ltd.",
  154: "Alpwise",
  155: "Jiangsu Toppower Automotive Electronics Co., Ltd.",
  156: "Colorfy, Inc.",
  157: "Geoforce Inc.",
  158: "Bose Corporation",
  159: "Suunto Oy",
  160: "Kensington Computer Products Group",
  161: "SR-Medizinelektronik",
  162: "Vertu Corporation Limited",
  163: "Meta Watch Ltd.",
  164: "LINAK A/S",
  165: "OTL Dynamics LLC",
  166: "Panda Ocean Inc.",
  167: "Visteon Corporation",
  168: "ARP Devices Limited",
  169: "Magneti Marelli S.p.A",
  170: "CAEN RFID srl",
  171: "Ingenieur-Systemgruppe Zahn GmbH",
  172: "Green Throttle Games",
  173: "Peter Systemtechnik GmbH",
  174: "Omegawave Oy",
  175: "Cinetix",
  176: "Passif Semiconductor Corp",
  177: "Saris Cycling Group, Inc",
  178: "Bekey A/S",
  179: "Clarinox Technologies Pty. Ltd.",
  180: "BDE Technology Co., Ltd.",
  181: "Swirl Networks",
  182: "Meso international",
  183: "TreLab Ltd",
  184: "Qualcomm Innovation Center, Inc. (QuIC)",
  185: "Johnson Controls, Inc.",
  186: "Starkey Laboratories Inc.",
  187: "S-Power Electronics Limited",
  188: "Ace Sensor Inc",
  189: "Aplix Corporation",
  190: "AAMP of America",
  191: "Stalmart Technology Limited",
  192: "AMICCOM Electronics Corporation",
  193: "Shenzhen Excelsecu Data Technology Co.,Ltd",
  194: "Geneq Inc.",
  195: "adidas AG",
  196: "LG Electronics",
  197: "Onset Computer Corporation",
  198: "Selfly BV",
  199: "Quuppa Oy.",
  200: "GeLo Inc",
  201: "Evluma",
  202: "MC10",
  203: "Binauric SE",
  204: "Beats Electronics",
  205: "Microchip Technology Inc.",
  206: "Elgato Systems GmbH",
  207: "ARCHOS SA",
  208: "Dexcom, Inc.",
  209: "Polar Electro Europe B.V.",
  210: "Dialog Semiconductor B.V.",
  211: "TaixingbangÂ Technology (HK) Co,. LTD.",
  212: "Kawantech",
  213: "Austco Communication Systems",
  214: "Timex Group USA, Inc.",
  215: "Qualcomm Technologies, Inc.",
  216: "Qualcomm Connected Experiences, Inc.",
  217: "Voyetra Turtle Beach",
  218: "txtr GmbH",
  219: "Biosentronics",
  220: "Procter & Gamble",
  221: "Hosiden Corporation",
  222: "Muzik LLC",
  223: "Misfit Wearables Corp",
  224: "Google",
  225: "Danlers Ltd",
  226: "Semilink Inc",
  227: "inMusic Brands, Inc",
  228: "L.S. Research Inc.",
  229: "Eden Software Consultants Ltd.",
  230: "Freshtemp",
  231: "KS Technologies",
  232: "ACTS Technologies",
  233: "Vtrack Systems",
  234: "Nielsen-Kellerman Company",
  235: "Server Technology, Inc.",
  236: "BioResearch Associates",
  237: "Jolly Logic, LLC",
  238: "Above Average Outcomes, Inc.",
  239: "Bitsplitters GmbH",
  240: "PayPal, Inc.",
  241: "Witron Technology Limited",
  242: "Aether ThingsÂ Inc. (formerly Morse Project Inc.)",
  243: "Kent Displays Inc.",
  244: "Nautilus Inc.",
  245: "Smartifier Oy",
  246: "Elcometer Limited",
  247: "VSN Technologies Inc.",
  248: "AceUni Corp., Ltd.",
  249: "StickNFind",
  250: "Crystal Code AB",
  251: "KOUKAAM a.s.",
  252: "Delphi Corporation",
  253: "ValenceTech Limited",
  254: "Reserved",
  255: "Typo Products, LLC",
  256: "TomTom International BV",
  257: "Fugoo, Inc",
  258: "Keiser Corporation",
  259: "Bang & Olufsen A/S",
  260: "PLUS Locations Systems Pty Ltd",
  261: "Ubiquitous Computing Technology Corporation",
  262: "Innovative Yachtter Solutions",
  263: "William Demant Holding A/S",
  264: "Chicony Electronics Co., Ltd.",
  265: "Atus BV",
  266: "Codegate Ltd.",
  267: "ERi, Inc.",
  268: "Transducers Direct, LLC",
  269: "Fujitsu Ten Limited",
  270: "Audi AG",
  271: "HiSilicon Technologies Co., Ltd.",
  272: "Nippon Seiki Co., Ltd.",
  273: "Steelseries ApS",
  274: "vyzybl Inc.",
  275: "Openbrain Technologies, Co., Ltd.",
  276: "Xensr",
  277: "e.solutions",
  278: "1OAK Technologies",
  279: "Wimoto Technologies Inc",
  280: "Radius Networks, Inc.",
  281: "Wize Technology Co., Ltd.",
  282: "Qualcomm Labs, Inc.",
  283: "Aruba Networks",
  284: "Baidu",
  285: "Arendi AG",
  286: "Skoda Auto a.s.",
  287: "Volkswagon AG",
  288: "Porsche AG",
  289: "Sino Wealth Electronic Ltd.",
  290: "AirTurn, Inc.",
  291: "Kinsa, Inc.",
  292: "HID Global",
  293: "SEAT es",
  294: "Promethean Ltd.",
  295: "Salutica Allied Solutions",
  296: "GPSI Group Pty Ltd",
  297: "Nimble Devices Oy",
  298: "Changzhou Yongse Infotech Co., Ltd",
  299: "SportIQ",
  300: "TEMEC Instruments B.V.",
  301: "Sony Corporation",
  302: "ASSA ABLOY",
  303: "Clarion Co., Ltd.",
  304: "Warehouse Innovations",
  305: "Cypress Semiconductor Corporation",
  306: "MADS Inc",
  307: "Blue Maestro Limited",
  308: "Resolution Products, Inc.",
  309: "Airewear LLC",
  310: "Seed Labs, Inc. (formerly ETC sp. z.o.o.)",
  311: "Prestigio Plaza Ltd.",
  312: "NTEO Inc.",
  313: "Focus Systems Corporation",
  314: "Tencent Holdings Limited",
  315: "Allegion",
  316: "Murata Manufacuring Co., Ltd.",
  318: "Nod, Inc.",
  319: "B&B Manufacturing Company",
  320: "AlpineÂ ElectronicsÂ (China)Â Co.,Â Ltd",
  321: "FedEx Services",
  322: "Grape Systems Inc.",
  323: "Bkon Connect",
  324: "Lintech GmbH",
  325: "Novatel Wireless",
  326: "Ciright",
  327: "Mighty Cast, Inc.",
  328: "Ambimat Electronics",
  329: "Perytons Ltd.",
  330: "Tivoli Audio, LLC",
  331: "Master Lock",
  332: "Mesh-Net Ltd",
  333: "Huizhou Desay SV Automotive CO., LTD.",
  334: "Tangerine, Inc.",
  335: "B&W Group Ltd.",
  336: "Pioneer Corporation",
  337: "OnBeep",
  338: "Vernier Software & Technology",
  339: "ROL Ergo",
  340: "Pebble Technology",
  341: "NETATMO",
  342: "Accumulate AB",
  343: "Anhui Huami Information Technology Co., Ltd.",
  344: "Inmite s.r.o.",
  345: "ChefSteps, Inc.",
  346: "micas AG",
  347: "Biomedical Research Ltd.",
  348: "Pitius Tec S.L.",
  349: "Estimote, Inc.",
  350: "Unikey Technologies, Inc.",
  351: "Timer Cap Co.",
  352: "AwoX",
  353: "yikes",
  354: "MADSGlobal NZ Ltd.",
  355: "PCH International",
  356: "Qingdao Yeelink Information Technology Co., Ltd.",
  357: "Milwaukee Tool (formerly Milwaukee Electric Tools)",
  358: "MISHIK Pte Ltd",
  359: "Bayer HealthCare",
  360: "Spicebox LLC",
  361: "emberlight",
  362: "Cooper-Atkins Corporation",
  363: "Qblinks",
  364: "MYSPHERA",
  365: "LifeScan Inc",
  366: "Volantic AB",
  367: "Podo Labs, Inc",
  368: "Roche Diabetes Care AG",
  369: "Amazon Fulfillment Service",
  370: "Connovate Technology Private Limited",
  371: "Kocomojo, LLC",
  372: "Everykey LLC",
  373: "Dynamic Controls",
  374: "SentriLock",
  375: "I-SYST inc.",
  376: "CASIO COMPUTER CO., LTD.",
  377: "LAPIS Semiconductor Co., Ltd.",
  378: "Telemonitor, Inc.",
  379: "taskit GmbH",
  380: "Daimler AG",
  381: "BatAndCat",
  382: "BluDotz Ltd",
  383: "XTel ApS",
  384: "Gigaset Communications GmbH",
  385: "Gecko Health Innovations, Inc.",
  386: "HOP Ubiquitous",
  387: "To Be Assigned",
  388: "Nectar",
  389: "belâapps LLC",
  390: "CORE Lighting Ltd",
  391: "Seraphim Sense Ltd",
  392: "Unico RBC",
  393: "Physical Enterprises Inc.",
  394: "Able Trend Technology Limited",
  395: "Konica Minolta, Inc.",
  396: "Wilo SE",
  397: "Extron Design Services",
  398: "Fitbit, Inc.",
  399: "Fireflies Systems",
  400: "Intelletto Technologies Inc.",
  401: "FDK CORPORATION",
  402: "Cloudleaf, Inc",
  403: "Maveric Automation LLC",
  404: "Acoustic Stream Corporation",
  405: "Zuli",
  406: "Paxton Access Ltd",
  407: "WiSilica Inc",
  408: "Vengit Limited",
  409: "SALTO SYSTEMS S.L.",
  410: "TRON Forum (formerly T-Engine Forum)",
  411: "CUBETECH s.r.o.",
  412: "Cokiya Incorporated",
  413: "CVS Health",
  414: "Ceruus",
  415: "Strainstall Ltd",
  416: "Channel Enterprises (HK) Ltd.",
  417: "FIAMM",
  418: "GIGALANE.CO.,LTD",
  419: "EROAD",
  420: "Mine Safety Appliances",
  421: "Icon Health and Fitness",
  422: "Asandoo GmbH",
  423: "ENERGOUS CORPORATION",
  424: "Taobao",
  425: "Canon Inc.",
  426: "Geophysical Technology Inc.",
  427: "Facebook, Inc.",
  428: "Nipro Diagnostics, Inc.",
  429: "FlightSafety International",
  430: "Earlens Corporation",
  431: "Sunrise Micro Devices, Inc.",
  432: "Star Micronics Co., Ltd.",
  433: "Netizens Sp. z o.o.",
  434: "Nymi Inc.",
  435: "Nytec, Inc.",
  436: "Trineo Sp. z o.o.",
  437: "Nest Labs Inc.",
  438: "LM Technologies Ltd",
  439: "General Electric Company",
  440: "i+D3 S.L.",
  441: "HANA Micron",
  442: "Stages Cycling LLC",
  443: "Cochlear Bone Anchored Solutions AB",
  444: "SenionLab AB",
  445: "Syszone Co., Ltd",
  446: "Pulsate Mobile Ltd.",
  447: "Hong Kong HunterSun Electronic Limited",
  448: "pironex GmbH",
  449: "BRADATECH Corp.",
  450: "Transenergooil AG",
  451: "Bunch",
  452: "DME Microelectronics",
  453: "Bitcraze AB",
  454: "HASWARE Inc.",
  455: "Abiogenix Inc.",
  456: "Poly-Control ApS",
  457: "Avi-on",
  458: "Laerdal Medical AS",
  459: "Fetch My Pet",
  460: "Sam Labs Ltd.",
  461: "Chengdu Synwing Technology Ltd",
  462: "HOUWA SYSTEM DESIGN, k.k.",
  463: "BSH",
  464: "Primus Inter Pares Ltd",
  465: "August",
  466: "Gill Electronics",
  467: "Sky Wave Design",
  468: "Newlab S.r.l.",
  469: "ELAD srl",
  470: "G-wearables inc.",
  471: "Squadrone Systems Inc.",
  472: "Code Corporation",
  473: "Savant Systems LLC",
  474: "Logitech International SA",
  475: "Innblue Consulting",
  476: "iParking Ltd.",
  477: "Koninklijke Philips Electronics N.V.",
  478: "Minelab Electronics Pty Limited",
  479: "Bison Group Ltd.",
  480: "Widex A/S",
  481: "Jolla Ltd",
  482: "Lectronix, Inc.",
  483: "Caterpillar Inc",
  484: "Freedom Innovations",
  485: "Dynamic Devices Ltd",
  486: "Technology Solutions (UK) Ltd",
  487: "IPS Group Inc.",
  488: "STIR",
  489: "Sano, Inc",
  490: "Advanced Application Design, Inc.",
  491: "AutoMap LLC",
  492: "Spreadtrum Communications Shanghai Ltd",
  493: "CuteCircuit LTD",
  494: "Valeo Service",
  495: "Fullpower Technologies, Inc.",
  496: "KloudNation",
  497: "Zebra Technologies Corporation",
  498: "Itron, Inc.",
  499: "The University of Tokyo",
  500: "UTC Fire and Security",
  501: "Cool Webthings Limited",
  502: "DJO Global",
  503: "Gelliner Limited",
  504: "Anyka (Guangzhou) Microelectronics Technology Co, LTD",
  505: "Medtronic, Inc.",
  506: "Gozio, Inc.",
  507: "Form Lifting, LLC",
  508: "Wahoo Fitness, LLC",
  509: "Kontakt Micro-Location Sp. z o.o.",
  510: "Radio System Corporation",
  511: "Freescale Semiconductor, Inc.",
  512: "Verifone Systems PTe Ltd. Taiwan Branch",
  513: "AR Timing",
  514: "Rigado LLC",
  515: "Kemppi Oy",
  516: "Tapcentive Inc.",
  517: "Smartbotics Inc.",
  518: "Otter Products, LLC",
  519: "STEMP Inc.",
  520: "LumiGeek LLC",
  521: "InvisionHeart Inc.",
  522: "Macnica Inc. ",
  523: "Jaguar Land Rover Limited",
  524: "CoroWare Technologies, Inc",
  525: "Simplo Technology Co., LTD",
  526: "Omron Healthcare Co., LTD",
  527: "Comodule GMBH",
  528: "ikeGPS",
  529: "Telink Semiconductor Co. Ltd",
  530: "Interplan Co., Ltd",
  531: "Wyler AG",
  532: "IK Multimedia Production srl",
  533: "Lukoton Experience Oy",
  534: "MTI Ltd",
  535: "Tech4home, Lda",
  536: "Hiotech AB",
  537: "DOTT Limited",
  538: "Blue Speck Labs, LLC",
  539: "Cisco Systems, Inc",
  540: "Mobicomm Inc",
  541: "Edamic",
  542: "Goodnet, Ltd",
  543: "Luster Leaf Products Inc",
  544: "Manus Machina BV",
  545: "Mobiquity Networks Inc",
  546: "Praxis Dynamics",
  547: "Philip Morris Products S.A.",
  548: "Comarch SA",
  549: "Nestl Nespresso S.A.",
  550: "Merlinia A/S",
  551: "LifeBEAM Technologies",
  552: "Twocanoes Labs, LLC",
  553: "Muoverti Limited",
  554: "Stamer Musikanlagen GMBH",
  555: "Tesla Motors",
  556: "Pharynks Corporation",
  557: "Lupine",
  558: "Siemens AG",
  559: "Huami (Shanghai) Culture Communication CO., LTD",
  560: "Foster Electric Company, Ltd",
  561: "ETA SA",
  562: "x-Senso Solutions Kft",
  563: "Shenzhen SuLong Communication Ltd",
  564: "FengFan (BeiJing) Technology Co, Ltd",
  565: "Qrio Inc",
  566: "Pitpatpet Ltd",
  567: "MSHeli s.r.l.",
  568: "Trakm8 Ltd",
  569: "JIN CO, Ltd",
  570: "Alatech Tehnology",
  571: "Beijing CarePulse Electronic Technology Co, Ltd",
  572: "Awarepoint",
  573: "ViCentra B.V.",
  574: "Raven Industries",
  575: "WaveWare Technologies Inc.",
  576: "Argenox Technologies",
  577: "Bragi GmbH",
  578: "16Lab Inc",
  579: "Masimo Corp",
  580: "Iotera Inc",
  581: "Endress+Hauser",
  582: "ACKme Networks, Inc.",
  583: "FiftyThree Inc.",
  584: "Parker Hannifin Corp",
  585: "Transcranial Ltd",
  586: "Uwatec AG",
  587: "Orlan LLC",
  588: "Blue Clover Devices",
  589: "M-Way Solutions GmbH",
  590: "Microtronics Engineering GmbH",
  591: "Schneider Schreibgerte GmbH",
  592: "Sapphire Circuits LLC",
  593: "Lumo Bodytech Inc.",
  594: "UKC Technosolution",
  595: "Xicato Inc.",
  596: "Playbrush",
  597: "Dai Nippon Printing Co., Ltd.",
  598: "G24 Power Limited",
  599: "AdBabble Local Commerce Inc.",
  600: "Devialet SA",
  601: "ALTYOR",
  602: "University of Applied Sciences Valais/Haute Ecole Valaisanne",
  603: "Five Interactive, LLC dba Zendo",
  604: "NetEaseHangzhouNetwork co.Ltd.",
  605: "Lexmark International Inc.",
  606: "Fluke Corporation",
  607: "Yardarm Technologies",
  608: "SensaRx",
  609: "SECVRE GmbH",
  610: "Glacial Ridge Technologies",
  611: "Identiv, Inc.",
  612: "DDS, Inc.",
  613: "SMK Corporation",
  614: "Schawbel Technologies LLC",
  615: "XMI Systems SA",
  616: "Cerevo",
  617: "Torrox GmbH & Co KG",
  618: "Gemalto",
  619: "DEKA Research & Development Corp.",
  620: "Domster Tadeusz Szydlowski",
  621: "Technogym SPA",
  622: "FLEURBAEY BVBA",
  623: "Aptcode Solutions",
  624: "LSI ADL Technology",
  625: "Animas Corp",
  626: "Alps Electric Co., Ltd.",
  627: "OCEASOFT",
  628: "Motsai Research",
  629: "Geotab",
  630: "E.G.O. Elektro-Gertebau GmbH",
  631: "bewhere inc",
  632: "Johnson Outdoors Inc",
  633: "steute Schaltgerate GmbH & Co. KG",
  634: "Ekomini inc.",
  635: "DEFA AS",
  636: "Aseptika Ltd",
  637: "HUAWEI Technologies Co., Ltd. ( )",
  638: "HabitAware, LLC",
  639: "ruwido austria gmbh",
  640: "ITEC corporation",
  641: "StoneL",
  642: "Sonova AG",
  643: "Maven Machines, Inc.",
  644: "Synapse Electronics",
  645: "Standard Innovation Inc.",
  646: "RF Code, Inc.",
  647: "Wally Ventures S.L.",
  648: "Willowbank Electronics Ltd",
  649: "SK Telecom",
  650: "Jetro AS",
  651: "Code Gears LTD",
  652: "NANOLINK APS",
  653: "IF, LLC",
  654: "RF Digital Corp",
  655: "Church & Dwight Co., Inc",
  656: "Multibit Oy",
  657: "CliniCloud Inc",
  658: "SwiftSensors",
  659: "Blue Bite",
  660: "ELIAS GmbH",
  661: "Sivantos GmbH",
  662: "Petzl",
  663: "storm power ltd",
  664: "EISST Ltd",
  665: "Inexess Technology Simma KG",
  666: "Currant, Inc.",
  667: "C2 Development, Inc.",
  668: "Blue Sky Scientific, LLC",
  669: "ALOTTAZS LABS, LLC",
  670: "Kupson spol. s r.o.",
  671: "Areus Engineering GmbH",
  672: "Impossible Camera GmbH",
  673: "InventureTrack Systems",
  674: "LockedUp",
  675: "Itude",
  676: "Pacific Lock Company",
  677: "Tendyron Corporation ( )",
  678: "Robert Bosch GmbH",
  679: "Illuxtron international B.V.",
  680: "miSport Ltd.",
  681: "Chargelib",
  682: "Doppler Lab",
  683: "BBPOS Limited",
  684: "RTB Elektronik GmbH & Co. KG",
  685: "Rx Networks, Inc.",
  686: "WeatherFlow, Inc.",
  687: "Technicolor USA Inc.",
  688: "Bestechnic(Shanghai),Ltd",
  689: "Raden Inc",
  690: "JouZen Oy",
  691: "CLABER S.P.A.",
  692: "Hyginex, Inc.",
  693: "HANSHIN ELECTRIC RAILWAY CO.,LTD.",
  694: "Schneider Electric",
  695: "Oort Technologies LLC",
  696: "Chrono Therapeutics",
  697: "Rinnai Corporation",
  698: "Swissprime Technologies AG",
  699: "Koha.,Co.Ltd",
  700: "Genevac Ltd",
  701: "Chemtronics",
  702: "Seguro Technology Sp. z o.o.",
  703: "Redbird Flight Simulations",
  704: "Dash Robotics",
  705: "LINE Corporation",
  706: "Guillemot Corporation",
  707: "Techtronic Power Tools Technology Limited",
  708: "Wilson Sporting Goods",
  709: "Lenovo (Singapore) Pte Ltd. ( )",
  710: "Ayatan Sensors",
  711: "Electronics Tomorrow Limited",
  712: "VASCO Data Security International, Inc.",
  713: "PayRange Inc.",
  714: "ABOV Semiconductor",
  715: "AINA-Wireless Inc.",
  716: "Eijkelkamp Soil & Water",
  717: "BMA ergonomics b.v.",
  718: "Teva Branded Pharmaceutical Products R&D, Inc.",
  719: "Anima",
  720: "3M",
  721: "Empatica Srl",
  722: "Afero, Inc.",
  723: "Powercast Corporation",
  724: "Secuyou ApS",
  725: "OMRON Corporation",
  726: "Send Solutions",
  727: "NIPPON SYSTEMWARE CO.,LTD.",
  728: "Neosfar",
  729: "Fliegl Agrartechnik GmbH",
  730: "Gilvader",
  731: "Digi International Inc (R)",
  732: "DeWalch Technologies, Inc.",
  733: "Flint Rehabilitation Devices, LLC",
  734: "Samsung SDS Co., Ltd.",
  735: "Blur Product Development",
  736: "University of Michigan",
  737: "Victron Energy BV",
  738: "NTT docomo",
  739: "Carmanah Technologies Corp.",
  740: "Bytestorm Ltd.",
  741: "Espressif Incorporated ( () )",
  742: "Unwire",
  743: "Connected Yard, Inc.",
  744: "American Music Environments",
  745: "Sensogram Technologies, Inc.",
  746: "Fujitsu Limited",
  747: "Ardic Technology",
  748: "Delta Systems, Inc",
  749: "HTC Corporation",
  750: "Citizen Holdings Co., Ltd.",
  751: "SMART-INNOVATION.inc",
  752: "Blackrat Software",
  753: "The Idea Cave, LLC",
  754: "GoPro, Inc.",
  755: "AuthAir, Inc",
  756: "Vensi, Inc.",
  757: "Indagem Tech LLC",
  758: "Intemo Technologies",
  759: "DreamVisions co., Ltd.",
  760: "Runteq Oy Ltd",
  761: "IMAGINATION TECHNOLOGIES LTD",
  762: "CoSTAR TEchnologies",
  763: "Clarius Mobile Health Corp.",
  764: "Shanghai Frequen Microelectronics Co., Ltd.",
  765: "Uwanna, Inc.",
  766: "Lierda Science & Technology Group Co., Ltd.",
  767: "Silicon Laboratories",
  768: "World Moto Inc.",
  769: "Giatec Scientific Inc.",
  770: "Loop Devices, Inc",
  771: "IACA electronique",
  772: "Martians Inc",
  773: "Swipp ApS",
  774: "Life Laboratory Inc.",
  775: "FUJI INDUSTRIAL CO.,LTD.",
  776: "Surefire, LLC",
  777: "Dolby Labs",
  778: "Ellisys",
  779: "Magnitude Lighting Converters",
  780: "Hilti AG",
  781: "Devdata S.r.l.",
  782: "Deviceworx",
  783: "Shortcut Labs",
  784: "SGL Italia S.r.l.",
  785: "PEEQ DATA",
  786: "Ducere Technologies Pvt Ltd",
  787: "DiveNav, Inc.",
  788: "RIIG AI Sp. z o.o.",
  789: "Thermo Fisher Scientific",
  790: "AG Measurematics Pvt. Ltd.",
  791: "CHUO Electronics CO., LTD.",
  792: "Aspenta International",
  793: "Eugster Frismag AG",
  794: "Amber wireless GmbH",
  795: "HQ Inc",
  796: "Lab Sensor Solutions",
  797: "Enterlab ApS",
  798: "Eyefi, Inc.",
  799: "MetaSystem S.p.A.",
  800: "SONO ELECTRONICS. CO., LTD",
  801: "Jewelbots",
  802: "Compumedics Limited",
  803: "Rotor Bike Components",
  804: "Astro, Inc.",
  805: "Amotus Solutions",
  806: "Healthwear Technologies (Changzhou)Ltd",
  807: "Essex Electronics",
  808: "Grundfos A/S",
  809: "Eargo, Inc.",
  810: "Electronic Design Lab",
  811: "ESYLUX",
  812: "NIPPON SMT.CO.,Ltd",
  813: "BM innovations GmbH",
  814: "indoormap",
  815: "OttoQ Inc",
  816: "North Pole Engineering",
  817: "3flares Technologies Inc.",
  818: "Electrocompaniet A.S.",
  819: "Mul-T-Lock",
  820: "Corentium AS",
  821: "Enlighted Inc",
  822: "GISTIC",
  823: "AJP2 Holdings, LLC",
  824: "COBI GmbH",
  825: "Blue Sky Scientific, LLC",
  826: "Appception, Inc.",
  827: "Courtney Thorne Limited",
  828: "Virtuosys",
  829: "TPV Technology Limited",
  830: "Monitra SA",
  831: "Automation Components, Inc.",
  832: "Letsense s.r.l.",
  833: "Etesian Technologies LLC",
  834: "GERTEC BRASIL LTDA.",
  835: "Drekker Development Pty. Ltd.",
  836: "Whirl Inc",
  837: "Locus Positioning",
  838: "Acuity Brands Lighting, Inc",
  839: "Prevent Biometrics",
  840: "Arioneo",
  841: "VersaMe",
  842: "Vaddio",
  843: "Libratone A/S",
  844: "HM Electronics, Inc.",
  845: "TASER International, Inc.",
  846: "SafeTrust Inc.",
  847: "Heartland Payment Systems",
  848: "Bitstrata Systems Inc.",
  849: "Pieps GmbH",
  850: "iRiding(Xiamen)Technology Co.,Ltd.",
  851: "Alpha Audiotronics, Inc.",
  852: "TOPPAN FORMS CO.,LTD.",
  853: "Sigma Designs, Inc.",
  854: "Spectrum Brands, Inc.",
  855: "Polymap Wireless",
  856: "MagniWare Ltd.",
  857: "Novotec Medical GmbH",
  858: "Medicom Innovation Partner a/s",
  859: "Matrix Inc.",
  860: "Eaton Corporation",
  861: "KYS",
  862: "Naya Health, Inc.",
  863: "Acromag",
  864: "Insulet Corporation",
  865: "Wellinks Inc.",
  866: "ON Semiconductor",
  867: "FREELAP SA",
  868: "Favero Electronics Srl",
  869: "BioMech Sensor LLC",
  870: "BOLTT Sports technologies Private limited",
  871: "Saphe International",
  872: "Metormote AB",
  873: "littleBits",
  874: "SetPoint Medical",
  875: "BRControls Products BV",
  876: "Zipcar",
  877: "AirBolt Pty Ltd",
  878: "KeepTruckin Inc",
  879: "Motiv, Inc.",
  880: "Wazombi Labs O",
  881: "ORBCOMM",
  882: "Nixie Labs, Inc.",
  883: "AppNearMe Ltd",
  884: "Holman Industries",
  885: "Expain AS",
  886: "Electronic Temperature Instruments Ltd",
  887: "Plejd AB",
  888: "Propeller Health",
  889: "Shenzhen iMCO Electronic Technology Co.,Ltd",
  890: "Algoria",
  891: "Apption Labs Inc.",
  892: "Cronologics Corporation",
  893: "MICRODIA Ltd.",
  894: "lulabytes S.L.",
  895: "Nestec S.A.",
  896: "LLC MEGA - F service",
  897: "Sharp Corporation",
  898: "Precision Outcomes Ltd",
  899: "Kronos Incorporated",
  900: "OCOSMOS Co., Ltd.",
  901: "Embedded Electronic Solutions Ltd. dba e2Solutions",
  902: "Aterica Inc.",
  903: "BluStor PMC, Inc.",
  904: "Kapsch TrafficCom AB",
  905: "ActiveBlu Corporation",
  906: "Kohler Mira Limited",
  907: "Noke",
  908: "Appion Inc.",
  909: "Resmed Ltd",
  910: "Crownstone B.V.",
  911: "Xiaomi Inc.",
  912: "INFOTECH s.r.o.",
  913: "Thingsquare AB",
  914: "T&D",
  915: "LAVAZZA S.p.A.",
  916: "Netclearance Systems, Inc.",
  917: "SDATAWAY",
  918: "BLOKS GmbH",
  919: "LEGO System A/S",
  920: "Thetatronics Ltd",
  921: "Nikon Corporation",
  922: "NeST",
  923: "South Silicon Valley Microelectronics",
  924: "ALE International",
  925: "CareView Communications, Inc.",
  926: "SchoolBoard Limited",
  927: "Molex Corporation",
  928: "IVT Wireless Limited",
  929: "Alpine Labs LLC",
  930: "Candura Instruments",
  931: "SmartMovt Technology Co., Ltd",
  932: "Token Zero Ltd",
  933: "ACE CAD Enterprise Co., Ltd. (ACECAD)",
  934: "Medela, Inc",
  935: "AeroScout",
  936: "Esrille Inc.",
  937: "THINKERLY SRL",
  938: "Exon Sp. z o.o.",
  939: "Meizu Technology Co., Ltd.",
  940: "Smablo LTD",
  941: "XiQ",
  942: "Allswell Inc.",
  943: "Comm-N-Sense Corp DBA Verigo",
  944: "VIBRADORM GmbH",
  945: "Otodata Wireless Network Inc.",
  946: "Propagation Systems Limited",
  947: "Midwest Instruments & Controls",
  948: "Alpha Nodus, inc.",
  949: "petPOMM, Inc",
  950: "Mattel",
  951: "Airbly Inc.",
  952: "A-Safe Limited",
  953: "FREDERIQUE CONSTANT SA",
  954: "Maxscend Microelectronics Company Limited",
  955: "Abbott Diabetes Care",
  956: "ASB Bank Ltd",
  957: "amadas",
  958: "Applied Science, Inc.",
  959: "iLumi Solutions Inc.",
  960: "Arch Systems Inc.",
  961: "Ember Technologies, Inc.",
  962: "Snapchat Inc",
  963: "Casambi Technologies Oy",
  964: "Pico Technology Inc.",
  965: "St. Jude Medical, Inc.",
  966: "Intricon",
  967: "Structural Health Systems, Inc.",
  968: "Avvel International",
  969: "Gallagher Group",
  970: "In2things Automation Pvt. Ltd.",
  971: "SYSDEV Srl",
  972: "Vonkil Technologies Ltd",
  973: "Wynd Technologies, Inc.",
  974: "CONTRINEX S.A.",
  975: "MIRA, Inc.",
  976: "Watteam Ltd",
  977: "Density Inc.",
  978: "IOT Pot India Private Limited",
  979: "Sigma Connectivity AB",
  980: "PEG PEREGO SPA",
  981: "Wyzelink Systems Inc.",
  982: "Yota Devices LTD",
  983: "FINSECUR",
  984: "Zen-Me Labs Ltd",
  985: "3IWare Co., Ltd.",
  986: "EnOcean GmbH",
  987: "Instabeat, Inc",
  988: "Nima Labs",
  989: "Andreas Stihl AG & Co. KG",
  990: "Nathan Rhoades LLC",
  991: "Grob Technologies, LLC",
  992: "Actions (Zhuhai) Technology Co., Limited",
  993: "SPD Development Company Ltd",
  994: "Sensoan Oy",
  995: "Qualcomm Life Inc",
  996: "Chip-ing AG",
  997: "ffly4u",
  998: "IoT Instruments Oy",
  999: "TRUE Fitness Technology",
  1e3: "Reiner Kartengeraete GmbH & Co. KG.",
  1001: "SHENZHEN LEMONJOY TECHNOLOGY CO., LTD.",
  1002: "Hello Inc.",
  1003: "Evollve Inc.",
  1004: "Jigowatts Inc.",
  1005: "BASIC MICRO.COM,INC.",
  1006: "CUBE TECHNOLOGIES",
  1007: "foolography GmbH",
  1008: "CLINK",
  1009: "Hestan Smart Cooking Inc.",
  1010: "WindowMaster A/S",
  1011: "Flowscape AB",
  1012: "PAL Technologies Ltd",
  1013: "WHERE, Inc.",
  1014: "Iton Technology Corp.",
  1015: "Owl Labs Inc.",
  1016: "Rockford Corp.",
  1017: "Becon Technologies Co.,Ltd.",
  1018: "Vyassoft Technologies Inc",
  1019: "Nox Medical",
  1020: "Kimberly-Clark",
  1021: "Trimble Navigation Ltd.",
  1022: "Littelfuse",
  1023: "Withings",
  1024: "i-developer IT Beratung UG",
  1026: "Sears Holdings Corporation",
  1027: "Gantner Electronic GmbH",
  1028: "Authomate Inc",
  1029: "Vertex International, Inc.",
  1030: "Airtago",
  1031: "Swiss Audio SA",
  1032: "ToGetHome Inc.",
  1033: "AXIS",
  1034: "Openmatics",
  1035: "Jana Care Inc.",
  1036: "Senix Corporation",
  1037: "NorthStar Battery Company, LLC",
  1038: "SKF (U.K.) Limited",
  1039: "CO-AX Technology, Inc.",
  1040: "Fender Musical Instruments",
  1041: "Luidia Inc",
  1042: "SEFAM",
  1043: "Wireless Cables Inc",
  1044: "Lightning Protection International Pty Ltd",
  1045: "Uber Technologies Inc",
  1046: "SODA GmbH",
  1047: "Fatigue Science",
  1048: "Alpine Electronics Inc.",
  1049: "Novalogy LTD",
  1050: "Friday Labs Limited",
  1051: "OrthoAccel Technologies",
  1052: "WaterGuru, Inc.",
  1053: "Benning Elektrotechnik und Elektronik GmbH & Co. KG",
  1054: "Dell Computer Corporation",
  1055: "Kopin Corporation",
  1056: "TecBakery GmbH",
  1057: "Backbone Labs, Inc.",
  1058: "DELSEY SA",
  1059: "Chargifi Limited",
  1060: "Trainesense Ltd.",
  1061: "Unify Software and Solutions GmbH & Co. KG",
  1062: "Husqvarna AB",
  1063: "Focus fleet and fuel management inc",
  1064: "SmallLoop, LLC",
  1065: "Prolon Inc.",
  1066: "BD Medical",
  1067: "iMicroMed Incorporated",
  1068: "Ticto N.V.",
  1069: "Meshtech AS",
  1070: "MemCachier Inc.",
  1071: "Danfoss A/S",
  1072: "SnapStyk Inc.",
  1073: "Amyway Corporation",
  1074: "Silk Labs, Inc.",
  1075: "Pillsy Inc.",
  1076: "Hatch Baby, Inc.",
  1077: "Blocks Wearables Ltd.",
  1078: "Drayson Technologies (Europe) Limited",
  1079: "eBest IOT Inc.",
  1080: "Helvar Ltd",
  1081: "Radiance Technologies",
  1082: "Nuheara Limited",
  1083: "Appside co., ltd.",
  1084: "DeLaval",
  1085: "Coiler Corporation",
  1086: "Thermomedics, Inc.",
  1087: "Tentacle Sync GmbH",
  1088: "Valencell, Inc.",
  1089: "iProtoXi Oy",
  1090: "SECOM CO., LTD.",
  1091: "Tucker International LLC",
  1092: "Metanate Limited",
  1093: "Kobian Canada Inc.",
  1094: "NETGEAR, Inc.",
  1095: "Fabtronics Australia Pty Ltd",
  1096: "Grand Centrix GmbH",
  1097: "1UP USA.com llc",
  1098: "SHIMANO INC.",
  1099: "Nain Inc.",
  1100: "LifeStyle Lock, LLC",
  1101: "VEGA Grieshaber KG",
  1102: "Xtrava Inc.",
  1103: "TTS Tooltechnic Systems AG & Co. KG",
  1104: "Teenage Engineering AB",
  1105: "Tunstall Nordic AB",
  1106: "Svep Design Center AB",
  1107: "GreenPeak Technologies BV",
  1108: "Sphinx Electronics GmbH & Co KG",
  1109: "Atomation",
  1110: "Nemik Consulting Inc",
  1111: "RF INNOVATION",
  1112: "Mini Solution Co., Ltd.",
  1113: "Lumenetix, Inc",
  1114: "2048450 Ontario Inc",
  1115: "SPACEEK LTD",
  1116: "Delta T Corporation",
  1117: "Boston Scientific Corporation",
  1118: "Nuviz, Inc.",
  1119: "Real Time Automation, Inc.",
  1120: "Kolibree",
  1121: "vhf elektronik GmbH",
  1122: "Bonsai Systems GmbH",
  1123: "Fathom Systems Inc.",
  1124: "Bellman & Symfon",
  1125: "International Forte Group LLC",
  1126: "CycleLabs Solutions inc.",
  1127: "Codenex Oy",
  1128: "Kynesim Ltd",
  1129: "Palago AB",
  1130: "INSIGMA INC.",
  1131: "PMD Solutions",
  1132: "Qingdao Realtime Technology Co., Ltd.",
  1133: "BEGA Gantenbrink-Leuchten KG",
  1134: "Pambor Ltd.",
  65535: "SPECIAL USE/DEFAULT"
};
const exec = require$$1$1.exec;
const execSync = require$$1$1.execSync;
const path = require$$2$1;
const util = util$j;
const bluetoothVendors = bluetoothVendors$1;
const fs = require$$1$2;
let _platform = process.platform;
const _linux = _platform === "linux" || _platform === "android";
const _darwin = _platform === "darwin";
const _windows = _platform === "win32";
const _freebsd = _platform === "freebsd";
const _openbsd = _platform === "openbsd";
const _netbsd = _platform === "netbsd";
const _sunos = _platform === "sunos";
function parseBluetoothType(str) {
  let result2 = "";
  if (str.indexOf("keyboard") >= 0) {
    result2 = "Keyboard";
  }
  if (str.indexOf("mouse") >= 0) {
    result2 = "Mouse";
  }
  if (str.indexOf("trackpad") >= 0) {
    result2 = "Trackpad";
  }
  if (str.indexOf("speaker") >= 0) {
    result2 = "Speaker";
  }
  if (str.indexOf("headset") >= 0) {
    result2 = "Headset";
  }
  if (str.indexOf("phone") >= 0) {
    result2 = "Phone";
  }
  if (str.indexOf("macbook") >= 0) {
    result2 = "Computer";
  }
  if (str.indexOf("imac") >= 0) {
    result2 = "Computer";
  }
  if (str.indexOf("ipad") >= 0) {
    result2 = "Tablet";
  }
  if (str.indexOf("watch") >= 0) {
    result2 = "Watch";
  }
  if (str.indexOf("headphone") >= 0) {
    result2 = "Headset";
  }
  return result2;
}
function parseBluetoothManufacturer(str) {
  let result2 = str.split(" ")[0];
  str = str.toLowerCase();
  if (str.indexOf("apple") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("ipad") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("imac") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("iphone") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("magic mouse") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("magic track") >= 0) {
    result2 = "Apple";
  }
  if (str.indexOf("macbook") >= 0) {
    result2 = "Apple";
  }
  return result2;
}
function parseBluetoothVendor(str) {
  const id = parseInt(str);
  if (!isNaN(id)) return bluetoothVendors[id];
}
function parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {
  const result2 = {};
  result2.device = null;
  result2.name = util.getValue(lines, "name", "=");
  result2.manufacturer = null;
  result2.macDevice = macAddr1;
  result2.macHost = macAddr2;
  result2.batteryPercent = null;
  result2.type = parseBluetoothType(result2.name.toLowerCase());
  result2.connected = false;
  return result2;
}
function parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {
  const result2 = {};
  const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || "") + (bluetoothObject.device_name || "")).toLowerCase();
  result2.device = bluetoothObject.device_services || "";
  result2.name = bluetoothObject.device_name || "";
  result2.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothVendor(bluetoothObject.device_vendorID) || parseBluetoothManufacturer(bluetoothObject.device_name || "") || "";
  result2.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || "").toLowerCase().replace(/-/g, ":");
  result2.macHost = macAddr2;
  result2.batteryPercent = bluetoothObject.device_batteryPercent || null;
  result2.type = parseBluetoothType(typeStr);
  result2.connected = bluetoothObject.device_isconnected === "attrib_Yes" || false;
  return result2;
}
function parseWindowsBluetooth(lines) {
  const result2 = {};
  result2.device = null;
  result2.name = util.getValue(lines, "name", ":");
  result2.manufacturer = util.getValue(lines, "manufacturer", ":");
  result2.macDevice = null;
  result2.macHost = null;
  result2.batteryPercent = null;
  result2.type = parseBluetoothType(result2.name.toLowerCase());
  result2.connected = null;
  return result2;
}
function bluetoothDevices(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = [];
      if (_linux) {
        const btFiles = util.getFilesInPath("/var/lib/bluetooth/");
        btFiles.forEach((element) => {
          const filename = path.basename(element);
          const pathParts = element.split("/");
          const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;
          const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;
          if (filename === "info") {
            const infoFile = fs.readFileSync(element, { encoding: "utf8" }).split("\n");
            result2.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));
          }
        });
        try {
          const hdicon = execSync("hcitool con", util.execOptsLinux).toString().toLowerCase();
          for (let i = 0; i < result2.length; i++) {
            if (result2[i].macDevice && result2[i].macDevice.length > 10 && hdicon.indexOf(result2[i].macDevice.toLowerCase()) >= 0) {
              result2[i].connected = true;
            }
          }
        } catch (e) {
          util.noop();
        }
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_darwin) {
        let cmd = "system_profiler SPBluetoothDataType -json";
        exec(cmd, function(error, stdout) {
          if (!error) {
            try {
              const outObj = JSON.parse(stdout.toString());
              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_title"] && outObj.SPBluetoothDataType[0]["device_title"].length) {
                let macAddr2 = null;
                if (outObj.SPBluetoothDataType[0]["local_device_title"] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {
                  macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ":");
                }
                outObj.SPBluetoothDataType[0]["device_title"].forEach((element) => {
                  const obj = element;
                  const objKey = Object.keys(obj);
                  if (objKey && objKey.length === 1) {
                    const innerObject = obj[objKey[0]];
                    innerObject.device_name = objKey[0];
                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                    result2.push(bluetoothDevice);
                  }
                });
              }
              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_connected"] && outObj.SPBluetoothDataType[0]["device_connected"].length) {
                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                outObj.SPBluetoothDataType[0]["device_connected"].forEach((element) => {
                  const obj = element;
                  const objKey = Object.keys(obj);
                  if (objKey && objKey.length === 1) {
                    const innerObject = obj[objKey[0]];
                    innerObject.device_name = objKey[0];
                    innerObject.device_isconnected = "attrib_Yes";
                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                    result2.push(bluetoothDevice);
                  }
                });
              }
              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_not_connected"] && outObj.SPBluetoothDataType[0]["device_not_connected"].length) {
                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                outObj.SPBluetoothDataType[0]["device_not_connected"].forEach((element) => {
                  const obj = element;
                  const objKey = Object.keys(obj);
                  if (objKey && objKey.length === 1) {
                    const innerObject = obj[objKey[0]];
                    innerObject.device_name = objKey[0];
                    innerObject.device_isconnected = "attrib_No";
                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                    result2.push(bluetoothDevice);
                  }
                });
              }
            } catch (e) {
              util.noop();
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_windows) {
        util.powerShell("Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl").then((stdout, error) => {
          if (!error) {
            const parts = stdout.toString().split(/\n\s*\n/);
            parts.forEach((part) => {
              if (util.getValue(part.split("\n"), "PNPClass", ":") === "Bluetooth") {
                result2.push(parseWindowsBluetooth(part.split("\n")));
              }
            });
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_freebsd || _netbsd || _openbsd || _sunos) {
        resolve(null);
      }
    });
  });
}
bluetooth.bluetoothDevices = bluetoothDevices;
(function(exports) {
  const lib_version = require$$0$1.version;
  const util2 = util$j;
  const system2 = system$1;
  const osInfo2 = osinfo;
  const cpu2 = cpu$1;
  const memory$1 = memory;
  const battery$1 = battery;
  const graphics2 = graphics$1;
  const filesystem$1 = filesystem;
  const network$1 = network;
  const wifi$1 = wifi;
  const processes2 = processes$1;
  const users2 = users$1;
  const internet$1 = internet;
  const docker$1 = docker;
  const vbox = virtualbox;
  const printer2 = printer$1;
  const usb2 = usb$1;
  const audio2 = audio$1;
  const bluetooth$1 = bluetooth;
  let _platform2 = process.platform;
  const _windows2 = _platform2 === "win32";
  const _freebsd2 = _platform2 === "freebsd";
  const _openbsd2 = _platform2 === "openbsd";
  const _netbsd2 = _platform2 === "netbsd";
  const _sunos2 = _platform2 === "sunos";
  if (_windows2) {
    util2.getCodepage();
    util2.getPowershell();
  }
  function version2() {
    return lib_version;
  }
  function getStaticData(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = {};
        data.version = version2();
        Promise.all([
          system2.system(),
          system2.bios(),
          system2.baseboard(),
          system2.chassis(),
          osInfo2.osInfo(),
          osInfo2.uuid(),
          osInfo2.versions(),
          cpu2.cpu(),
          cpu2.cpuFlags(),
          graphics2.graphics(),
          network$1.networkInterfaces(),
          memory$1.memLayout(),
          filesystem$1.diskLayout()
        ]).then((res) => {
          data.system = res[0];
          data.bios = res[1];
          data.baseboard = res[2];
          data.chassis = res[3];
          data.os = res[4];
          data.uuid = res[5];
          data.versions = res[6];
          data.cpu = res[7];
          data.cpu.flags = res[8];
          data.graphics = res[9];
          data.net = res[10];
          data.memLayout = res[11];
          data.diskLayout = res[12];
          if (callback) {
            callback(data);
          }
          resolve(data);
        });
      });
    });
  }
  function getDynamicData(srv, iface, callback) {
    if (util2.isFunction(iface)) {
      callback = iface;
      iface = "";
    }
    if (util2.isFunction(srv)) {
      callback = srv;
      srv = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        iface = iface || network$1.getDefaultNetworkInterface();
        srv = srv || "";
        let functionProcessed = function() {
          let totalFunctions = 15;
          if (_windows2) {
            totalFunctions = 13;
          }
          if (_freebsd2 || _openbsd2 || _netbsd2) {
            totalFunctions = 11;
          }
          if (_sunos2) {
            totalFunctions = 6;
          }
          return function() {
            if (--totalFunctions === 0) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          };
        }();
        let data = {};
        data.time = osInfo2.time();
        data.node = process.versions.node;
        data.v8 = process.versions.v8;
        cpu2.cpuCurrentSpeed().then((res) => {
          data.cpuCurrentSpeed = res;
          functionProcessed();
        });
        users2.users().then((res) => {
          data.users = res;
          functionProcessed();
        });
        processes2.processes().then((res) => {
          data.processes = res;
          functionProcessed();
        });
        cpu2.currentLoad().then((res) => {
          data.currentLoad = res;
          functionProcessed();
        });
        if (!_sunos2) {
          cpu2.cpuTemperature().then((res) => {
            data.temp = res;
            functionProcessed();
          });
        }
        if (!_openbsd2 && !_freebsd2 && !_netbsd2 && !_sunos2) {
          network$1.networkStats(iface).then((res) => {
            data.networkStats = res;
            functionProcessed();
          });
        }
        if (!_sunos2) {
          network$1.networkConnections().then((res) => {
            data.networkConnections = res;
            functionProcessed();
          });
        }
        memory$1.mem().then((res) => {
          data.mem = res;
          functionProcessed();
        });
        if (!_sunos2) {
          battery$1().then((res) => {
            data.battery = res;
            functionProcessed();
          });
        }
        if (!_sunos2) {
          processes2.services(srv).then((res) => {
            data.services = res;
            functionProcessed();
          });
        }
        if (!_sunos2) {
          filesystem$1.fsSize().then((res) => {
            data.fsSize = res;
            functionProcessed();
          });
        }
        if (!_windows2 && !_openbsd2 && !_freebsd2 && !_netbsd2 && !_sunos2) {
          filesystem$1.fsStats().then((res) => {
            data.fsStats = res;
            functionProcessed();
          });
        }
        if (!_windows2 && !_openbsd2 && !_freebsd2 && !_netbsd2 && !_sunos2) {
          filesystem$1.disksIO().then((res) => {
            data.disksIO = res;
            functionProcessed();
          });
        }
        if (!_openbsd2 && !_freebsd2 && !_netbsd2 && !_sunos2) {
          wifi$1.wifiNetworks().then((res) => {
            data.wifiNetworks = res;
            functionProcessed();
          });
        }
        internet$1.inetLatency().then((res) => {
          data.inetLatency = res;
          functionProcessed();
        });
      });
    });
  }
  function getAllData(srv, iface, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = {};
        if (iface && util2.isFunction(iface) && !callback) {
          callback = iface;
          iface = "";
        }
        if (srv && util2.isFunction(srv) && !iface && !callback) {
          callback = srv;
          srv = "";
          iface = "";
        }
        getStaticData().then((res) => {
          data = res;
          getDynamicData(srv, iface).then((res2) => {
            for (let key2 in res2) {
              if ({}.hasOwnProperty.call(res2, key2)) {
                data[key2] = res2[key2];
              }
            }
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        });
      });
    });
  }
  function get(valueObject, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const allPromises = Object.keys(valueObject).filter((func) => ({}).hasOwnProperty.call(exports, func)).map((func) => {
          const params = valueObject[func].substring(valueObject[func].lastIndexOf("(") + 1, valueObject[func].lastIndexOf(")"));
          let funcWithoutParams = func.indexOf(")") >= 0 ? func.split(")")[1].trim() : func;
          funcWithoutParams = func.indexOf("|") >= 0 ? func.split("|")[0].trim() : funcWithoutParams;
          if (params) {
            return exports[funcWithoutParams](params);
          } else {
            return exports[funcWithoutParams]("");
          }
        });
        Promise.all(allPromises).then((data) => {
          const result2 = {};
          let i = 0;
          for (let key2 in valueObject) {
            if ({}.hasOwnProperty.call(valueObject, key2) && {}.hasOwnProperty.call(exports, key2) && data.length > i) {
              if (valueObject[key2] === "*" || valueObject[key2] === "all") {
                result2[key2] = data[i];
              } else {
                let keys = valueObject[key2];
                let filter = "";
                let filterParts = [];
                if (keys.indexOf(")") >= 0) {
                  keys = keys.split(")")[1].trim();
                }
                if (keys.indexOf("|") >= 0) {
                  filter = keys.split("|")[1].trim();
                  filterParts = filter.split(":");
                  keys = keys.split("|")[0].trim();
                }
                keys = keys.replace(/,/g, " ").replace(/ +/g, " ").split(" ");
                if (data[i]) {
                  if (Array.isArray(data[i])) {
                    const partialArray = [];
                    data[i].forEach((element) => {
                      let partialRes = {};
                      if (keys.length === 1 && (keys[0] === "*" || keys[0] === "all")) {
                        partialRes = element;
                      } else {
                        keys.forEach((k) => {
                          if ({}.hasOwnProperty.call(element, k)) {
                            partialRes[k] = element[k];
                          }
                        });
                      }
                      if (filter && filterParts.length === 2) {
                        if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {
                          const val = partialRes[filterParts[0].trim()];
                          if (typeof val == "number") {
                            if (val === parseFloat(filterParts[1].trim())) {
                              partialArray.push(partialRes);
                            }
                          } else if (typeof val == "string") {
                            if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {
                              partialArray.push(partialRes);
                            }
                          }
                        }
                      } else {
                        partialArray.push(partialRes);
                      }
                    });
                    result2[key2] = partialArray;
                  } else {
                    const partialRes = {};
                    keys.forEach((k) => {
                      if ({}.hasOwnProperty.call(data[i], k)) {
                        partialRes[k] = data[i][k];
                      }
                    });
                    result2[key2] = partialRes;
                  }
                } else {
                  result2[key2] = {};
                }
              }
              i++;
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      });
    });
  }
  function observe(valueObject, interval, callback) {
    let _data = null;
    const result2 = setInterval(() => {
      get(valueObject).then((data) => {
        if (JSON.stringify(_data) !== JSON.stringify(data)) {
          _data = Object.assign({}, data);
          callback(data);
        }
      });
    }, interval);
    return result2;
  }
  exports.version = version2;
  exports.system = system2.system;
  exports.bios = system2.bios;
  exports.baseboard = system2.baseboard;
  exports.chassis = system2.chassis;
  exports.time = osInfo2.time;
  exports.osInfo = osInfo2.osInfo;
  exports.versions = osInfo2.versions;
  exports.shell = osInfo2.shell;
  exports.uuid = osInfo2.uuid;
  exports.cpu = cpu2.cpu;
  exports.cpuFlags = cpu2.cpuFlags;
  exports.cpuCache = cpu2.cpuCache;
  exports.cpuCurrentSpeed = cpu2.cpuCurrentSpeed;
  exports.cpuTemperature = cpu2.cpuTemperature;
  exports.currentLoad = cpu2.currentLoad;
  exports.fullLoad = cpu2.fullLoad;
  exports.mem = memory$1.mem;
  exports.memLayout = memory$1.memLayout;
  exports.battery = battery$1;
  exports.graphics = graphics2.graphics;
  exports.fsSize = filesystem$1.fsSize;
  exports.fsOpenFiles = filesystem$1.fsOpenFiles;
  exports.blockDevices = filesystem$1.blockDevices;
  exports.fsStats = filesystem$1.fsStats;
  exports.disksIO = filesystem$1.disksIO;
  exports.diskLayout = filesystem$1.diskLayout;
  exports.networkInterfaceDefault = network$1.networkInterfaceDefault;
  exports.networkGatewayDefault = network$1.networkGatewayDefault;
  exports.networkInterfaces = network$1.networkInterfaces;
  exports.networkStats = network$1.networkStats;
  exports.networkConnections = network$1.networkConnections;
  exports.wifiNetworks = wifi$1.wifiNetworks;
  exports.wifiInterfaces = wifi$1.wifiInterfaces;
  exports.wifiConnections = wifi$1.wifiConnections;
  exports.services = processes2.services;
  exports.processes = processes2.processes;
  exports.processLoad = processes2.processLoad;
  exports.users = users2.users;
  exports.inetChecksite = internet$1.inetChecksite;
  exports.inetLatency = internet$1.inetLatency;
  exports.dockerInfo = docker$1.dockerInfo;
  exports.dockerImages = docker$1.dockerImages;
  exports.dockerContainers = docker$1.dockerContainers;
  exports.dockerContainerStats = docker$1.dockerContainerStats;
  exports.dockerContainerProcesses = docker$1.dockerContainerProcesses;
  exports.dockerVolumes = docker$1.dockerVolumes;
  exports.dockerAll = docker$1.dockerAll;
  exports.vboxInfo = vbox.vboxInfo;
  exports.printer = printer2.printer;
  exports.usb = usb2.usb;
  exports.audio = audio2.audio;
  exports.bluetoothDevices = bluetooth$1.bluetoothDevices;
  exports.getStaticData = getStaticData;
  exports.getDynamicData = getDynamicData;
  exports.getAllData = getAllData;
  exports.get = get;
  exports.observe = observe;
  exports.powerShellStart = util2.powerShellStart;
  exports.powerShellRelease = util2.powerShellRelease;
})(lib$1);
const si = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
var dist = {};
var darwin = {};
var constants = {};
Object.defineProperty(constants, "__esModule", { value: true });
constants.Constants = void 0;
var Constants = (
  /** @class */
  function() {
    function Constants2() {
    }
    Constants2.WINDOWS_COMMAND = "wmic logicaldisk get Caption,FreeSpace,Size,VolumeSerialNumber,Description  /format:list";
    Constants2.LINUX_COMMAND = "df -P | awk 'NR > 1'";
    Constants2.DARWIN_COMMAND = "df -P | awk 'NR > 1'";
    return Constants2;
  }()
);
constants.Constants = Constants;
var drive = {};
Object.defineProperty(drive, "__esModule", { value: true });
var Drive = (
  /** @class */
  function() {
    function Drive2(filesystem2, blocks, used, available, capacity, mounted) {
      this._filesystem = filesystem2;
      this._blocks = blocks;
      this._used = used;
      this._available = available;
      this._capacity = capacity;
      this._mounted = mounted;
    }
    Object.defineProperty(Drive2.prototype, "filesystem", {
      /**
       * Drive filesystem.
       *
       * @return Gets drive filesystem.
       */
      get: function() {
        return this._filesystem;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Drive2.prototype, "blocks", {
      /**
       * Blocks associated to disk.
       *
       * @return Gets blocks associated to disk.
       */
      get: function() {
        return this._blocks;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Drive2.prototype, "used", {
      /**
       * Used disk space.
       *
       * @return Gets used disk space.
       */
      get: function() {
        return this._used;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Drive2.prototype, "available", {
      /**
       * Available disk space.
       *
       * @return Gets available disk space.
       */
      get: function() {
        return this._available;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Drive2.prototype, "capacity", {
      /**
       * Disk capacity.
       *
       * @return Gets disk capacity.
       */
      get: function() {
        return this._capacity;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Drive2.prototype, "mounted", {
      /**
       * Indicates the mount point of the disk.
       *
       * @return Gets the mount point of the disk.
       */
      get: function() {
        return this._mounted;
      },
      enumerable: false,
      configurable: true
    });
    return Drive2;
  }()
);
drive.default = Drive;
var utils = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result2, mod, k);
  }
  __setModuleDefault(result2, mod);
  return result2;
};
Object.defineProperty(utils, "__esModule", { value: true });
utils.Utils = void 0;
var os = __importStar(os$a);
var child_process_1 = require$$1$1;
var Utils = (
  /** @class */
  function() {
    function Utils2() {
    }
    Utils2.detectPlatform = function() {
      return os.platform().toLowerCase();
    };
    Utils2.chcp = function() {
      return child_process_1.execSync("chcp").toString().split(":")[1].trim();
    };
    Utils2.execute = function(command) {
      return child_process_1.execSync(command, { windowsHide: true, encoding: "buffer" });
    };
    return Utils2;
  }()
);
utils.Utils = Utils;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(darwin, "__esModule", { value: true });
darwin.Darwin = void 0;
var constants_1$2 = constants;
var drive_1$2 = __importDefault$2(drive);
var utils_1$3 = utils;
var Darwin = (
  /** @class */
  function() {
    function Darwin2() {
    }
    Darwin2.run = function() {
      var drives = [];
      var buffer2 = utils_1$3.Utils.execute(constants_1$2.Constants.DARWIN_COMMAND);
      var lines = buffer2.toString().split("\n");
      lines.forEach(function(value, index, array) {
        if (value !== "") {
          var line = value.replace(/ +(?= )/g, "");
          var tokens = line.split(" ");
          var d = new drive_1$2.default(tokens[0], isNaN(parseFloat(tokens[1])) ? 0 : +tokens[1], isNaN(parseFloat(tokens[2])) ? 0 : +tokens[2], isNaN(parseFloat(tokens[3])) ? 0 : +tokens[3], tokens[4], tokens[5]);
          drives.push(d);
        }
      });
      return drives;
    };
    return Darwin2;
  }()
);
darwin.Darwin = Darwin;
var linux = {};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(linux, "__esModule", { value: true });
linux.Linux = void 0;
var constants_1$1 = constants;
var drive_1$1 = __importDefault$1(drive);
var utils_1$2 = utils;
var Linux = (
  /** @class */
  function() {
    function Linux2() {
    }
    Linux2.run = function() {
      var drives = [];
      var buffer2 = utils_1$2.Utils.execute(constants_1$1.Constants.LINUX_COMMAND);
      var lines = buffer2.toString().split("\n");
      lines.forEach(function(value) {
        if (value !== "") {
          var line = value.replace(/ +(?= )/g, "");
          var tokens = line.split(" ");
          var d = new drive_1$1.default(tokens[0], isNaN(parseFloat(tokens[1])) ? 0 : +tokens[1], isNaN(parseFloat(tokens[2])) ? 0 : +tokens[2], isNaN(parseFloat(tokens[3])) ? 0 : +tokens[3], tokens[4], tokens[5]);
          drives.push(d);
        }
      });
      return drives;
    };
    return Linux2;
  }()
);
linux.Linux = Linux;
var windows = {};
var lib = { exports: {} };
var buffer = require$$0$3;
var Buffer2 = buffer.Buffer;
var safer = {};
var key;
for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === "SlowBuffer" || key === "Buffer") continue;
  safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for (key in Buffer2) {
  if (!Buffer2.hasOwnProperty(key)) continue;
  if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
  Safer[key] = Buffer2[key];
}
safer.Buffer.prototype = Buffer2.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer2(value, encodingOrOffset, length);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer2(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch (e) {
  }
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var bomHandling = {};
var BOMChar = "\uFEFF";
bomHandling.PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper(encoder, options) {
  this.encoder = encoder;
  this.addBOM = true;
}
PrependBOMWrapper.prototype.write = function(str) {
  if (this.addBOM) {
    str = BOMChar + str;
    this.addBOM = false;
  }
  return this.encoder.write(str);
};
PrependBOMWrapper.prototype.end = function() {
  return this.encoder.end();
};
bomHandling.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
  this.decoder = decoder;
  this.pass = false;
  this.options = options || {};
}
StripBOMWrapper.prototype.write = function(buf) {
  var res = this.decoder.write(buf);
  if (this.pass || !res)
    return res;
  if (res[0] === BOMChar) {
    res = res.slice(1);
    if (typeof this.options.stripBOM === "function")
      this.options.stripBOM();
  }
  this.pass = true;
  return res;
};
StripBOMWrapper.prototype.end = function() {
  return this.decoder.end();
};
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer3 = safer_1.Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer3.from("eda0bdedb2a9", "hex").toString() !== "ð©") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$3.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer3.isBuffer(buf)) {
      buf = Buffer3.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer3.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer3.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer3.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer3.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer3 = safer_1.Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer3.from(str, "ucs2");
    var dst = Buffer3.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer3.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer3.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++)
        overflow.push(src[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer3 = safer_1.Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer3.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer3.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer3 = safer_1.Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer3.from(str.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer3.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer3.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer3.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer3.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer3.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer3 = safer_1.Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer3.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer3.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer3.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer3.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": "ÃÄÄÃÄÃÃÃ¡ÄÄÃ¤ÄÄÄÃ©Å¹ÅºÄÃ­ÄÄÄÄÃ³ÄÃ´Ã¶ÃµÃºÄÄÃ¼â Â°ÄÂ£Â§â¢Â¶ÃÂ®Â©â¢ÄÂ¨â Ä£Ä®Ä¯Äªâ¤â¥Ä«Ä¶ââÅÄ»Ä¼Ä½Ä¾Ä¹ÄºÅÅÅÂ¬âÅÅâÂ«Â»â¦Â ÅÅÃÅÅââââââÃ·âÅÅÅÅâ¹âºÅÅÅÅ ââÅ¡ÅÅÃÅ¤Å¥ÃÅ½Å¾ÅªÃÃÅ«Å®ÃÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë"
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": "ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÐÑÐÑÐÑÐÑÂ°âÂ·âââ¬â Â "
    },
    "mik": {
      "type": "_sbcs",
      "chars": "ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑââ´â¬âââ¼â£ââââ©â¦â ââ¬ââââââ¤âÂ§âââââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "cp720": {
      "type": "_sbcs",
      "chars": "ÂÂÃ©Ã¢ÂÃ ÂÃ§ÃªÃ«Ã¨Ã¯Ã®ÂÂÂÂÙÙÃ´Â¤ÙÃ»Ã¹Ø¡Ø¢Ø£Ø¤Â£Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµÂ«Â»âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââØ¶Ø·Ø¸Ø¹ØºÙÂµÙÙÙÙÙÙÙÙÙâ¡ÙÙÙÙÙÙâÂ°âÂ·ââ¿Â²â Â "
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": "â¬ï¿½ï¿½ï¿½ï¿½â¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½âââââ¢ââï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹ï¿½ï¿½ï¿½ï¿½"
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âï¿½ââ¦â â¡ï¿½â°Å â¹ÅÅ¤Å½Å¹ï¿½âââââ¢ââï¿½â¢Å¡âºÅÅ¥Å¾ÅºÂ ËËÅÂ¤ÄÂ¦Â§Â¨Â©ÅÂ«Â¬Â­Â®Å»Â°Â±ËÅÂ´ÂµÂ¶Â·Â¸ÄÅÂ»Ä½ËÄ¾Å¼ÅÃÃÄÃÄ¹ÄÃÄÃÄÃÄÃÃÄÄÅÅÃÃÅÃÃÅÅ®ÃÅ°ÃÃÅ¢ÃÅÃ¡Ã¢ÄÃ¤ÄºÄÃ§ÄÃ©ÄÃ«ÄÃ­Ã®ÄÄÅÅÃ³Ã´ÅÃ¶Ã·ÅÅ¯ÃºÅ±Ã¼Ã½Å£Ë"
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": "ÐÐâÑââ¦â â¡â¬â°Ðâ¹ÐÐÐÐÑâââââ¢ââï¿½â¢ÑâºÑÑÑÑÂ ÐÑÐÂ¤ÒÂ¦Â§ÐÂ©ÐÂ«Â¬Â­Â®ÐÂ°Â±ÐÑÒÂµÂ¶Â·ÑâÑÂ»ÑÐÑÑÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ"
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âÆââ¦â â¡Ëâ°Å â¹Åï¿½Å½ï¿½ï¿½âââââ¢ââËâ¢Å¡âºÅï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âÆââ¦â â¡ï¿½â°ï¿½â¹ï¿½ï¿½ï¿½ï¿½ï¿½âââââ¢ââï¿½â¢ï¿½âºï¿½ï¿½ï¿½ï¿½Â ÎÎÂ£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®âÂ°Â±Â²Â³ÎÂµÂ¶Â·ÎÎÎÂ»ÎÂ½ÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿ÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏï¿½"
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âÆââ¦â â¡Ëâ°Å â¹Åï¿½ï¿½ï¿½ï¿½âââââ¢ââËâ¢Å¡âºÅï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÄÃÃÃÃÃÃÃÃÃÃÃÃÄ°ÅÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅÃ¿"
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âÆââ¦â â¡Ëâ°ï¿½â¹ï¿½ï¿½ï¿½ï¿½ï¿½âââââ¢ââËâ¢ï¿½âºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£âªÂ¥Â¦Â§Â¨Â©ÃÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×××××°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××××××××××××××××× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½ââï¿½"
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": "â¬Ù¾âÆââ¦â â¡Ëâ°Ù¹â¹ÅÚÚÚÚ¯âââââ¢ââÚ©â¢ÚâºÅââÚºÂ ØÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ØÂ»Â¼Â½Â¾ØÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶ÃØ·Ø¸Ø¹ØºÙÙÙÙÃ ÙÃ¢ÙÙÙÙÃ§Ã¨Ã©ÃªÃ«ÙÙÃ®Ã¯ÙÙÙÙÃ´ÙÙÃ·ÙÃ¹ÙÃ»Ã¼ââÛ"
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âï¿½ââ¦â â¡ï¿½â°ï¿½â¹ï¿½Â¨ËÂ¸ï¿½âââââ¢ââï¿½â¢ï¿½âºï¿½Â¯Ëï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§ÃÂ©ÅÂ«Â¬Â­Â®ÃÂ°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹ÅÂ»Â¼Â½Â¾Ã¦ÄÄ®ÄÄÃÃÄÄÄÃÅ¹ÄÄ¢Ä¶ÄªÄ»Å ÅÅÃÅÃÃÃÅ²ÅÅÅªÃÅ»Å½ÃÄÄ¯ÄÄÃ¤Ã¥ÄÄÄÃ©ÅºÄÄ£Ä·Ä«Ä¼Å¡ÅÅÃ³ÅÃµÃ¶Ã·Å³ÅÅÅ«Ã¼Å¼Å¾Ë"
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": "â¬ï¿½âÆââ¦â â¡Ëâ°ï¿½â¹Åï¿½ï¿½ï¿½ï¿½âââââ¢ââËâ¢ï¿½âºÅï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÄÃÃÃÃÃÃÃÃÌÃÃÃÄÃÌÃÃÆ ÃÃÃÃÃÃÃÆ¯ÌÃÃ Ã¡Ã¢ÄÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯ÄÃ±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â«Ã¿"
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÄËÅÂ¤Ä½ÅÂ§Â¨Å ÅÅ¤Å¹Â­Å½Å»Â°ÄËÅÂ´Ä¾ÅËÂ¸Å¡ÅÅ¥ÅºËÅ¾Å¼ÅÃÃÄÃÄ¹ÄÃÄÃÄÃÄÃÃÄÄÅÅÃÃÅÃÃÅÅ®ÃÅ°ÃÃÅ¢ÃÅÃ¡Ã¢ÄÃ¤ÄºÄÃ§ÄÃ©ÄÃ«ÄÃ­Ã®ÄÄÅÅÃ³Ã´ÅÃ¶Ã·ÅÅ¯ÃºÅ±Ã¼Ã½Å£Ë"
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Ä¦ËÂ£Â¤ï¿½Ä¤Â§Â¨Ä°ÅÄÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅÄÄµÂ½ï¿½Å¼ÃÃÃï¿½ÃÄÄÃÃÃÃÃÃÃÃÃï¿½ÃÃÃÃÄ ÃÃÄÃÃÃÃÅ¬ÅÃÃ Ã¡Ã¢ï¿½Ã¤ÄÄÃ§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË"
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÄÄ¸ÅÂ¤Ä¨Ä»Â§Â¨Å ÄÄ¢Å¦Â­Å½Â¯Â°ÄËÅÂ´Ä©Ä¼ËÂ¸Å¡ÄÄ£Å§ÅÅ¾ÅÄÃÃÃÃÃÃÄ®ÄÃÄÃÄÃÃÄªÄÅÅÄ¶ÃÃÃÃÃÅ²ÃÃÃÅ¨ÅªÃÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©ÄÃ«ÄÃ­Ã®Ä«ÄÅÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë"
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÐÐÐÐÐÐÐÐÐÐÐÐÂ­ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑâÑÑÑÑÑÑÑÑÑÑÑÑÂ§ÑÑ"
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Øï¿½ï¿½ï¿½Øï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½ÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ââÂ£â¬â¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½âÂ°Â±Â²Â³ÎÎÎÂ·ÎÎÎÂ»ÎÂ½ÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿ÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏï¿½"
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÃÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â××××××××××××××××× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½ââï¿½"
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÄÃÃÃÃÃÃÃÃÃÃÃÃÄ°ÅÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅÃ¿"
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÄÄÄ¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅÂ°ÄÄÄ£Ä«Ä©Ä·Â·Ä¼ÄÅ¡Å§Å¾âÅ«ÅÄÃÃÃÃÃÃÄ®ÄÃÄÃÄÃÃÃÃÅÅÃÃÃÃÅ¨ÃÅ²ÃÃÃÃÃÃÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©ÄÃ«ÄÃ­Ã®Ã¯Ã°ÅÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ âÂ¢Â£Â¤âÂ¦Â§ÃÂ©ÅÂ«Â¬Â­Â®ÃÂ°Â±Â²Â³âÂµÂ¶Â·Ã¸Â¹ÅÂ»Â¼Â½Â¾Ã¦ÄÄ®ÄÄÃÃÄÄÄÃÅ¹ÄÄ¢Ä¶ÄªÄ»Å ÅÅÃÅÃÃÃÅ²ÅÅÅªÃÅ»Å½ÃÄÄ¯ÄÄÃ¤Ã¥ÄÄÄÃ©ÅºÄÄ£Ä·Ä«Ä¼Å¡ÅÅÃ³ÅÃµÃ¶Ã·Å³ÅÅÅ«Ã¼Å¼Å¾â"
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ á¸á¸Â£ÄÄá¸Â§áºÂ©áºá¸á»²Â­Â®Å¸á¸á¸Ä Ä¡á¹á¹Â¶á¹áºá¹áºá¹ á»³áºáºá¹¡ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÅ´ÃÃÃÃÃÃá¹ªÃÃÃÃÃÃÅ¶ÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Â¡Â¢Â£â¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»ÅÅÅ¸Â¿ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÄÄÅâ¬âÅ Â§Å¡Â©ÈÂ«Å¹Â­ÅºÅ»Â°Â±ÄÅÅ½âÂ¶Â·Å¾ÄÈÂ»ÅÅÅ¸Å¼ÃÃÃÄÃÄÃÃÃÃÃÃÃÃÃÃÄÅÃÃÃÅÃÅÅ°ÃÃÃÃÄÈÃÃ Ã¡Ã¢ÄÃ¤ÄÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄÅÃ²Ã³Ã´ÅÃ¶ÅÅ±Ã¹ÃºÃ»Ã¼ÄÈÃ¿"
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬ÃÃÃÃ¦ÃÃ´Ã¶Ã²Ã»Ã¹Ã¿ÃÃÂ¢Â£Â¥â§ÆÃ¡Ã­Ã³ÃºÃ±ÃÂªÂºÂ¿âÂ¬Â½Â¼Â¡Â«Â»âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": "ÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿ÏÏÏÏÏÏÏÏÏâââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÏÎ¬Î­Î®ÏÎ¯ÏÏÏÏÎÎÎÎÎÎÎÂ±â¥â¤ÎªÎ«Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": "ÄÃ¼Ã©ÄÃ¤Ä£Ã¥ÄÅÄÅÅÄ«Å¹ÃÃÃÃ¦ÃÅÃ¶Ä¢Â¢ÅÅÃÃÃ¸Â£ÃÃÂ¤ÄÄªÃ³Å»Å¼ÅºâÂ¦Â©Â®Â¬Â½Â¼ÅÂ«Â»âââââ¤ÄÄÄÄâ£âââÄ®Å âââ´â¬âââ¼Å²Åªâââ©â¦â ââ¬Å½ÄÄÄÄÄ¯Å¡Å³Å«Å¾âââââââÃÃÅÅÃµÃÂµÅÄ¶Ä·Ä»Ä¼ÅÄÅâÂ­Â±âÂ¾Â¶Â§Ã·âÂ°âÂ·Â¹Â³Â²â Â "
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬ÃÃÃÃ¦ÃÃ´Ã¶Ã²Ã»Ã¹Ã¿ÃÃÃ¸Â£ÃÃÆÃ¡Ã­Ã³ÃºÃ±ÃÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»âââââ¤ÃÃÃÂ©â£âââÂ¢Â¥âââ´â¬âââ¼Ã£Ãâââ©â¦â ââ¬Â¤Ã°ÃÃÃÃÄ±ÃÃÃââââÂ¦ÃâÃÃÃÃÃµÃÂµÃ¾ÃÃÃÃÃ½ÃÂ¯Â´Â­Â±âÂ¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â Â "
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Å¯ÄÃ§ÅÃ«ÅÅÃ®Å¹ÃÄÃÄ¹ÄºÃ´Ã¶Ä½Ä¾ÅÅÃÃÅ¤Å¥ÅÃÄÃ¡Ã­Ã³ÃºÄÄÅ½Å¾ÄÄÂ¬ÅºÄÅÂ«Â»âââââ¤ÃÃÄÅâ£âââÅ»Å¼âââ´â¬âââ¼ÄÄâââ©â¦â ââ¬Â¤ÄÄÄÃÄÅÃÃÄââââÅ¢Å®âÃÃÃÅÅÅÅ Å¡ÅÃÅÅ°Ã½ÃÅ£Â´Â­ËËËËÂ§Ã·Â¸Â°Â¨ËÅ±ÅÅâ Â "
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": "ÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐÑÐ®ÑÐªÐ°ÐÐ±ÐÑÐ¦Ð´ÐÐµÐÑÐ¤Ð³ÐÂ«Â»âââââ¤ÑÐ¥Ð¸Ðâ£âââÐ¹Ðâââ´â¬âââ¼ÐºÐâââ©â¦â ââ¬Â¤Ð»ÐÐ¼ÐÐ½ÐÐ¾ÐÐ¿ââââÐÑâÐ¯ÑÐ ÑÐ¡ÑÐ¢ÑÐ£Ð¶ÐÐ²ÐÑÐ¬âÂ­ÑÐ«Ð·ÐÑÐ¨ÑÐ­ÑÐ©ÑÐ§Â§â Â "
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": "××××××××××××××××× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ãï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»âââââ¤ï¿½ï¿½ï¿½Â©â£âââÂ¢Â¥âââ´â¬âââ¼ï¿½ï¿½âââ©â¦â ââ¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ââââÂ¦ï¿½âï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±âÂ¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â Â "
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±ÃÃÃÃ¦ÃÃ´Ã¶Ã²Ã»Ã¹Ä°ÃÃÃ¸Â£ÃÅÅÃ¡Ã­Ã³ÃºÃ±ÃÄÄÂ¿Â®Â¬Â½Â¼Â¡Â«Â»âââââ¤ÃÃÃÂ©â£âââÂ¢Â¥âââ´â¬âââ¼Ã£Ãâââ©â¦â ââ¬Â¤ÂºÂªÃÃÃï¿½ÃÃÃââââÂ¦ÃâÃÃÃÃÃµÃÂµï¿½ÃÃÃÃÃ¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â Â "
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬ÃÃÃÃ¦ÃÃ´Ã¶Ã²Ã»Ã¹Ã¿ÃÃÃ¸Â£ÃÃÆÃ¡Ã­Ã³ÃºÃ±ÃÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»âââââ¤ÃÃÃÂ©â£âââÂ¢Â¥âââ´â¬âââ¼Ã£Ãâââ©â¦â ââ¬Â¤Ã°ÃÃÃÃâ¬ÃÃÃââââÂ¦ÃâÃÃÃÃÃµÃÂµÃ¾ÃÃÃÃÃ½ÃÂ¯Â´Â­Â±âÂ¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â Â "
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃÃ¨ÃÃÃ¬ÃÃÃÃÃÃ´ÃµÃ²ÃÃ¹ÃÃÃÂ¢Â£Ãâ§ÃÃ¡Ã­Ã³ÃºÃ±ÃÂªÂºÂ¿ÃÂ¬Â½Â¼Â¡Â«Â»âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃÃÃÃÃ¦ÃÃ´Ã¶Ã¾Ã»ÃÃ½ÃÃÃ¸Â£Ãâ§ÆÃ¡Ã­Ã³ÃºÃÃÃÃÂ¿âÂ¬Â½Â¼Â¡Â«Â»âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": "××××××××××××××××× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â§ÆÃ¡Ã­Ã³ÃºÃ±ÃÂªÂºÂ¿âÂ¬Â½Â¼Â¡Â«Â»âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢ÃÃ Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®âÃÂ§ÃÃÃÃ´ÃÃÃ»Ã¹Â¤ÃÃÂ¢Â£ÃÃÆÂ¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃâÂ¬Â½Â¼Â¾Â«Â»âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·ââââââ¼â¤â¬ââ´ââââÎ²âÏÂ±Â½Â¼âÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïºÂ£Â¤ïºï¿½ï¿½ïºïºïºïºØïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»Øïº±ïºµïº¹ØÂ¢ïºïºïºïºï»ïºïºïºïºïºïºïºïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»ï»ï»Â¦Â¬Ã·Ãï»Ùï»ï»ï»ï»ï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»ï»ï»ï»¡ï¹½Ùï»¥ï»©ï»¬ï»°ï»²ï»ï»ï»µï»¶ï»ï»ï»±â ï¿½"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": "ÃÃ¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬ÃÃÃÃ¦ÃÃ´Ã¶Ã²Ã»Ã¹Ã¿ÃÃÃ¸Â£Ãâ§ÆÃ¡Ã­Ã³ÃºÃ±ÃÂªÂºÂ¿âÂ¬Â½Â¼Â¡Â«Â¤âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÎ±ÃÎÏÎ£ÏÂµÏÎ¦ÎÎ©Î´âÏÎµâ©â¡Â±â¥â¤â â¡Ã·âÂ°âÂ·ââ¿Â²â Â "
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": "ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÐÑÐÑÐÑÐÑÂ°âÂ·ââÂ¤â Â "
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Îï¿½Â·Â¬Â¦ââÎâÎÎÎªÎï¿½ï¿½ÎÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏÎÏÏÎÎÎÎÎÎÎÂ½ÎÎÂ«Â»âââââ¤ÎÎÎÎâ£âââÎÎâââ´â¬âââ¼Î Î¡âââ©â¦â ââ¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³ââââÎ´ÎµâÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿ÏÏÏÏÏÎÂ­Â±ÏÏÏÂ§ÏÎÂ°Â¨ÏÏÎ°Ïâ Â "
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÅ ÃÃÃÃÃÃÃÃÃÃÃÃÃÅ½ÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": "ïºÃÃ·ï£¶ï£µï£´ï£·ï¹±Ââ ââââââï¹¹ï¹»ï¹½ï¹¿ï¹·ïºï»°ï»³ï»²ï»ï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïºïºïºïºïºïº£ØÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Øïº»ïº¿ï»Øï»Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»Ø¹Øºï»ïºïºïºï»ÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙï»ï»ï»ï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÐÐÒÐÐÐÐÐÐÐÐÐÂ­ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑâÑÑÒÑÑÑÑÑÑÑÑÑÂ§ÑÑ"
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": "ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿âââââ¤â¡â¢âââ£ââââââââ´â¬âââ¼âââââ©â¦â ââ¬â§â¨â¤â¥âââââ«âªâââââââÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÐÑÒÒÐÑÐÑÐÑÂ·ââÂ¤â Â "
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Â¡Â¢Â£Â¤Â¥Â¦Â§ÅÂ©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·ÅÂ¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÄÃÃÃÃÃÃÃÃÌÃÃÃÄÃÌÃÃÆ ÃÃÃÃÃÃÃÆ¯ÌÃÃ Ã¡Ã¢ÄÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯ÄÃ±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â«Ã¿"
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ àºàºàºàºàºàºªàºàºàºàºàºàºàºàºàºàºàºàºàºàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»à»à»à»à»à»à»à»à»à»à»à»ï¿½à»à»â­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»à»à»à»à»à»à»à»à»ï¿½ï¿½Â¢Â¬Â¦ï¿½"
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹à¹à¹â¬à¸¿à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹Â¢Â¬Â¦Â "
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": "â¬ÂÂÂÂâ¦ÂÂÂÂÂÂÂÂÂÂÂâââââ¢ââÂÂÂÂÂÂÂÂÂ à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹ï¿½ï¿½ï¿½ï¿½"
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ Â¡Â¢Â£â¬Â¥Â¦Â§ÅÂ©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·ÅÂ¹ÂºÂ»Â¼Â½Â¾Â¿ÃÃÃÄÃÃÃÃÃÃÃÃÌÃÃÃÄÃÌÃÃÆ ÃÃÃÃÃÃÃÆ¯ÌÃÃ Ã¡Ã¢ÄÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯ÄÃ±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â«Ã¿"
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": "ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Å â¢Â´Â¨â Å½ÃâÂ±â¤â¥âÂµâââÅ¡â«ÂªÂºâ¦Å¾Ã¸Â¿Â¡Â¬âÆâÄÂ«Äâ¦Â ÃÃÃÅÅÄâââââÃ·âï¿½Â©âÂ¤â¹âºÃÂ»âÂ·âââ°ÃÄÃÄÃÃÃÃÃÃÃÄÃÃÃÃÄ±ËËÂ¯ÏÃËÂ¸ÃÃ¦Ë"
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": "ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â Â°Â¢Â£Â§â¢Â¶ÐÂ®Â©â¢ÐÑâ ÐÑâÂ±â¤â¥ÑÂµâÐÐÑÐÑÐÑÐÑÑÐÂ¬âÆââÂ«Â»â¦Â ÐÑÐÑÑââââââÃ·âÐÑÐÑâÐÑÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÂ¤"
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": "ÃÂ¹Â²ÃÂ³ÃÃÎÃ Ã¢Ã¤ÎÂ¨Ã§Ã©Ã¨ÃªÃ«Â£â¢Ã®Ã¯â¢Â½â°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â ÎÎÎÎÎÎ ÃÂ®Â©Î£ÎªÂ§â Â°ÎÎÂ±â¤â¥Â¥ÎÎÎÎÎÎÎÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎÎ¡âÎ¤Â«Â»â¦Â Î¥Î§ÎÎÅââââââÃ·ÎÎÎÎÎ­Î®Î¯ÏÎÏÎ±Î²ÏÎ´ÎµÏÎ³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿ÏÏÏÏÏÎ¸ÏÏÏÏÎ¶ÏÏÎÎ°ï¿½"
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": "ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºâ¦Ã¦Ã¸Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸âÂ¤ÃÃ°ÃÃ¾Ã½Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï¿½ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË"
    },
    "macroman": {
      "type": "_sbcs",
      "chars": "ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºâ¦Ã¦Ã¸Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸âÂ¤â¹âºï¬ï¬â¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï¿½ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË"
    },
    "macromania": {
      "type": "_sbcs",
      "chars": "ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÄÅâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºâ¦ÄÅÂ¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸âÂ¤â¹âºÅ¢Å£â¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï¿½ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË"
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "Â«Â»â¦ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ââï¢ï¿½â¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ï¢ââï¿½Â à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸º\uFEFFâââà¸¿à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹â¢à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹Â®Â©ï¿½ï¿½ï¿½ï¿½"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": "ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºâ¦Ã¦Ã¸Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ÄÄÄ°Ä±ÅÅâ¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï¿½ÃÃÃÃï¿½ËËÂ¯ËËËÂ¸ËËË"
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": "ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â Â°ÒÂ£Â§â¢Â¶ÐÂ®Â©â¢ÐÑâ ÐÑâÂ±â¤â¥ÑÂµÒÐÐÑÐÑÐÑÐÑÑÐÂ¬âÆââÂ«Â»â¦Â ÐÑÐÑÑââââââÃ·âÐÑÐÑâÐÑÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÂ¤"
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": "ââââââââ¤â¬â´â¼âââââââââ â ââââ¤â¥Â â¡Â°Â²Â·Ã·âââÑââââââââââââââ â¡Ðâ¢â£â¤â¥â¦â§â¨â©âªâ«â¬Â©ÑÐ°Ð±ÑÐ´ÐµÑÐ³ÑÐ¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÐ¶Ð²ÑÑÐ·ÑÑÑÑÑÐ®ÐÐÐ¦ÐÐÐ¤ÐÐ¥ÐÐÐÐÐÐÐÐÐ¯Ð Ð¡Ð¢Ð£ÐÐÐ¬Ð«ÐÐ¨Ð­Ð©Ð§Ðª"
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": "ââââââââ¤â¬â´â¼âââââââââ â ââââ¤â¥Â â¡Â°Â²Â·Ã·âââÑÑâÑÑâââââÒââââ â¡ÐÐâ£ÐÐâ¦â§â¨â©âªÒâ¬Â©ÑÐ°Ð±ÑÐ´ÐµÑÐ³ÑÐ¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÐ¶Ð²ÑÑÐ·ÑÑÑÑÑÐ®ÐÐÐ¦ÐÐÐ¤ÐÐ¥ÐÐÐÐÐÐÐÐÐ¯Ð Ð¡Ð¢Ð£ÐÐÐ¬Ð«ÐÐ¨Ð­Ð©Ð§Ðª"
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": "ââââââââ¤â¬â´â¼âââââââââ â ââââ¤â¥Â â¡Â°Â²Â·Ã·âââÑÑâÑÑâââââÒÑâââ â¡ÐÐâ£ÐÐâ¦â§â¨â©âªÒÐÂ©ÑÐ°Ð±ÑÐ´ÐµÑÐ³ÑÐ¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÐ¶Ð²ÑÑÐ·ÑÑÑÑÑÐ®ÐÐÐ¦ÐÐÐ¤ÐÐ¥ÐÐÐÐÐÐÐÐÐ¯Ð Ð¡Ð¢Ð£ÐÐÐ¬Ð«ÐÐ¨Ð­Ð©Ð§Ðª"
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": "ÒÒâÒââ¦â â¡ï¿½â°Ò³â¹Ò²Ò·Ò¶ï¿½Òâââââ¢ââï¿½â¢ï¿½âºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®ÑÂ¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½âï¿½Â»ï¿½ï¿½ï¿½Â©ÑÐ°Ð±ÑÐ´ÐµÑÐ³ÑÐ¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÐ¶Ð²ÑÑÐ·ÑÑÑÑÑÐ®ÐÐÐ¦ÐÐÐ¤ÐÐ¥ÐÐÐÐÐÐÐÐÐ¯Ð Ð¡Ð¢Ð£ÐÐÐ¬Ð«ÐÐ¨Ð­Ð©Ð§Ðª"
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ï¿½ÖÖ)(Â»Â«â.Õ,-Öâ¦ÕÕÕÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯ÕÕ°ÕÕ±ÕÕ²ÕÕ³ÕÕ´ÕÕµÕÕ¶ÕÕ·ÕÕ¸ÕÕ¹ÕÕºÕÕ»ÕÕ¼ÕÕ½ÕÕ¾ÕÕ¿ÕÖÕÖÕÖÕÖÕÖÕÖÕÖÕï¿½"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": "ÐÐâÑââ¦â â¡â¬â°Ðâ¹ÐÒÒºÐÑâââââ¢ââï¿½â¢ÑâºÑÒÒ»ÑÂ Ò°Ò±ÓÂ¤Ó¨Â¦Â§ÐÂ©ÒÂ«Â¬Â­Â®Ò®Â°Â±ÐÑÓ©ÂµÂ¶Â·ÑâÒÂ»ÓÒ¢Ò£Ò¯ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ"
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0Ãá»¤á»ªá»¬á»®\x07\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ãáº¢ÃÃáº áº¶áº¬Ãáººáº¼Ãáº¸á»Ãá»Ä¨Ãá»Ãá»ÃÃá»á»á»á»á» á»á»¢Ãá»¦Å¨Â ÄÃÃÃÆ Æ¯ÄÄÃ¢ÃªÃ´Æ¡Æ°Äáº°ÌÌÌÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»áº·áº§áº©áº«áº¥áº­Ã¨á»áº»áº½Ã©áº¹á»á»á»áº¿á»Ã¬á»á»áº¾á»Ä©Ã­á»Ã²á»á»ÃµÃ³á»á»á»á»á»á»á»á»á»¡á»á»£Ã¹á»á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": "ÂÂâÆââ¦â â¡Ëâ°Å â¹ÅÂÂÂÂâââââ¢ââËâ¢Å¡âºÅÂÂÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿ááááááááááááááááá á¡á¢á£á¤á¥á¦á§á¨á©áªá«á¬á­á®á¯á°á±á²á³á´áµá¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": "ÂÂâÆââ¦â â¡Ëâ°Å â¹ÅÂÂÂÂâââââ¢ââËâ¢Å¡âºÅÂÂÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áááááááá±ááááááá²áááá á¡á¢á³á£á¤á¥á¦á§á¨á©áªá«á¬á­á®á´á¯á°áµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "pt154": {
      "type": "_sbcs",
      "chars": "ÒÒÓ®Òââ¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒÒºÒ¸Òâââââ¢ââÒ³Ò·Ò¡Ó£Ò£ÒÒ»Ò¹Â ÐÑÐÓ¨ÒÒ°Â§ÐÂ©ÓÂ«Â¬Ó¯Â®ÒÂ°Ò±ÐÑÒÓ©Â¶Â·ÑâÓÂ»ÑÒªÒ«ÒÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ"
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0áº²áº´áºª\x07\b	\n\v\f\rá»¶á»¸\x1Bá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»á»á»á»á»á»á»á»á»á»¢á»á»á»á»á»á»á»á»¦Å¨á»¤á»²Ãáº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»á»á»á»á»á»á»á» Æ á»á»á»á»á»°á»¨á»ªá»¬Æ¡á»Æ¯ÃÃÃÃáº¢Äáº³áºµÃÃÃáººÃÃÄ¨á»³Äá»©ÃÃÃáº¡á»·á»«á»­ÃÃá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»Äá»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": "ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ ÃÃÃÃÃÃÃÂ´ËËÂ¨ËÃÃâ¤Â¯ÃÃ½Â°ÃÃ§ÃÃ±Â¡Â¿Â¤Â£Â¥Â§ÆÂ¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼ÃÃ®ÃÃÃ¥Ã­Ã¸Ã¦ÃÃ¬ÃÃÃÃ¯ÃÃÃÃÃ£ÃÃ°ÃÃÃÃÃÃµÅ Å¡ÃÅ¸Ã¿ÃÃ¾Â·ÂµÂ¶Â¾âÂ¼Â½ÂªÂºÂ«â Â»Â±ï¿½"
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": "ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºâ¦Ã¦Ã¸Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸âÂ¤â¹âºï¬ï¬â¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï¿½ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË"
    },
    "ascii": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "tis620": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸à¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹à¹ï¿½ï¿½ï¿½ï¿½"
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer3 = safer_1.Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer3.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length) break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer3.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer3.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "ï½¡",
    62
  ],
  [
    "8140",
    "ãããï¼ï¼ã»ï¼ï¼ï¼ï¼ããÂ´ï½Â¨ï¼¾ï¿£ï¼¿ã½ã¾ãããä»ãããã¼ââï¼ï¼¼ï½â¥ï½â¦â¥ââââï¼ï¼ããï¼»ï¼½ï½ï½ã",
    9,
    "ï¼ï¼Â±Ã"
  ],
  [
    "8180",
    "Ã·ï¼â ï¼ï¼â¦â§ââ´ââÂ°â²â³âï¿¥ï¼ï¿ ï¿¡ï¼ï¼ï¼ï¼ï¼ Â§ââââââââ¡â â³â²â½â¼â»ãââââã"
  ],
  [
    "81b8",
    "âââââââªâ©"
  ],
  [
    "81c8",
    "â§â¨ï¿¢ââââ"
  ],
  [
    "81da",
    "â â¥ââââ¡ââªâ«ââ½ââµâ«â¬"
  ],
  [
    "81f0",
    "â«â°â¯â­âªâ â¡Â¶"
  ],
  [
    "81fc",
    "â¯"
  ],
  [
    "824f",
    "ï¼",
    9
  ],
  [
    "8260",
    "ï¼¡",
    25
  ],
  [
    "8281",
    "ï½",
    25
  ],
  [
    "829f",
    "ã",
    82
  ],
  [
    "8340",
    "ã¡",
    62
  ],
  [
    "8380",
    "ã ",
    22
  ],
  [
    "839f",
    "Î",
    16,
    "Î£",
    6
  ],
  [
    "83bf",
    "Î±",
    16,
    "Ï",
    6
  ],
  [
    "8440",
    "Ð",
    5,
    "ÐÐ",
    25
  ],
  [
    "8470",
    "Ð°",
    5,
    "ÑÐ¶",
    7
  ],
  [
    "8480",
    "Ð¾",
    17
  ],
  [
    "849f",
    "ââââââââ¬â¤â´â¼âââââââ£â³â«â»ââ â¯â¨â·â¿ââ°â¥â¸â"
  ],
  [
    "8740",
    "â ",
    19,
    "â ",
    9
  ],
  [
    "875f",
    "ããã¢ããã§ãã¶ãããã¦ã£ã«ãã»ããããããã¡"
  ],
  [
    "877e",
    "ã»"
  ],
  [
    "8780",
    "ããâãâ¡ã¤",
    4,
    "ã±ã²ã¹ã¾ã½ã¼ââ¡â«â®âââ¥â ââ¿âµâ©âª"
  ],
  [
    "889f",
    "äºåå¨é¿åææ¨å§¶é¢èµèç©æªæ¡æ¸¥æ­è¦è¦é¯µæ¢å§æ¡æ±å®å§è»é£´çµ¢ç¶¾é®æç²è¢·å®åºµæææ¡ééæä»¥ä¼ä½ä¾åå²å¤·å§å¨å°æææ°ææ¤çºçç°ç§»ç¶­ç·¯èèè¡£è¬ééºå»äºäº¥åè²éç£¯ä¸å£±æº¢é¸ç¨²è¨èé°¯åå°å½å¡å å§»å¼é£²æ·«è¤è­"
  ],
  [
    "8940",
    "é¢é°é é»åå³å®çç¾½è¿é¨å¯éµçªºä¸ç¢è¼æ¸¦ååæ¬èé°»å§¥å©æµ¦çéåäºéé²èé¤å¡å¶å¬°å½±æ æ³æ æ°¸æ³³æ´©ççç©é ´è±è¡è© é­æ¶²ç«çé§æ¦è¬è¶é²æ¦å­å"
  ],
  [
    "8980",
    "åå °å¥å®´å»¶æ¨æ©æ´æ²¿æ¼ççççç¿ç¸è¶èèé éé´å¡©æ¼æ±ç¥å¹å¤®å¥¥å¾å¿æ¼æºæ¨ªæ¬§æ®´çç¿è¥é´¬é´é»å²¡æ²è»åå±æ¶èæ¡¶ç¡ä¹ä¿ºå¸æ©æ¸©ç©é³ä¸åä»®ä½ä¼½ä¾¡ä½³å å¯åå¤å«å®¶å¯¡ç§æææ¶æ­æ²³ç«çç¦ç¦¾ç¨¼ç®è±èèè·è¯èè¦èª²å©è²¨è¿¦ééèä¿å³¨æçç»è¥è½è¾è³éé¤é§ä»ä¼è§£åå¡å£å»»å¿«æªææ¢ææææ¹"
  ],
  [
    "8a40",
    "é­æ¦æ¢°æµ·ç°çççµµè¥è¹ééè²å±å¾å¤å³å®³å´æ¨æ¦æ¶¯ç¢èè¡è©²é§éª¸æµ¬é¦¨èå£æ¿èéåååå»æ¡æ¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦è§èµ«è¼é­é£éé©å­¦å²³æ¥½é¡é¡æç¬ æ¨«"
  ],
  [
    "8a80",
    "æ©¿æ¢¶é°æ½å²åæ°æ¬æ´»æ¸æ»èè¤è½ä¸é°¹å¶æ¤æ¨ºéæ ªåç«è²ééåé´¨æ ¢èè±ç²¥åèç¦ä¹¾ä¾å å¯ååå§å·»åå ªå§¦å®å®å¯å¹²å¹¹æ£ææ£æ¾ææ¢ææ¡æ£ºæ¬¾æ­æ±æ¼¢æ¾æ½ç°çç£çç«¿ç®¡ç°¡ç·©ç¼¶ç¿°èè¦èè¦³è«è²«ééééé¢é¥éé¤¨èä¸¸å«å²¸å·ç©çç¼å²©ç¿«è´éé é¡é¡ä¼ä¼å±åå¨åºå¥å¬å¯å²å¸å¹¾å¿æ®æºææ¢ææ£æ£"
  ],
  [
    "8b40",
    "æ©å¸°æ¯æ°æ±½ç¿ç¥å­£ç¨ç´å¾½è¦è¨è²´èµ·è»è¼é£¢é¨é¬¼äºå½åå¦å®æ¯ææ¬æ¬ºç çç¥ç¾©è»èª¼è­°æ¬èé ååå«æ¡æ©è©°ç §æµé»å´å®¢èèéä¸ä¹ä»ä¼åå¸å®®å¼æ¥æ"
  ],
  [
    "8b80",
    "æ½æ±æ±²æ³£ç¸çç©¶çª®ç¬ç´ç³¾çµ¦æ§çå»å±å·¨ææ ææ¸ èè¨±è·é¸æ¼ç¦¦é­äº¨äº«äº¬ä¾ä¾ ååç«¶å±å¶åå¡å¿å«å¬å¢å³¡å¼·å½æ¯ææ­æææ©æ³çç­ç¯è¸èèèé·é¡é¿é¥é©ä»°åå°­ææ¥­å±æ²æ¥µçæ¡ç²åå¤åå·¾é¦æ¤æ¬£æ¬½ç´ç¦ç¦½ç­ç·è¹èè¡¿è¥è¬¹è¿éåéä¹å¶å¥åºççç©è¦èº¯é§é§é§å·æèå°ç©ºå¶å¯ééä¸²æ«é§å±å±"
  ],
  [
    "8c40",
    "æçªæ²é´è½¡çªªçéç²æ ç¹°æ¡é¬å²åè«è¨ç¾¤è»é¡å¦è¢ç¥ä¿å¾åååå­çªåå¥å½¢å¾æµæ¶æ§æ©æ²æºæ¬æ¯æ¡æ¸ç¦ç¨½ç³»çµç¶ç¹ç½«èèèè¨è©£è­¦è»½é é¶è¸è¿é¯¨"
  ],
  [
    "8c80",
    "åæææ¿éæ¡åæ¬ æ±ºæ½ç©´çµè¡è¨£æä»¶å¹å¦å¥å¼å¸å£å§åå å«å»ºæ²æ¸æ³æ²æ¤æ¨©ç½ç¬ç®ç ç¡¯çµ¹çè©è¦è¬è³¢è»é£éµéºé¡é¨é¹¸ååå³å¹»å¼¦æ¸æºçç¾çµè·è¨è«ºéä¹åå¤å¼åºå§å­¤å·±åº«å¼§æ¸ææ¯æ¹çç³è¢´è¡è¡è°èèªè·¨é·éé¡§é¼äºäºä¼ååå¾å¨¯å¾å¾¡ææ¢§æªçç¢èªèª¤è­·éä¹é¯äº¤ä½¼ä¾¯åååå¬åå¹å¾åå£å"
  ],
  [
    "8d40",
    "åååå¢å¥½å­å­å®å·¥å·§å··å¹¸åºåºåº·å¼æææææ§æ»æææ´æ­æ ¡æ¢æ§æ±æ´ªæµ©æ¸¯æºç²çç¡¬ç¨¿ç³ ç´ç´çµç¶±èèè¯è±èèèªèè¡è¡¡è¬è²¢è³¼ééµé±ç ¿é¼é¤é"
  ],
  [
    "8d80",
    "é é¦é«é´»åå«å·åå£æ·æ¿ è±ªè½éº¹åå»åå½ç©é·éµ é»çæ¼è°çå¿½æéª¨çè¾¼æ­¤é ä»å°å¤å¢¾å©æ¨ææææ ¹æ¢±æ··çç´ºè®é­äºä½åååµ¯å·¦å·®æ»æ²ç³ç è©éè£ååº§æ«åµå¬åæåå¡å¦»å®°å½©ææ¡æ ½æ­³æ¸ç½éçç ç ¦ç¥­æç´°èè£è¼éå¤å¨æç½ªè²¡å´åéªå ºæ¦è´å²å´å¼ç¢é·ºä½ååæ¾æ¨ææµçªç­ç´¢é¯æ¡é®­ç¬¹ååå·"
  ],
  [
    "8e40",
    "å¯æ¶æ®æ¦æ­æ®ºè©éçé¯æéé®«ç¿æä¸ååå±±æ¨ææ£æ¡ç¦çç£ç®çºèè®è³é¸é¤æ¬æ«æ®ä»ä»ä¼ºä½¿åºå¸å²å£åå£«å§å§å§¿å­å±å¸å¸«å¿æææ¯å­æ¯æ½æ¨ææ­¢"
  ],
  [
    "8e80",
    "æ­»æ°çç¥ç§ç³¸ç´ç´«è¢èè³è¦è©è©©è©¦èªè«®è³è³éé£¼æ­¯äºä¼¼ä¾åå­å¯ºææææ¬¡æ»æ²»ç¾ç½çç£ç¤ºèè³èªèè¾æ±é¹¿å¼è­é´«ç«ºè»¸å®é«ä¸å±å·å¤±å«å®¤ææ¹¿æ¼ç¾è³ªå®èç¯ å²æ´èå±¡èç¸èåå°æ¨èµ¦æç®ç¤¾ç´èè¬è»é®èéªååºå°ºæç¼çµééé«è¥å¯å¼±æ¹ä¸»åå®ææ±æ®ç©ç ç¨®è«è¶£éé¦åååªå¯¿ææ¨¹ç¶¬éååå¨"
  ],
  [
    "8f40",
    "å®å°±å·ä¿®ææ¾æ´²ç§ç§çµç¹ç¿è­èèè¡è¥²è®è¹´è¼¯é±éé¬ééä»ä½ååå¾æææ±æ¸ç£ç¸¦ééåå¤å®¿æ·ç¥ç¸®ç²å¡¾çåºè¡è¿°ä¿å³»æ¥ç¬ç«£èé§¿åå¾ªæ¬æ¥¯æ®æ·³"
  ],
  [
    "8f80",
    "æºæ½¤ç¾ç´å·¡éµéé å¦åææææ¸åº¶ç·ç½²æ¸è¯è·è«¸å©åå¥³åºå¾æé¤é¤å·ååå åå¬å¨åå±åå¥¨å¦¾å¨¼å®µå°å°å°å°åºåºå» å½°æ¿ææææ·æææ­æ¶æ¾æ¢¢æ¨æ¨µæ²¼æ¶æ¸æ¹ç¼ç¦ç§ççç¡ç¤ç¥¥ç§°ç« ç¬ç²§ç´¹èèèèè¡è£³è¨è¨¼è©è©³è±¡è³é¤é¦é¾éééä¸ä¸ä¸ä¹åå°åå ´å£å¬¢å¸¸ææ¾æ¡ææµç¶ç³ç©£è¸è­²é¸é å±å´é£¾"
  ],
  [
    "9040",
    "æ­æ¤æ®ç­ç¹è·è²è§¦é£èè¾±å°»ä¼¸ä¿¡ä¾µåå¨ å¯å¯©å¿ææ¯æ°ææ£®æ¦æµ¸æ·±ç³ç¹çç¥ç§¦ç´³è£è¯èªè¦ªè¨ºèº«è¾é²ééäººä»åå¡µå£¬å°çå°½èè¨è¿é£é­ç¬¥è«é é¢å³å¨"
  ],
  [
    "9080",
    "éå¹åå¸¥æ¨æ°´çç¡ç²ç¿ è¡°éééééçé«å´åµ©æ°æ¢è¶¨éæ®ææ¤èé éè£¾æ¾æºå¯¸ä¸ç¬çæ¯åå¶å¢å§å¾æ§ææ¿æ´ææ´æ£²æ æ­£æ¸ç²ççç²¾èå£°è£½è¥¿èª èªè«ééééæç¨èé»å¸­æææ¥ææç³ç©ç±ç¸¾èè²¬èµ¤è·¡è¹ç¢©åææ¥ææè¨­çªç¯èª¬éªçµ¶èèä»ååå å®£å°å°å·æ¦ææ°æ æ ´æ³æµæ´ææ½çç½æç©¿ç®­ç·"
  ],
  [
    "9140",
    "ç¹ç¾¨èºèè¹è¦è©®è³è·µé¸é·é­ééé®®ååæ¼¸ç¶å¨ç¦ç¹è³ç³åå¡å²¨æªæ¾æ½æ¥çççç¤ç¥ç§ç²ç´ çµèè¨´é»é¡é¼ å§åµåå¢ååªå£®å¥ç½å®å±¤åæ£æ³æææ¿æ»"
  ],
  [
    "9180",
    "ææ©æ¹å·£æ§æ§½æ¼ç¥äºç©ç¸çªç³ç·ç¶è¡èèè¬è¼è»è£èµ°éé­ééé¨åå¢æèèµè´é ä¿å´åå³æ¯æææ¸¬è¶³éä¿å±è³æç¶åè¢å¶æå­å­«å°ææéä»å¤å¤ªæ±°è©å¾å å¦¥æ°ææèµæ¥éé§é¨¨ä½å å¯¾èå²±å¸¯å¾æ ææ´æ¿æ³°æ»èè¿èè¢è²¸éé®éé»é¯ä»£å°å¤§ç¬¬éé¡é·¹æ»ç§ååå®ææææ²¢æ¿¯ç¢è¨é¸æ¿è«¾è¸å§è¸åª"
  ],
  [
    "9240",
    "å©ä½éè¾°å¥ªè±å·½ç«ªè¾¿æ£è°·ç¸é±æ¨½èª°ä¸¹ååå¦ææ¢æ¦æ­æ·¡æ¹ç­ç­ç«¯ç®ªç¶»è½èèèªéå£å£å¼¾æ­ææªæ®µç·è«å¤ç¥å°å¼æ¥æºæ± ç´ç¨ç½®è´èéé¦³ç¯çç«¹ç­è"
  ],
  [
    "9280",
    "éç§©çªè¶å«¡çä¸­ä»²å®å¿ æ½æ¼æ±æ³¨è«è¡·è¨»éé³é§æ¨ç¦çªè§èè²¯ä¸åååå¯µå¸å¸³åºå¼å¼µå½«å¾´æ²ææ¢ææ½®ççºçºè´è¹è¸è¶èª¿è«è¶è·³éé·é é³¥åæç´ææ²çè³é®é³æ´¥å¢æ¤æ§è¿½éçéå¡æ æ´æ§»ä½æ¼¬æè¾»è¦ç¶´éæ¤¿æ½°åªå£·å¬¬ç´¬çªåé£é¶´äº­ä½ååµåè²åå ¤å®å¸åºåº­å»·å¼ææµæºææ¢¯æ±ç¢ç¦ç¨ç· èè¨è«¦è¹é"
  ],
  [
    "9340",
    "é¸é­éé¼æ³¥ææ¢æµæ»´çç¬é©éæººå²å¾¹æ¤è½è¿­éå¸å¡«å¤©å±åºæ·»çºçè²¼è»¢é¡ç¹ä¼æ®¿æ¾±ç°é»ååå µå¡å¦¬å± å¾æææ¸¡ç»èè³­éé½éç ¥ç ºåªåº¦åå¥´æååå¬"
  ],
  [
    "9380",
    "åååå¡å¡å¥å®å³¶å¶æ¼ææ­æ±æ¡æ¢¼æ£çæ·æ¹¯æ¶ç¯çå½çç¥·ç­ç­ç­ç³çµ±å°è£è©è¤è¨è¬è±è¸éééé¶é ­é¨°éåååå å°æ§ææ´ç³ç«¥è´èééå³ é´å¿å¾å¾³æ¶ç¹ç£ç¦¿ç¯¤æ¯ç¬èª­æ æ©¡å¸çªæ¤´å±é³¶è«å¯éçå¸å±¯ææ¦æ²è±éé åæéå¥é£åä¹åªèè¬çæºéæ¥¢é¦´ç¸ç·åæ¥ è»é£æ±äºå°¼å¼è¿©åè³èè¹å»¿æ¥ä¹³å¥"
  ],
  [
    "9440",
    "å¦å°¿é®ä»»å¦å¿èªæ¿¡ç¦°ç¥¢å¯§è±ç«ç±å¹´å¿µæ»æçç²ä¹å»¼ä¹åå¢æ©æ¿ç´è½è³è¿è¾²è¦è¤å·´ææ­è¦æ·æ³¢æ´¾ç¶ç ´å©ç½µè­é¦¬ä¿³å»ææææ¯ççèèºè¼©éåå¹åªæ¢"
  ],
  [
    "9480",
    "æ¥³ç¤ç½è²·å£²è³ éªéè¿ç§¤ç§è©ä¼¯å¥åæææ³ç½ç®ç²è¶èè¿«ææ¼ çç¸è«é§éº¦å½ç®±ç¡²ç®¸èç­æ«¨å¹¡èçç å«é¢æºçºéé«ªä¼ç½°æç­é¥é³©åºå¡è¤é¼ä¼´å¤åååå¸æ¬ææ¿æ°¾æ±çç¯ç­çç¹è¬è©è²©ç¯éç©é é£¯æ½æ©çªç¤ç£èè®åªåå¦å¦åºå½¼æ²ææ¹æ«ææ¯æ³ç²ç®ç¢ç§ç·ç½·è¥è¢«èª¹è²»é¿éé£æ¨ç°¸åå°¾å¾®ææ¯çµçç¾"
  ],
  [
    "9540",
    "é¼»æç¨å¹çé«­å½¦èè±èå¼¼å¿ç¢ç­é¼æ¡§å§«åªç´ç¾è¬¬ä¿µå½ªæ¨æ°·æ¼ç¢ç¥¨è¡¨è©è±¹å»æçç§èé¨é²èè­é°­åå½¬ææµçè²§è³é »æç¶ä¸ä»å å¤«å©¦å¯å¨å¸åºææ¶æ·"
  ],
  [
    "9580",
    "æ§æ®æµ®ç¶ç¬¦èèèè­è² è³¦èµ´ééä¾®æ«æ­¦èè¡èªé¨å°æ¥é¢¨èºèä¼å¯å¾©å¹æç¦è¹è¤è¦æ·µå¼ææ²¸ä»ç©é®åå»å´å¢³æ¤æ®çå¥®ç²ç³ç´é°æèä¸ä½µåµå¡å¹£å¹³å¼æä¸¦è½ééç±³é å»å£çç¢§å¥ç¥èç®åå¤çç¯ç·¨è¾ºè¿éä¾¿åå¨©å¼é­ä¿èéªåææ­©ç«è£è¼ç©åå¢æææ®æ¯ç°¿è©å£ä¿¸ååå ±å¥å®å³°å³¯å´©åºæ±æ§æ¾æ¹æ"
  ],
  [
    "9640",
    "æ³æ³¡ç¹ç ²ç¸«èè³èè¬èè¤è¨ªè±é¦éé£½é³³éµ¬ä¹äº¡åååå¦¨å¸½å¿å¿æ¿æ´æææ£åç´¡èªè¨è¬è²è²¿é¾é²å é ¬åååå¢¨æ²æ´ç§ç¦ç©é¦åæ²¡æ®å å¹å¥æ¬ç¿»å¡ç"
  ],
  [
    "9680",
    "æ©ç£¨é­éº»åå¦¹æ§ææ¯å©æ§å¹èæé®ªæ¾é±æ¡äº¦ä¿£åæ¹æ«æ²«è¿ä¾­ç¹­éº¿ä¸æ¢æºæ¼«èå³æªé­å·³ç®å²¬å¯èæ¹èç¨èå¦ç²æ°ç åå¤¢ç¡ççé§éµ¡æ¤å©¿å¨å¥åå½æçè¿·éé³´å§ªçæ»åæ£ç¶¿ç·¬é¢éººæ¸æ¨¡èå¦å­æ¯çç²ç¶²èèå²æ¨é»ç®æ¢å¿é¤å°¤æ»ç±¾è²°åæ¶ç´éåä¹å¶å¤çºè¶éå¼¥ç¢åå½¹ç´è¬è¨³èºéæ³è®éæææ²¹ç"
  ],
  [
    "9740",
    "è«­è¼¸å¯ä½åªååå®¥å¹½æ æææææ¹§æ¶ç¶ç·ç±ç¥è£èªéééµéèå¤äºä½ä¸èªè¼¿é å­å¹¼å¦å®¹åº¸ææºæææ¥æ§æ´æº¶çç¨çª¯ç¾èèèè¦è¬¡è¸é¥é½é¤æ¾ææ¬²"
  ],
  [
    "9780",
    "æ²æµ´ç¿ç¿¼æ·ç¾èºè£¸æ¥è±é ¼é·æ´çµ¡è½éªä¹±åµåµæ¬æ¿«èè­è¦§å©åå±¥ææ¢¨ççç¢è£è£¡éé¢é¸å¾çç«èæ ç¥åæµæºççç¡«ç²éç«é¾ä¾¶æ®æèäºäº®åä¸¡åå¯®ææ¢æ¶¼ççç­ç¨ç³§è¯è«é¼ééµé åç·å«åææ·çç³è¨è¼ªé£é±éºç å¡æ¶ç´¯é¡ä»¤ä¼¶ä¾å·å±å¶ºæç²ç¤¼èé´é·é¶ééºé½¢æ¦æ­´åå£çè£å»æææ¼£çç°¾ç·´è¯"
  ],
  [
    "9840",
    "è®é£é¬åé­¯æ«çè³è·¯é²å´å©å»å¼ææ¥¼æ¦æµªæ¼ç¢ç¼ç¯­èè¾èéå­éºç¦èé²è«å­åè©±æ­ªè³èææ é·²äºäºé°è©«èè¨æ¤æ¹¾ç¢è"
  ],
  [
    "989f",
    "å¼ä¸ä¸ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹ä¹ä¹äºäºè±«äºèå¼äºäºäºäº äº¢äº°äº³äº¶ä»ä»ä»ä»ä»ä»ä»ä»­ä»ä»·ä¼ä½ä¼°ä½ä½ä½ä½ä½¶ä¾ä¾ä¾ä½»ä½©ä½°ä¾ä½¯ä¾ä¾åä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿¤ä¿¥åå¨ååªå¥åä¼ä¿¶å¡å©å¬ä¿¾ä¿¯ååååæåååååå¬å¸åååå´å²"
  ],
  [
    "9940",
    "ååå³åååå¥å­å£å®å¹åµåååååååå¡åºå·å¼å»å¿ååååå¢ç«¸å©åªå®ååååååååååå¤å¦å¢å©åªå«å³å±å²å°åµå½åååå èå©å­"
  ],
  [
    "9980",
    "å°åµå¾ååååå§åªå®å³å¹åååååååªå´å©å³å¿å½åååå±ååè¾¨è¾§å¬å­å¼åµååååå£å¦é£­å å³åµå¸å¹ååç¸åååååå£å¯å±å³å¸åååä¸ååååå©å®å¤å»å·ååå å¦å¥å®å°å¶åç°éåæ¼ç®å®å¨å­åºåå½åå¬å­å¼å®å¶å©ååååµååå±å·å°åå»åå¶ååååå¢å¸å¥å¬ååå¨"
  ],
  [
    "9a40",
    "å«åå¤å¾å¼åå¥å¦ååå½å®å­åºå¢å¹åå£åå®ååååå¸å³åååå¯ååå»å¾ååå®å¼åå©åå¨åååååå¤ååå·åå¾å½åå¹ååçå´å¶å²å¸"
  ],
  [
    "9a80",
    "å«å¤å¯å¬åªåååå ååå¥å®å¶å´åå¼ååååååååå®å¹åå¿ååååååååååå¦å·å¸åå»ååå©ååå¡å¿ååå å³å¤åªå°åååååå åå£å å å å¡²å ¡å¡¢å¡å¡°æ¯å¡å ½å¡¹å¢å¢¹å¢å¢«å¢ºå£å¢»å¢¸å¢®å£å£å£å£å£å£å£¥å£å£¤å£å£¯å£ºå£¹å£»å£¼å£½å¤å¤å¤å¤æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«å¥å¥å¥å¥å¥å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "9b40",
    "å¥¸å¦å¦ä½ä¾«å¦£å¦²å§å§¨å§å¦å§å§å¨¥å¨å¨å¨å¨å¨å©å©¬å©å¨µå¨¶å©¢å©ªåªåª¼åª¾å«å«åª½å«£å«å«¦å«©å«å«ºå«»å¬å¬å¬å¬²å«å¬ªå¬¶å¬¾å­å­å­å­å­å­å­å­¥å­©å­°å­³å­µå­¸æå­ºå®"
  ],
  [
    "9b80",
    "å®å®¦å®¸å¯å¯å¯å¯å¯å¯¤å¯¦å¯¢å¯å¯¥å¯«å¯°å¯¶å¯³å°å°å°å°å°å° å°¢å°¨å°¸å°¹å±å±å±å±å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²å²å²å¦å²«å²»å²¶å²¼å²·å³å²¾å³å³å³©å³½å³ºå³­å¶å³ªå´å´å´åµå´å´å´å´å´¢å´å´å´åµåµåµåµåµ¬åµ³åµ¶å¶å¶å¶å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·å·å·å·å·å·å·«å·²å·µå¸å¸å¸å¸å¸å¸¶å¸·å¹å¹å¹å¹å¹å¹å¹å¹¢å¹¤å¹å¹µå¹¶å¹ºéº¼å¹¿åº å»å»å»å»å»"
  ],
  [
    "9c40",
    "å»å»£å»å»å»å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼å¼å½å½å¼å¼å¼å¼©å¼­å¼¸å½å½å½å½å¼¯å½å½å½å½å½¡å½­å½³å½·å¾å¾å½¿å¾å¾å¾å¾å¾å¾å¾å¾ å¾¨å¾­å¾¼å¿å¿»å¿¤å¿¸å¿±å¿æ³å¿¿æ¡æ "
  ],
  [
    "9c80",
    "æææ©ææ±æææ«æ¦ææºæææªæ·æææææ£ææ¤ææ¬æ«ææææ§ææææææææ§ææ¡æ¸æ ææ´å¿°æ½ææµæææææ¶æ·ææ´æºææ¡æ»æ±ææææ¾æ¨æ§ææ¿æ¼æ¬æ´æ½æææ³æ·ææææ«æ´æ¯æ¥æ±ææææµææææ¬æææææ«æ®ææææ·ææææºæç½¹ææ¦æ£æ¶æºæ´æ¿æ½æ¼æ¾æææææææ"
  ],
  [
    "9d40",
    "ææ¡æªæ®æ°æ²æ³ææææ£ææ æ¨æ¼æææ¾æææææææææ»ææ¿ææææææææææææ®æ±æ§æææ¯æµææ¾æææææææ«æ¶æ£ææææµæ«"
  ],
  [
    "9d80",
    "æ©æ¾æ©æææ£æææ¶æææ´æææ¦æ¶æææ¨ææ§æ¯æ¶ææªæææ¥æ©ææ¼æææææ»æææ±æ§èæ æ¡æ¬æ£æ¯æ¬æ¶æ´æ²æºææ½ææææ¤æ£æ«æ´æµæ·æ¶æ¸çææææææææ²æ¸ææè®æææ«æ·æææææææææ æ¡æ±æ²æææ»æ³æµæ¶æ´ææææææææ¤æ§æ¨ææ¢æ°æææææææææ¹ææ¾æ¼"
  ],
  [
    "9e40",
    "ææ¸æææ æ¿æ¦æ©æ°æµæ·ææææ¦æ§é¸æ®æ¿æ¶ææ¸æ·æææ ææ£æ¤ææ°æ©æ¼æªæææ¦æ¡ææ·æ¯æ´æ¬æ³æ©æ¸æ¤æææ¢æ®æ¹æææ§æªæ æ¡æ ©æ¡æ¡æ ²æ¡"
  ],
  [
    "9e80",
    "æ¢³æ «æ¡æ¡£æ¡·æ¡¿æ¢æ¢æ¢­æ¢æ¢æ¢æ¢æª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£æ¤æ£æ¤¢æ¤¦æ£¡æ¤æ£æ£æ£§æ£æ¤¶æ¤æ¤æ£æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤æ¤£æ¤¡æ£æ¥¹æ¥·æ¥æ¥¸æ¥«æ¥æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥æ¤°æ¥¡æ¥æ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§æ¦¾æ§å¯¨æ§æ§æ¦»æ§æ¦§æ¨®æ¦æ¦ æ¦æ¦æ¦´æ§æ§¨æ¨æ¨æ§¿æ¬æ§¹æ§²æ§§æ¨æ¦±æ¨æ§­æ¨æ§«æ¨æ¨æ«æ¨£æ¨æ©æ¨æ©²æ¨¶æ©¸æ©æ©¢æ©æ©¦æ©æ¨¸æ¨¢æªæªæª æªæª¢æª£"
  ],
  [
    "9f40",
    "æªèæª»æ«æ«æª¸æª³æª¬æ«æ«æ«æªªæ«æ«ªæ«»æ¬èæ«ºæ¬æ¬é¬±æ¬æ¬¸æ¬·çæ¬¹é£®æ­æ­æ­æ­æ­æ­æ­æ­æ­¡æ­¸æ­¹æ­¿æ®æ®æ®æ®æ®æ®æ®æ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯æ¯æ¯æ¯æ¯¬æ¯«æ¯³æ¯¯"
  ],
  [
    "9f80",
    "éº¾æ°æ°æ°æ°æ°¤æ°£æ±æ±æ±¢æ±ªæ²æ²æ²æ²æ²æ±¾æ±¨æ±³æ²æ²æ³æ³±æ³æ²½æ³æ³æ³æ²®æ²±æ²¾æ²ºæ³æ³¯æ³æ³ªæ´è¡æ´¶æ´«æ´½æ´¸æ´æ´µæ´³æ´æ´æµ£æ¶æµ¤æµæµ¹æµæ¶æ¶æ¿¤æ¶æ·¹æ¸æ¸æ¶µæ·æ·¦æ¶¸æ·æ·¬æ·æ·æ·¨æ·æ·æ·ºæ·æ·¤æ·æ·ªæ·®æ¸­æ¹®æ¸®æ¸æ¹²æ¹æ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸æ¹æ¸ºæ¹æ¸¤æ»¿æ¸æ¸¸æºæºªæºæ»æº·æ»æº½æº¯æ»æº²æ»æ»æºæº¥æ»æºæ½æ¼çæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»"
  ],
  [
    "e040",
    "æ¼¾æ¼æ»·æ¾æ½ºæ½¸æ¾æ¾æ½¯æ½æ¿³æ½­æ¾æ½¼æ½æ¾æ¾æ¿æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿æ¾ªæ¿æ¿æ¿¬æ¿æ¿æ¿±æ¿®æ¿ççæ¿ºçççæ¿¾ççæ½´çççç°ç¾ç²çç£ççç¯ç±ç¬ç¸ç³ç®ççç"
  ],
  [
    "e080",
    "ççç½ççç¥ççç¦ç¢ççç¬çç»ççç¨ç¬çç¹ç¾ççççç ç¬ç§çµç¼ç¹ç¿çççç¨ç­ç¬ç°ç²ç»ç¼ç¿ççççç´ç¾çççççç¢ç§ç¹ç²çççççç¢ç ç¡ç¹ç·åçççççç´ç¯ç©ç¥ç¾ççé»ççªç¨ç°ç¸çµç»çºçç³çç»çç¥ç®çç¢çç¯ç¥ç¸ç²çºçç¿ççççç©ç°ç£çªç¶ç¾ççç§çççç±"
  ],
  [
    "e140",
    "ç ç£ç§ç©ç®ç²ç°ç±ç¸ç·çççççççççç¦ç¬ç¼çççççççç©ç¤ç§ç«ç­ç¸ç¶ççç´ççççççç¥ç£çç³ççµç½ç¸ç¼ç±ççççç£çç¾ç¿"
  ],
  [
    "e180",
    "ç¼çç°çºç²ç³ççççç§ç ç¡ç¢ç¤ç´ç°ç»çççççç¡ç¢ç¨ç©çªç§ç¬ç°ç²ç¶ç¸ç¼çççççççççç°ç´ç¸ç¹çºçççççç¡ç¥ç§çªè¯ç»çççç©ç¤çç¥ç¦çç·ç¸ççç¨ç«çç¥ç¿ç¾ç¹çççç çç°ç¶ç¹ç¿ç¼ç½ç»çççççç£ç®ç¼ç ç ç¤¦ç  ç¤ªç¡ç¢ç¡´ç¢ç¡¼ç¢ç¢ç¢£ç¢µç¢ªç¢¯ç£ç£ç£ç£ç¢¾ç¢¼ç£ç£ç£¬"
  ],
  [
    "e240",
    "ç£§ç£ç£½ç£´ç¤ç¤ç¤ç¤ç¤¬ç¤«ç¥ç¥ ç¥ç¥ç¥ç¥ç¥ç¥ºç¥¿ç¦ç¦ç¦§é½ç¦ªç¦®ç¦³ç¦¹ç¦ºç§ç§ç§§ç§¬ç§¡ç§£ç¨ç¨ç¨ç¨ç¨ ç¨ç¦ç¨±ç¨»ç¨¾ç¨·ç©ç©ç©ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªçªçªçªçªçª©ç«çª°"
  ],
  [
    "e280",
    "çª¶ç«ç«çª¿éç«ç«ç«ç«ç«ç«ç«ç«ç«ç«¡ç«¢ç«¦ç«­ç«°ç¬ç¬ç¬ç¬ç¬³ç¬ç¬ç¬ç¬µç¬¨ç¬¶ç­ç­ºç¬ç­ç¬ç­ç­ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®ç®ç®ç®ç®ç®ç®ç®ç­ç®ç¯ç¯ç¯ç¯ç®´ç¯ç¯ç¯©ç°ç°ç¯¦ç¯¥ç± ç°ç°ç°ç¯³ç¯·ç°ç°ç¯¶ç°£ç°§ç°ªç°ç°·ç°«ç°½ç±ç±ç±ç±ç±ç±ç±ç±ç±¤ç±ç±¥ç±¬ç±µç²ç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³ç³ç³ç³ç³ç³ç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´"
  ],
  [
    "e340",
    "ç´ç´ç´ç´çµçµç´®ç´²ç´¿ç´µçµçµ³çµçµçµ²çµ¨çµ®çµçµ£ç¶ç¶çµç¶çµ½ç¶ç¶ºç¶®ç¶£ç¶µç·ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·ç¶¸ç¶ç¶°ç·ç·ç·¤ç·ç·»ç·²ç·¡ç¸ç¸ç¸£ç¸¡ç¸ç¸±ç¸ç¸ç¸ç¸¢ç¹ç¹¦ç¸»ç¸µç¸¹ç¹ç¸·"
  ],
  [
    "e380",
    "ç¸²ç¸ºç¹§ç¹ç¹ç¹ç¹ç¹ç¹¹ç¹ªç¹©ç¹¼ç¹»çºç·ç¹½è¾®ç¹¿çºçºçºçºçºçºçºçºçºçºçºç¼¸ç¼ºç½ç½ç½ç½ç½ç½ç½ç½ç½ç½ç½ ç½¨ç½©ç½§ç½¸ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿ç¿ç¿ç¿ç¿ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£èèèèèèèè¡è¨è¿è»èèèèèèè¢è¨è³è²è°è¶è¹è½è¿èèèèèèè­åè¬èè¥èèèèèèè¯è±èè©è£è¯è"
  ],
  [
    "e440",
    "éèè¾èèè¼è±è®è¥è¦è´èèèèèè èè¤è£èèè©è°èµè¾è¸è½èèèºèèèèèèèèè è§èºè»è¾èèèèèèèèè©è«è¸è³èèèèèèè¤"
  ],
  [
    "e480",
    "è¢è¨èªè«è®è±è·è¸è¾èèè«èè»è¬è¡è£èèè´è³èºèèè»è¹èèèèèèµè´èè²è±èè¹èèè¯è«èèèèèªèè¢èè£èèèè¼èµè³èµè èè¨è´èè«èè½èèèèè·èè è²èè¢è è½è¸èè»è­èªè¼èèè·è«è­è®èè©èè¬è¯è¹èµèè¢è¹è¿èèèè»èèèèèè¡è¡è¿è´èèè¬èèèè¼èè£èè"
  ],
  [
    "e540",
    "èèèèèè¤èèèè¨è­èèèªèèè·è¾èèèºèè¹èèèè¥èè¹èèèè¾èºèè¢èè°è¿èä¹èèè§è±èè£è©èªèèè¶è¯èèè°èè £è«èèè©è¬"
  ],
  [
    "e580",
    "èèè¯èèèèèè»èèèè¹èè´è¿è·è»è¥è©èè èè¸èèè´èè¨è®èèè£èªè è¢èèè¯èè½èèéè«èè³èèè»è¯è²è è è è¾è¶è·è èè è è è ¢è ¡è ±è ¶è ¹è §è »è¡è¡è¡è¡è¡è¡¢è¡«è¢è¡¾è¢è¡µè¡½è¢µè¡²è¢è¢è¢è¢®è¢è¢¢è¢è¢¤è¢°è¢¿è¢±è£è£è£è£è£è£è£¹è¤è£¼è£´è£¨è£²è¤è¤è¤è¤è¥è¤è¤¥è¤ªè¤«è¥è¥è¤»è¤¶è¤¸è¥è¤è¥ è¥"
  ],
  [
    "e640",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦è¦è¦è¦è¦è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§è§è§è§è§§è§´è§¸è¨è¨è¨è¨è¨è¨è¨¥è¨¶è©è©è©è©è©è©¼è©­è©¬è©¢èªèªèªèª¨èª¡èªèª¥èª¦èªèª£è«è«è«è«è««è«³è«§"
  ],
  [
    "e680",
    "è«¤è«±è¬è« è«¢è«·è«è«è¬è¬è¬è«¡è¬è¬è¬è¬ è¬³é«è¬¦è¬«è¬¾è¬¨è­è­è­è­è­è­è­è­è­«è­è­¬è­¯è­´è­½è®è®è®è®è®è®è®è®è°ºè±è°¿è±è±è±è±è±è±¢è±¬è±¸è±ºè²è²è²è²è²è²è²è±¼è²æè²­è²ªè²½è²²è²³è²®è²¶è³è³è³¤è³£è³è³½è³ºè³»è´è´è´è´è´è´è´é½è´è³è´è´èµ§èµ­èµ±èµ³è¶è¶è·è¶¾è¶ºè·è·è·è·è·è·è·ªè·«è·è·£è·¼è¸è¸è·¿è¸è¸è¸è¸è¹è¸µè¸°è¸´è¹"
  ],
  [
    "e740",
    "è¹è¹è¹è¹è¹è¹è¹¤è¹ è¸ªè¹£è¹è¹¶è¹²è¹¼èºèºèºèºèºèºèºèºèºèºèºªèº¡èº¬èº°è»èº±èº¾è»è»è»è»è»£è»¼è»»è»«è»¾è¼è¼è¼è¼è¼è¼è¼è¼è¼è¼è¼¦è¼³è¼»è¼¹è½è½è¼¾è½è½è½è½è½è½"
  ],
  [
    "e780",
    "è½¢è½£è½¤è¾è¾è¾£è¾­è¾¯è¾·è¿è¿¥è¿¢è¿ªè¿¯éè¿´éè¿¹è¿ºééé¡ééééé§é¶éµé¹è¿¸ééééééé¾éééé¨é¯é¶é¨é²éé½éééééé¨é¯é±éµé¢é¤æééééé²é°éééé£é¥é©é³é²éééé¢é«é¯éªéµé´éºéééééééé¡éé¼éµé¶éé¿éé¬ééééééé¤ééé¿ééééééééé¹é·é©ééºéé®"
  ],
  [
    "e840",
    "éé¢éé£éºéµé»éé é¼é®éé°é¬é­éé¹ééé¨é¥éééééé¤ééééééé¶é«éµé¡éºééééé é¢ééªé©é°éµé·é½éé¼é¾éé¿ééééééé"
  ],
  [
    "e880",
    "é é¨é§é­é¼é»é¹é¾éæ¿¶éééééééé¡é¥é¢é¡é¨é®é¯ééééé·ééééé¦é²é¬éééééªé§é±é²é°é´é¶é¸é¹ééééè¥éééé¹éééééééééé¤éªé°é¹é½é¾ééééééé é¤é¦é¨åé«é±é¹éé¼ééºéééééé¨é¦é£é³é´éééééé­é½é²ç«é¶éµé é é ¸é ¤é ¡é ·é ½é¡é¡é¡é¡«é¡¯é¡°"
  ],
  [
    "e940",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£é£é£é£©é£«é¤é¤é¤é¤é¤é¤¡é¤é¤é¤¤é¤ é¤¬é¤®é¤½é¤¾é¥é¥é¥é¥é¥é¥é¥é¥é¥é¦é¦é¦¥é¦­é¦®é¦¼é§é§é§é§é§é§­é§®é§±é§²é§»é§¸é¨é¨é¨é§¢é¨é¨«é¨·é©é©é©é©"
  ],
  [
    "e980",
    "é¨¾é©é©é©é©é©é©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«é«é«é«é«é«é«é«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬é¬é¬é¬é¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­é­é­é­é­é­é­é­´é®é®é®é®é®é®é® é®¨é®´é¯é¯é®¹é¯é¯é¯é¯é¯£é¯¢é¯¤é¯é¯¡é°ºé¯²é¯±é¯°é°é°é°é°é°é°é°é°é°é°é°®é°é°¥é°¤é°¡é°°é±é°²é±é°¾é±é± é±§é±¶é±¸é³§é³¬é³°é´é´é³«é´é´é´ªé´¦é¶¯é´£é´éµé´é´éµé´¿é´¾éµéµ"
  ],
  [
    "ea40",
    "éµéµéµ¤éµéµéµéµ²é¶é¶é¶«éµ¯éµºé¶é¶¤é¶©é¶²é·é·é¶»é¶¸é¶ºé·é·é·é·é·é·¸é·¦é·­é·¯é·½é¸é¸é¸é¹µé¹¹é¹½éºéºéºéºéºéºéºéºéº¥éº©éº¸éºªéº­é¡é»é»é»é»é»é»é»é»é» é»¥é»¨é»¯"
  ],
  [
    "ea80",
    "é»´é»¶é»·é»¹é»»é»¼é»½é¼é¼ç·é¼é¼¡é¼¬é¼¾é½é½é½é½£é½é½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾é¾é¾ å ¯æ§éç¤åç"
  ],
  [
    "ed40",
    "çºè¤ééèä¿ç»æ±æ£é¹æ»å½ä¸¨ä»¡ä»¼ä¼ä¼ä¼¹ä½ä¾ä¾ä¾ä¾ä¿åå¢ä¿¿ååå°ååå´ååå¤åå¾å¬ååå¦ååååå¤å²åå²åï¨ååå©å¿ååå¥å¬ååï¨"
  ],
  [
    "ed80",
    "ï¨å¢å¢²å¤å¥å¥å¥å¥£å¦¤å¦ºå­å¯ç¯å¯å¯¬å°å²¦å²ºå³µå´§åµï¨åµåµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿ææææææ æ²ææ·æ°æææ¦æµæ ææææææ»ææ®ææ¤æ¥ææï¨æ³ææ æ²æ¿æºæï¤©æ¦æ»æ¡ææ æ¡æ£ï¨æ¥¨ï¨æ¦æ§¢æ¨°æ©«æ©æ©³æ©¾æ«¢æ«¤æ¯æ°¿æ±æ²æ±¯æ³æ´æ¶æµ¯æ¶æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹æ¸§æ¸¼æº¿æ¾æ¾µæ¿µççç¨çç«çççççï¨çç¾ç±"
  ],
  [
    "ee40",
    "ç¾ç¤ï¨ç·ç½ççç£çççµç¦çªç©ç®ç¢çççç¯ççççç¦ï¨çå¯ç ¡ç¡ç¡¤ç¡ºç¤°ï¨ï¨ï¨ç¦ï¨ç¦ç«ç«§ï¨ç««ç®ï¨çµçµç¶·ç¶ ç·ç¹ç½ç¾¡ï¨èè¢è¿èè¶èè´èè"
  ],
  [
    "ee80",
    "è«ï¨è°ï¨ ï¨¡è è£µè¨è¨·è©¹èª§èª¾è«ï¨¢è«¶è­è­¿è³°è³´è´èµ¶ï¨£è»ï¨¤ï¨¥é§éï¨¦éé§éééé­é®é¤é¥ééééºéé¼éééé¹é§é§é·é¸é§éééï¨§éé éé¥é¡é»ï¨¨éé¿ééé°éé¤ééé¸é±éééï§ï¨©éé¯é³é»éééééé¡é¡¥ï¨ªï¨«é¤§ï¨¬é¦é©é«é«é­µé­²é®é®±é®»é°éµ°éµ«ï¨­é¸é»"
  ],
  [
    "eeef",
    "â°",
    9,
    "ï¿¢ï¿¤ï¼ï¼"
  ],
  [
    "f040",
    "î",
    62
  ],
  [
    "f080",
    "î¿",
    124
  ],
  [
    "f140",
    "î¼",
    62
  ],
  [
    "f180",
    "î»",
    124
  ],
  [
    "f240",
    "î¸",
    62
  ],
  [
    "f280",
    "î·",
    124
  ],
  [
    "f340",
    "î´",
    62
  ],
  [
    "f380",
    "î³",
    124
  ],
  [
    "f440",
    "î°",
    62
  ],
  [
    "f480",
    "î¯",
    124
  ],
  [
    "f540",
    "î¬",
    62
  ],
  [
    "f580",
    "î«",
    124
  ],
  [
    "f640",
    "î¨",
    62
  ],
  [
    "f680",
    "î§",
    124
  ],
  [
    "f740",
    "î¤",
    62
  ],
  [
    "f780",
    "î£",
    124
  ],
  [
    "f840",
    "î ",
    62
  ],
  [
    "f880",
    "î",
    124
  ],
  [
    "f940",
    "î"
  ],
  [
    "fa40",
    "â°",
    9,
    "â ",
    9,
    "ï¿¢ï¿¤ï¼ï¼ã±ââ¡âµçºè¤ééèä¿ç»æ±æ£é¹æ»å½ä¸¨ä»¡ä»¼ä¼ä¼ä¼¹ä½ä¾ä¾ä¾ä¾ä¿åå¢ä¿¿ååå°ååå´åå"
  ],
  [
    "fa80",
    "å¤åå¾å¬ååå¦ååååå¤å²åå²åï¨ååå©å¿ååå¥å¬ååï¨ï¨å¢å¢²å¤å¥å¥å¥å¥£å¦¤å¦ºå­å¯ç¯å¯å¯¬å°å²¦å²ºå³µå´§åµï¨åµåµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿ææææææ æ²ææ·æ°æææ¦æµæ ææææææ»ææ®ææ¤æ¥ææï¨æ³ææ æ²æ¿æºæï¤©æ¦æ»æ¡ææ æ¡æ£ï¨æ¥¨ï¨æ¦æ§¢æ¨°æ©«æ©æ©³æ©¾æ«¢æ«¤æ¯æ°¿æ±æ²æ±¯æ³æ´æ¶æµ¯"
  ],
  [
    "fb40",
    "æ¶æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹æ¸§æ¸¼æº¿æ¾æ¾µæ¿µççç¨çç«çççççï¨çç¾ç±ç¾ç¤ï¨ç·ç½ççç£çççµç¦çªç©ç®ç¢çççç¯ççççç¦ï¨çå¯ç ¡ç¡ç¡¤ç¡ºç¤°ï¨ï¨"
  ],
  [
    "fb80",
    "ï¨ç¦ï¨ç¦ç«ç«§ï¨ç««ç®ï¨çµçµç¶·ç¶ ç·ç¹ç½ç¾¡ï¨èè¢è¿èè¶èè´èèè«ï¨è°ï¨ ï¨¡è è£µè¨è¨·è©¹èª§èª¾è«ï¨¢è«¶è­è­¿è³°è³´è´èµ¶ï¨£è»ï¨¤ï¨¥é§éï¨¦éé§éééé­é®é¤é¥ééééºéé¼éééé¹é§é§é·é¸é§éééï¨§éé éé¥é¡é»ï¨¨éé¿ééé°éé¤ééé¸é±éééï§ï¨©éé¯é³é»éééééé¡é¡¥ï¨ªï¨«é¤§ï¨¬é¦é©é«"
  ],
  [
    "fc40",
    "é«é­µé­²é®é®±é®»é°éµ°éµ«ï¨­é¸é»"
  ]
];
const require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "ï½¡",
    62
  ],
  [
    "a1a1",
    "ãããï¼ï¼ã»ï¼ï¼ï¼ï¼ããÂ´ï½Â¨ï¼¾ï¿£ï¼¿ã½ã¾ãããä»ãããã¼ââï¼ï¼¼ï½â¥ï½â¦â¥ââââï¼ï¼ããï¼»ï¼½ï½ï½ã",
    9,
    "ï¼ï¼Â±ÃÃ·ï¼â ï¼ï¼â¦â§ââ´ââÂ°â²â³âï¿¥ï¼ï¿ ï¿¡ï¼ï¼ï¼ï¼ï¼ Â§ââââââ"
  ],
  [
    "a2a1",
    "ââ¡â â³â²â½â¼â»ãââââã"
  ],
  [
    "a2ba",
    "âââââââªâ©"
  ],
  [
    "a2ca",
    "â§â¨ï¿¢ââââ"
  ],
  [
    "a2dc",
    "â â¥ââââ¡ââªâ«ââ½ââµâ«â¬"
  ],
  [
    "a2f2",
    "â«â°â¯â­âªâ â¡Â¶"
  ],
  [
    "a2fe",
    "â¯"
  ],
  [
    "a3b0",
    "ï¼",
    9
  ],
  [
    "a3c1",
    "ï¼¡",
    25
  ],
  [
    "a3e1",
    "ï½",
    25
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã¡",
    85
  ],
  [
    "a6a1",
    "Î",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ï",
    6
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "ÑÐ¶",
    25
  ],
  [
    "a8a1",
    "ââââââââ¬â¤â´â¼âââââââ£â³â«â»ââ â¯â¨â·â¿ââ°â¥â¸â"
  ],
  [
    "ada1",
    "â ",
    19,
    "â ",
    9
  ],
  [
    "adc0",
    "ããã¢ããã§ãã¶ãããã¦ã£ã«ãã»ããããããã¡"
  ],
  [
    "addf",
    "ã»ããâãâ¡ã¤",
    4,
    "ã±ã²ã¹ã¾ã½ã¼ââ¡â«â®âââ¥â ââ¿âµâ©âª"
  ],
  [
    "b0a1",
    "äºåå¨é¿åææ¨å§¶é¢èµèç©æªæ¡æ¸¥æ­è¦è¦é¯µæ¢å§æ¡æ±å®å§è»é£´çµ¢ç¶¾é®æç²è¢·å®åºµæææ¡ééæä»¥ä¼ä½ä¾åå²å¤·å§å¨å°æææ°ææ¤çºçç°ç§»ç¶­ç·¯èèè¡£è¬ééºå»äºäº¥åè²éç£¯ä¸å£±æº¢é¸ç¨²è¨èé°¯åå°å½å¡å å§»å¼é£²æ·«è¤è­"
  ],
  [
    "b1a1",
    "é¢é°é é»åå³å®çç¾½è¿é¨å¯éµçªºä¸ç¢è¼æ¸¦ååæ¬èé°»å§¥å©æµ¦çéåäºéé²èé¤å¡å¶å¬°å½±æ æ³æ æ°¸æ³³æ´©ççç©é ´è±è¡è© é­æ¶²ç«çé§æ¦è¬è¶é²æ¦å­ååå °å¥å®´å»¶æ¨æ©æ´æ²¿æ¼ççççç¿ç¸è¶èèé éé´å¡©æ¼æ±ç¥å¹å¤®å¥¥å¾å¿"
  ],
  [
    "b2a1",
    "æ¼æºæ¨ªæ¬§æ®´çç¿è¥é´¬é´é»å²¡æ²è»åå±æ¶èæ¡¶ç¡ä¹ä¿ºå¸æ©æ¸©ç©é³ä¸åä»®ä½ä¼½ä¾¡ä½³å å¯åå¤å«å®¶å¯¡ç§æææ¶æ­æ²³ç«çç¦ç¦¾ç¨¼ç®è±èèè·è¯èè¦èª²å©è²¨è¿¦ééèä¿å³¨æçç»è¥è½è¾è³éé¤é§ä»ä¼è§£åå¡å£å»»å¿«æªææ¢ææææ¹"
  ],
  [
    "b3a1",
    "é­æ¦æ¢°æµ·ç°çççµµè¥è¹ééè²å±å¾å¤å³å®³å´æ¨æ¦æ¶¯ç¢èè¡è©²é§éª¸æµ¬é¦¨èå£æ¿èéåååå»æ¡æ¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦è§èµ«è¼é­é£éé©å­¦å²³æ¥½é¡é¡æç¬ æ¨«æ©¿æ¢¶é°æ½å²åæ°æ¬æ´»æ¸æ»èè¤è½ä¸é°¹å¶æ¤æ¨ºéæ ªåç«è²ééåé´¨æ ¢èè±"
  ],
  [
    "b4a1",
    "ç²¥åèç¦ä¹¾ä¾å å¯ååå§å·»åå ªå§¦å®å®å¯å¹²å¹¹æ£ææ£æ¾ææ¢ææ¡æ£ºæ¬¾æ­æ±æ¼¢æ¾æ½ç°çç£çç«¿ç®¡ç°¡ç·©ç¼¶ç¿°èè¦èè¦³è«è²«ééééé¢é¥éé¤¨èä¸¸å«å²¸å·ç©çç¼å²©ç¿«è´éé é¡é¡ä¼ä¼å±åå¨åºå¥å¬å¯å²å¸å¹¾å¿æ®æºææ¢ææ£æ£"
  ],
  [
    "b5a1",
    "æ©å¸°æ¯æ°æ±½ç¿ç¥å­£ç¨ç´å¾½è¦è¨è²´èµ·è»è¼é£¢é¨é¬¼äºå½åå¦å®æ¯ææ¬æ¬ºç çç¥ç¾©è»èª¼è­°æ¬èé ååå«æ¡æ©è©°ç §æµé»å´å®¢èèéä¸ä¹ä»ä¼åå¸å®®å¼æ¥ææ½æ±æ±²æ³£ç¸çç©¶çª®ç¬ç´ç³¾çµ¦æ§çå»å±å·¨ææ ææ¸ èè¨±è·é¸æ¼ç¦¦é­äº¨äº«äº¬"
  ],
  [
    "b6a1",
    "ä¾ä¾ ååç«¶å±å¶åå¡å¿å«å¬å¢å³¡å¼·å½æ¯ææ­æææ©æ³çç­ç¯è¸èèèé·é¡é¿é¥é©ä»°åå°­ææ¥­å±æ²æ¥µçæ¡ç²åå¤åå·¾é¦æ¤æ¬£æ¬½ç´ç¦ç¦½ç­ç·è¹èè¡¿è¥è¬¹è¿éåéä¹å¶å¥åºççç©è¦èº¯é§é§é§å·æèå°ç©ºå¶å¯ééä¸²æ«é§å±å±"
  ],
  [
    "b7a1",
    "æçªæ²é´è½¡çªªçéç²æ ç¹°æ¡é¬å²åè«è¨ç¾¤è»é¡å¦è¢ç¥ä¿å¾åååå­çªåå¥å½¢å¾æµæ¶æ§æ©æ²æºæ¬æ¯æ¡æ¸ç¦ç¨½ç³»çµç¶ç¹ç½«èèèè¨è©£è­¦è»½é é¶è¸è¿é¯¨åæææ¿éæ¡åæ¬ æ±ºæ½ç©´çµè¡è¨£æä»¶å¹å¦å¥å¼å¸å£å§åå å«å»ºæ²æ¸æ³æ²"
  ],
  [
    "b8a1",
    "æ¤æ¨©ç½ç¬ç®ç ç¡¯çµ¹çè©è¦è¬è³¢è»é£éµéºé¡é¨é¹¸ååå³å¹»å¼¦æ¸æºçç¾çµè·è¨è«ºéä¹åå¤å¼åºå§å­¤å·±åº«å¼§æ¸ææ¯æ¹çç³è¢´è¡è¡è°èèªè·¨é·éé¡§é¼äºäºä¼ååå¾å¨¯å¾å¾¡ææ¢§æªçç¢èªèª¤è­·éä¹é¯äº¤ä½¼ä¾¯åååå¬åå¹å¾åå£å"
  ],
  [
    "b9a1",
    "åååå¢å¥½å­å­å®å·¥å·§å··å¹¸åºåºåº·å¼æææææ§æ»æææ´æ­æ ¡æ¢æ§æ±æ´ªæµ©æ¸¯æºç²çç¡¬ç¨¿ç³ ç´ç´çµç¶±èèè¯è±èèèªèè¡è¡¡è¬è²¢è³¼ééµé±ç ¿é¼é¤éé é¦é«é´»åå«å·åå£æ·æ¿ è±ªè½éº¹åå»åå½ç©é·éµ é»çæ¼è°çå¿½æéª¨çè¾¼"
  ],
  [
    "baa1",
    "æ­¤é ä»å°å¤å¢¾å©æ¨ææææ ¹æ¢±æ··çç´ºè®é­äºä½åååµ¯å·¦å·®æ»æ²ç³ç è©éè£ååº§æ«åµå¬åæåå¡å¦»å®°å½©ææ¡æ ½æ­³æ¸ç½éçç ç ¦ç¥­æç´°èè£è¼éå¤å¨æç½ªè²¡å´åéªå ºæ¦è´å²å´å¼ç¢é·ºä½ååæ¾æ¨ææµçªç­ç´¢é¯æ¡é®­ç¬¹ååå·"
  ],
  [
    "bba1",
    "å¯æ¶æ®æ¦æ­æ®ºè©éçé¯æéé®«ç¿æä¸ååå±±æ¨ææ£æ¡ç¦çç£ç®çºèè®è³é¸é¤æ¬æ«æ®ä»ä»ä¼ºä½¿åºå¸å²å£åå£«å§å§å§¿å­å±å¸å¸«å¿æææ¯å­æ¯æ½æ¨ææ­¢æ­»æ°çç¥ç§ç³¸ç´ç´«è¢èè³è¦è©è©©è©¦èªè«®è³è³éé£¼æ­¯äºä¼¼ä¾åå­å¯ºæææ"
  ],
  [
    "bca1",
    "æ¬¡æ»æ²»ç¾ç½çç£ç¤ºèè³èªèè¾æ±é¹¿å¼è­é´«ç«ºè»¸å®é«ä¸å±å·å¤±å«å®¤ææ¹¿æ¼ç¾è³ªå®èç¯ å²æ´èå±¡èç¸èåå°æ¨èµ¦æç®ç¤¾ç´èè¬è»é®èéªååºå°ºæç¼çµééé«è¥å¯å¼±æ¹ä¸»åå®ææ±æ®ç©ç ç¨®è«è¶£éé¦åååªå¯¿ææ¨¹ç¶¬éååå¨"
  ],
  [
    "bda1",
    "å®å°±å·ä¿®ææ¾æ´²ç§ç§çµç¹ç¿è­èèè¡è¥²è®è¹´è¼¯é±éé¬ééä»ä½ååå¾æææ±æ¸ç£ç¸¦ééåå¤å®¿æ·ç¥ç¸®ç²å¡¾çåºè¡è¿°ä¿å³»æ¥ç¬ç«£èé§¿åå¾ªæ¬æ¥¯æ®æ·³æºæ½¤ç¾ç´å·¡éµéé å¦åææææ¸åº¶ç·ç½²æ¸è¯è·è«¸å©åå¥³åºå¾æé¤é¤å·å"
  ],
  [
    "bea1",
    "åå åå¬å¨åå±åå¥¨å¦¾å¨¼å®µå°å°å°å°åºåºå» å½°æ¿ææææ·æææ­æ¶æ¾æ¢¢æ¨æ¨µæ²¼æ¶æ¸æ¹ç¼ç¦ç§ççç¡ç¤ç¥¥ç§°ç« ç¬ç²§ç´¹èèèèè¡è£³è¨è¨¼è©è©³è±¡è³é¤é¦é¾éééä¸ä¸ä¸ä¹åå°åå ´å£å¬¢å¸¸ææ¾æ¡ææµç¶ç³ç©£è¸è­²é¸é å±å´é£¾"
  ],
  [
    "bfa1",
    "æ­æ¤æ®ç­ç¹è·è²è§¦é£èè¾±å°»ä¼¸ä¿¡ä¾µåå¨ å¯å¯©å¿ææ¯æ°ææ£®æ¦æµ¸æ·±ç³ç¹çç¥ç§¦ç´³è£è¯èªè¦ªè¨ºèº«è¾é²ééäººä»åå¡µå£¬å°çå°½èè¨è¿é£é­ç¬¥è«é é¢å³å¨éå¹åå¸¥æ¨æ°´çç¡ç²ç¿ è¡°éééééçé«å´åµ©æ°æ¢è¶¨éæ®ææ¤èé éè£¾"
  ],
  [
    "c0a1",
    "æ¾æºå¯¸ä¸ç¬çæ¯åå¶å¢å§å¾æ§ææ¿æ´ææ´æ£²æ æ­£æ¸ç²ççç²¾èå£°è£½è¥¿èª èªè«ééééæç¨èé»å¸­æææ¥ææç³ç©ç±ç¸¾èè²¬èµ¤è·¡è¹ç¢©åææ¥ææè¨­çªç¯èª¬éªçµ¶èèä»ååå å®£å°å°å·æ¦ææ°æ æ ´æ³æµæ´ææ½çç½æç©¿ç®­ç·"
  ],
  [
    "c1a1",
    "ç¹ç¾¨èºèè¹è¦è©®è³è·µé¸é·é­ééé®®ååæ¼¸ç¶å¨ç¦ç¹è³ç³åå¡å²¨æªæ¾æ½æ¥çççç¤ç¥ç§ç²ç´ çµèè¨´é»é¡é¼ å§åµåå¢ååªå£®å¥ç½å®å±¤åæ£æ³æææ¿æ»ææ©æ¹å·£æ§æ§½æ¼ç¥äºç©ç¸çªç³ç·ç¶è¡èèè¬è¼è»è£èµ°éé­ééé¨åå¢æ"
  ],
  [
    "c2a1",
    "èèµè´é ä¿å´åå³æ¯æææ¸¬è¶³éä¿å±è³æç¶åè¢å¶æå­å­«å°ææéä»å¤å¤ªæ±°è©å¾å å¦¥æ°ææèµæ¥éé§é¨¨ä½å å¯¾èå²±å¸¯å¾æ ææ´æ¿æ³°æ»èè¿èè¢è²¸éé®éé»é¯ä»£å°å¤§ç¬¬éé¡é·¹æ»ç§ååå®ææææ²¢æ¿¯ç¢è¨é¸æ¿è«¾è¸å§è¸åª"
  ],
  [
    "c3a1",
    "å©ä½éè¾°å¥ªè±å·½ç«ªè¾¿æ£è°·ç¸é±æ¨½èª°ä¸¹ååå¦ææ¢æ¦æ­æ·¡æ¹ç­ç­ç«¯ç®ªç¶»è½èèèªéå£å£å¼¾æ­ææªæ®µç·è«å¤ç¥å°å¼æ¥æºæ± ç´ç¨ç½®è´èéé¦³ç¯çç«¹ç­èéç§©çªè¶å«¡çä¸­ä»²å®å¿ æ½æ¼æ±æ³¨è«è¡·è¨»éé³é§æ¨ç¦çªè§èè²¯ä¸åååå¯µ"
  ],
  [
    "c4a1",
    "å¸å¸³åºå¼å¼µå½«å¾´æ²ææ¢ææ½®ççºçºè´è¹è¸è¶èª¿è«è¶è·³éé·é é³¥åæç´ææ²çè³é®é³æ´¥å¢æ¤æ§è¿½éçéå¡æ æ´æ§»ä½æ¼¬æè¾»è¦ç¶´éæ¤¿æ½°åªå£·å¬¬ç´¬çªåé£é¶´äº­ä½ååµåè²åå ¤å®å¸åºåº­å»·å¼ææµæºææ¢¯æ±ç¢ç¦ç¨ç· èè¨è«¦è¹é"
  ],
  [
    "c5a1",
    "é¸é­éé¼æ³¥ææ¢æµæ»´çç¬é©éæººå²å¾¹æ¤è½è¿­éå¸å¡«å¤©å±åºæ·»çºçè²¼è»¢é¡ç¹ä¼æ®¿æ¾±ç°é»ååå µå¡å¦¬å± å¾æææ¸¡ç»èè³­éé½éç ¥ç ºåªåº¦åå¥´æååå¬åååå¡å¡å¥å®å³¶å¶æ¼ææ­æ±æ¡æ¢¼æ£çæ·æ¹¯æ¶ç¯çå½çç¥·ç­ç­ç­ç³çµ±å°"
  ],
  [
    "c6a1",
    "è£è©è¤è¨è¬è±è¸éééé¶é ­é¨°éåååå å°æ§ææ´ç³ç«¥è´èééå³ é´å¿å¾å¾³æ¶ç¹ç£ç¦¿ç¯¤æ¯ç¬èª­æ æ©¡å¸çªæ¤´å±é³¶è«å¯éçå¸å±¯ææ¦æ²è±éé åæéå¥é£åä¹åªèè¬çæºéæ¥¢é¦´ç¸ç·åæ¥ è»é£æ±äºå°¼å¼è¿©åè³èè¹å»¿æ¥ä¹³å¥"
  ],
  [
    "c7a1",
    "å¦å°¿é®ä»»å¦å¿èªæ¿¡ç¦°ç¥¢å¯§è±ç«ç±å¹´å¿µæ»æçç²ä¹å»¼ä¹åå¢æ©æ¿ç´è½è³è¿è¾²è¦è¤å·´ææ­è¦æ·æ³¢æ´¾ç¶ç ´å©ç½µè­é¦¬ä¿³å»ææææ¯ççèèºè¼©éåå¹åªæ¢æ¥³ç¤ç½è²·å£²è³ éªéè¿ç§¤ç§è©ä¼¯å¥åæææ³ç½ç®ç²è¶èè¿«ææ¼ çç¸è«é§éº¦"
  ],
  [
    "c8a1",
    "å½ç®±ç¡²ç®¸èç­æ«¨å¹¡èçç å«é¢æºçºéé«ªä¼ç½°æç­é¥é³©åºå¡è¤é¼ä¼´å¤åååå¸æ¬ææ¿æ°¾æ±çç¯ç­çç¹è¬è©è²©ç¯éç©é é£¯æ½æ©çªç¤ç£èè®åªåå¦å¦åºå½¼æ²ææ¹æ«ææ¯æ³ç²ç®ç¢ç§ç·ç½·è¥è¢«èª¹è²»é¿éé£æ¨ç°¸åå°¾å¾®ææ¯çµçç¾"
  ],
  [
    "c9a1",
    "é¼»æç¨å¹çé«­å½¦èè±èå¼¼å¿ç¢ç­é¼æ¡§å§«åªç´ç¾è¬¬ä¿µå½ªæ¨æ°·æ¼ç¢ç¥¨è¡¨è©è±¹å»æçç§èé¨é²èè­é°­åå½¬ææµçè²§è³é »æç¶ä¸ä»å å¤«å©¦å¯å¨å¸åºææ¶æ·æ§æ®æµ®ç¶ç¬¦èèèè­è² è³¦èµ´ééä¾®æ«æ­¦èè¡èªé¨å°æ¥é¢¨èºèä¼å¯å¾©å¹æ"
  ],
  [
    "caa1",
    "ç¦è¹è¤è¦æ·µå¼ææ²¸ä»ç©é®åå»å´å¢³æ¤æ®çå¥®ç²ç³ç´é°æèä¸ä½µåµå¡å¹£å¹³å¼æä¸¦è½ééç±³é å»å£çç¢§å¥ç¥èç®åå¤çç¯ç·¨è¾ºè¿éä¾¿åå¨©å¼é­ä¿èéªåææ­©ç«è£è¼ç©åå¢æææ®æ¯ç°¿è©å£ä¿¸ååå ±å¥å®å³°å³¯å´©åºæ±æ§æ¾æ¹æ"
  ],
  [
    "cba1",
    "æ³æ³¡ç¹ç ²ç¸«èè³èè¬èè¤è¨ªè±é¦éé£½é³³éµ¬ä¹äº¡åååå¦¨å¸½å¿å¿æ¿æ´æææ£åç´¡èªè¨è¬è²è²¿é¾é²å é ¬åååå¢¨æ²æ´ç§ç¦ç©é¦åæ²¡æ®å å¹å¥æ¬ç¿»å¡çæ©ç£¨é­éº»åå¦¹æ§ææ¯å©æ§å¹èæé®ªæ¾é±æ¡äº¦ä¿£åæ¹æ«æ²«è¿ä¾­ç¹­éº¿ä¸æ¢æº"
  ],
  [
    "cca1",
    "æ¼«èå³æªé­å·³ç®å²¬å¯èæ¹èç¨èå¦ç²æ°ç åå¤¢ç¡ççé§éµ¡æ¤å©¿å¨å¥åå½æçè¿·éé³´å§ªçæ»åæ£ç¶¿ç·¬é¢éººæ¸æ¨¡èå¦å­æ¯çç²ç¶²èèå²æ¨é»ç®æ¢å¿é¤å°¤æ»ç±¾è²°åæ¶ç´éåä¹å¶å¤çºè¶éå¼¥ç¢åå½¹ç´è¬è¨³èºéæ³è®éæææ²¹ç"
  ],
  [
    "cda1",
    "è«­è¼¸å¯ä½åªååå®¥å¹½æ æææææ¹§æ¶ç¶ç·ç±ç¥è£èªéééµéèå¤äºä½ä¸èªè¼¿é å­å¹¼å¦å®¹åº¸ææºæææ¥æ§æ´æº¶çç¨çª¯ç¾èèèè¦è¬¡è¸é¥é½é¤æ¾ææ¬²æ²æµ´ç¿ç¿¼æ·ç¾èºè£¸æ¥è±é ¼é·æ´çµ¡è½éªä¹±åµåµæ¬æ¿«èè­è¦§å©åå±¥ææ¢¨çç"
  ],
  [
    "cea1",
    "ç¢è£è£¡éé¢é¸å¾çç«èæ ç¥åæµæºççç¡«ç²éç«é¾ä¾¶æ®æèäºäº®åä¸¡åå¯®ææ¢æ¶¼ççç­ç¨ç³§è¯è«é¼ééµé åç·å«åææ·çç³è¨è¼ªé£é±éºç å¡æ¶ç´¯é¡ä»¤ä¼¶ä¾å·å±å¶ºæç²ç¤¼èé´é·é¶ééºé½¢æ¦æ­´åå£çè£å»æææ¼£çç°¾ç·´è¯"
  ],
  [
    "cfa1",
    "è®é£é¬åé­¯æ«çè³è·¯é²å´å©å»å¼ææ¥¼æ¦æµªæ¼ç¢ç¼ç¯­èè¾èéå­éºç¦èé²è«å­åè©±æ­ªè³èææ é·²äºäºé°è©«èè¨æ¤æ¹¾ç¢è"
  ],
  [
    "d0a1",
    "å¼ä¸ä¸ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹ä¹ä¹äºäºè±«äºèå¼äºäºäºäº äº¢äº°äº³äº¶ä»ä»ä»ä»ä»ä»ä»ä»­ä»ä»·ä¼ä½ä¼°ä½ä½ä½ä½ä½¶ä¾ä¾ä¾ä½»ä½©ä½°ä¾ä½¯ä¾ä¾åä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿¤ä¿¥åå¨ååªå¥åä¼ä¿¶å¡å©å¬ä¿¾ä¿¯ååååæåååååå¬å¸åååå´å²"
  ],
  [
    "d1a1",
    "ååå³åååå¥å­å£å®å¹åµåååååååå¡åºå·å¼å»å¿ååååå¢ç«¸å©åªå®ååååååååååå¤å¦å¢å©åªå«å³å±å²å°åµå½åååå èå©å­å°åµå¾ååååå§åªå®å³å¹åååååååªå´å©å³å¿å½åååå±ååè¾¨"
  ],
  [
    "d2a1",
    "è¾§å¬å­å¼åµååååå£å¦é£­å å³åµå¸å¹ååç¸åååååå£å¯å±å³å¸åååä¸ååååå©å®å¤å»å·ååå å¦å¥å®å°å¶åç°éåæ¼ç®å®å¨å­åºåå½åå¬å­å¼å®å¶å©ååååµååå±å·å°åå»åå¶ååååå¢å¸å¥å¬ååå¨"
  ],
  [
    "d3a1",
    "å«åå¤å¾å¼åå¥å¦ååå½å®å­åºå¢å¹åå£åå®ååååå¸å³åååå¯ååå»å¾ååå®å¼åå©åå¨åååååå¤ååå·åå¾å½åå¹ååçå´å¶å²å¸å«å¤å¯å¬åªåååå ååå¥å®å¶å´åå¼ååååååååå®å¹åå¿åå"
  ],
  [
    "d4a1",
    "ååååååååå¦å·å¸åå»ååå©ååå¡å¿ååå å³å¤åªå°åååååå åå£å å å å¡²å ¡å¡¢å¡å¡°æ¯å¡å ½å¡¹å¢å¢¹å¢å¢«å¢ºå£å¢»å¢¸å¢®å£å£å£å£å£å£å£¥å£å£¤å£å£¯å£ºå£¹å£»å£¼å£½å¤å¤å¤å¤æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«å¥å¥å¥å¥å¥å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "d5a1",
    "å¥¸å¦å¦ä½ä¾«å¦£å¦²å§å§¨å§å¦å§å§å¨¥å¨å¨å¨å¨å¨å©å©¬å©å¨µå¨¶å©¢å©ªåªåª¼åª¾å«å«åª½å«£å«å«¦å«©å«å«ºå«»å¬å¬å¬å¬²å«å¬ªå¬¶å¬¾å­å­å­å­å­å­å­å­¥å­©å­°å­³å­µå­¸æå­ºå®å®å®¦å®¸å¯å¯å¯å¯å¯å¯¤å¯¦å¯¢å¯å¯¥å¯«å¯°å¯¶å¯³å°å°å°å°å°å° å°¢å°¨å°¸å°¹å±å±å±å±"
  ],
  [
    "d6a1",
    "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²å²å²å¦å²«å²»å²¶å²¼å²·å³å²¾å³å³å³©å³½å³ºå³­å¶å³ªå´å´å´åµå´å´å´å´å´¢å´å´å´åµåµåµåµåµ¬åµ³åµ¶å¶å¶å¶å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·å·å·å·å·å·å·«å·²å·µå¸å¸å¸å¸å¸å¸¶å¸·å¹å¹å¹å¹å¹å¹å¹å¹¢å¹¤å¹å¹µå¹¶å¹ºéº¼å¹¿åº å»å»å»å»å»"
  ],
  [
    "d7a1",
    "å»å»£å»å»å»å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼å¼å½å½å¼å¼å¼å¼©å¼­å¼¸å½å½å½å½å¼¯å½å½å½å½å½¡å½­å½³å½·å¾å¾å½¿å¾å¾å¾å¾å¾å¾å¾å¾ å¾¨å¾­å¾¼å¿å¿»å¿¤å¿¸å¿±å¿æ³å¿¿æ¡æ æææ©ææ±æææ«æ¦ææºæææªæ·æææææ£ææ¤ææ¬æ«ææææ§ææ"
  ],
  [
    "d8a1",
    "ææææææ§ææ¡æ¸æ ææ´å¿°æ½ææµæææææ¶æ·ææ´æºææ¡æ»æ±ææææ¾æ¨æ§ææ¿æ¼æ¬æ´æ½æææ³æ·ææææ«æ´æ¯æ¥æ±ææææµææææ¬æææææ«æ®ææææ·ææææºæç½¹ææ¦æ£æ¶æºæ´æ¿æ½æ¼æ¾æææææææ"
  ],
  [
    "d9a1",
    "ææ¡æªæ®æ°æ²æ³ææææ£ææ æ¨æ¼æææ¾æææææææææ»ææ¿ææææææææææææ®æ±æ§æææ¯æµææ¾æææææææ«æ¶æ£ææææµæ«æ©æ¾æ©æææ£æææ¶æææ´æææ¦æ¶æææ¨ææ§æ¯æ¶ææªæææ¥æ©ææ¼"
  ],
  [
    "daa1",
    "æææææ»æææ±æ§èæ æ¡æ¬æ£æ¯æ¬æ¶æ´æ²æºææ½ææææ¤æ£æ«æ´æµæ·æ¶æ¸çææææææææ²æ¸ææè®æææ«æ·æææææææææ æ¡æ±æ²æææ»æ³æµæ¶æ´ææææææææ¤æ§æ¨ææ¢æ°æææææææææ¹ææ¾æ¼"
  ],
  [
    "dba1",
    "ææ¸æææ æ¿æ¦æ©æ°æµæ·ææææ¦æ§é¸æ®æ¿æ¶ææ¸æ·æææ ææ£æ¤ææ°æ©æ¼æªæææ¦æ¡ææ·æ¯æ´æ¬æ³æ©æ¸æ¤æææ¢æ®æ¹æææ§æªæ æ¡æ ©æ¡æ¡æ ²æ¡æ¢³æ «æ¡æ¡£æ¡·æ¡¿æ¢æ¢æ¢­æ¢æ¢æ¢æ¢æª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£æ¤æ£æ¤¢æ¤¦æ£¡æ¤æ£"
  ],
  [
    "dca1",
    "æ£æ£§æ£æ¤¶æ¤æ¤æ£æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤æ¤£æ¤¡æ£æ¥¹æ¥·æ¥æ¥¸æ¥«æ¥æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥æ¤°æ¥¡æ¥æ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§æ¦¾æ§å¯¨æ§æ§æ¦»æ§æ¦§æ¨®æ¦æ¦ æ¦æ¦æ¦´æ§æ§¨æ¨æ¨æ§¿æ¬æ§¹æ§²æ§§æ¨æ¦±æ¨æ§­æ¨æ§«æ¨æ¨æ«æ¨£æ¨æ©æ¨æ©²æ¨¶æ©¸æ©æ©¢æ©æ©¦æ©æ¨¸æ¨¢æªæªæª æªæª¢æª£"
  ],
  [
    "dda1",
    "æªèæª»æ«æ«æª¸æª³æª¬æ«æ«æ«æªªæ«æ«ªæ«»æ¬èæ«ºæ¬æ¬é¬±æ¬æ¬¸æ¬·çæ¬¹é£®æ­æ­æ­æ­æ­æ­æ­æ­æ­¡æ­¸æ­¹æ­¿æ®æ®æ®æ®æ®æ®æ®æ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯æ¯æ¯æ¯æ¯¬æ¯«æ¯³æ¯¯éº¾æ°æ°æ°æ°æ°¤æ°£æ±æ±æ±¢æ±ªæ²æ²æ²æ²æ²æ±¾æ±¨æ±³æ²æ²æ³æ³±æ³æ²½æ³æ³æ³æ²®æ²±æ²¾"
  ],
  [
    "dea1",
    "æ²ºæ³æ³¯æ³æ³ªæ´è¡æ´¶æ´«æ´½æ´¸æ´æ´µæ´³æ´æ´æµ£æ¶æµ¤æµæµ¹æµæ¶æ¶æ¿¤æ¶æ·¹æ¸æ¸æ¶µæ·æ·¦æ¶¸æ·æ·¬æ·æ·æ·¨æ·æ·æ·ºæ·æ·¤æ·æ·ªæ·®æ¸­æ¹®æ¸®æ¸æ¹²æ¹æ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸æ¹æ¸ºæ¹æ¸¤æ»¿æ¸æ¸¸æºæºªæºæ»æº·æ»æº½æº¯æ»æº²æ»æ»æºæº¥æ»æºæ½æ¼çæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»"
  ],
  [
    "dfa1",
    "æ¼¾æ¼æ»·æ¾æ½ºæ½¸æ¾æ¾æ½¯æ½æ¿³æ½­æ¾æ½¼æ½æ¾æ¾æ¿æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿æ¾ªæ¿æ¿æ¿¬æ¿æ¿æ¿±æ¿®æ¿ççæ¿ºçççæ¿¾ççæ½´çççç°ç¾ç²çç£ççç¯ç±ç¬ç¸ç³ç®çççççç½ççç¥ççç¦ç¢ççç¬çç»ççç¨ç¬çç¹ç¾ççççç ç¬ç§çµç¼"
  ],
  [
    "e0a1",
    "ç¹ç¿çççç¨ç­ç¬ç°ç²ç»ç¼ç¿ççççç´ç¾çççççç¢ç§ç¹ç²çççççç¢ç ç¡ç¹ç·åçççççç´ç¯ç©ç¥ç¾ççé»ççªç¨ç°ç¸çµç»çºçç³çç»çç¥ç®çç¢çç¯ç¥ç¸ç²çºçç¿ççççç©ç°ç£çªç¶ç¾ççç§çççç±"
  ],
  [
    "e1a1",
    "ç ç£ç§ç©ç®ç²ç°ç±ç¸ç·çççççççççç¦ç¬ç¼çççççççç©ç¤ç§ç«ç­ç¸ç¶ççç´ççççççç¥ç£çç³ççµç½ç¸ç¼ç±ççççç£çç¾ç¿ç¼çç°çºç²ç³ççççç§ç ç¡ç¢ç¤ç´ç°ç»çççççç¡ç¢ç¨ç©çªç§ç¬ç°"
  ],
  [
    "e2a1",
    "ç²ç¶ç¸ç¼çççççççççç°ç´ç¸ç¹çºçççççç¡ç¥ç§çªè¯ç»çççç©ç¤çç¥ç¦çç·ç¸ççç¨ç«çç¥ç¿ç¾ç¹çççç çç°ç¶ç¹ç¿ç¼ç½ç»çççççç£ç®ç¼ç ç ç¤¦ç  ç¤ªç¡ç¢ç¡´ç¢ç¡¼ç¢ç¢ç¢£ç¢µç¢ªç¢¯ç£ç£ç£ç£ç¢¾ç¢¼ç£ç£ç£¬"
  ],
  [
    "e3a1",
    "ç£§ç£ç£½ç£´ç¤ç¤ç¤ç¤ç¤¬ç¤«ç¥ç¥ ç¥ç¥ç¥ç¥ç¥ç¥ºç¥¿ç¦ç¦ç¦§é½ç¦ªç¦®ç¦³ç¦¹ç¦ºç§ç§ç§§ç§¬ç§¡ç§£ç¨ç¨ç¨ç¨ç¨ ç¨ç¦ç¨±ç¨»ç¨¾ç¨·ç©ç©ç©ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªçªçªçªçªçª©ç«çª°çª¶ç«ç«çª¿éç«ç«ç«ç«ç«ç«ç«ç«ç«ç«¡ç«¢ç«¦ç«­ç«°ç¬ç¬ç¬ç¬ç¬³ç¬ç¬ç¬ç¬µç¬¨ç¬¶ç­"
  ],
  [
    "e4a1",
    "ç­ºç¬ç­ç¬ç­ç­ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®ç®ç®ç®ç®ç®ç®ç®ç­ç®ç¯ç¯ç¯ç¯ç®´ç¯ç¯ç¯©ç°ç°ç¯¦ç¯¥ç± ç°ç°ç°ç¯³ç¯·ç°ç°ç¯¶ç°£ç°§ç°ªç°ç°·ç°«ç°½ç±ç±ç±ç±ç±ç±ç±ç±ç±¤ç±ç±¥ç±¬ç±µç²ç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³ç³ç³ç³ç³ç³ç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´"
  ],
  [
    "e5a1",
    "ç´ç´ç´ç´çµçµç´®ç´²ç´¿ç´µçµçµ³çµçµçµ²çµ¨çµ®çµçµ£ç¶ç¶çµç¶çµ½ç¶ç¶ºç¶®ç¶£ç¶µç·ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·ç¶¸ç¶ç¶°ç·ç·ç·¤ç·ç·»ç·²ç·¡ç¸ç¸ç¸£ç¸¡ç¸ç¸±ç¸ç¸ç¸ç¸¢ç¹ç¹¦ç¸»ç¸µç¸¹ç¹ç¸·ç¸²ç¸ºç¹§ç¹ç¹ç¹ç¹ç¹ç¹¹ç¹ªç¹©ç¹¼ç¹»çºç·ç¹½è¾®ç¹¿çºçºçºçºçºçºçºçºçºçºçºç¼¸ç¼º"
  ],
  [
    "e6a1",
    "ç½ç½ç½ç½ç½ç½ç½ç½ç½ç½ç½ ç½¨ç½©ç½§ç½¸ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿ç¿ç¿ç¿ç¿ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£èèèèèèèè¡è¨è¿è»èèèèèèè¢è¨è³è²è°è¶è¹è½è¿èèèèèèè­åè¬èè¥èèèèèèè¯è±èè©è£è¯è"
  ],
  [
    "e7a1",
    "éèè¾èèè¼è±è®è¥è¦è´èèèèèè èè¤è£èèè©è°èµè¾è¸è½èèèºèèèèèèèèè è§èºè»è¾èèèèèèèèè©è«è¸è³èèèèèèè¤è¢è¨èªè«è®è±è·è¸è¾èèè«èè»è¬è¡è£èèè´è³èºèèè»è¹èèèèè"
  ],
  [
    "e8a1",
    "èµè´èè²è±èè¹èèè¯è«èèèèèªèè¢èè£èèèè¼èµè³èµè èè¨è´èè«èè½èèèèè·èè è²èè¢è è½è¸èè»è­èªè¼èèè·è«è­è®èè©èè¬è¯è¹èµèè¢è¹è¿èèèè»èèèèèè¡è¡è¿è´èèè¬èèèè¼èè£èè"
  ],
  [
    "e9a1",
    "èèèèèè¤èèèè¨è­èèèªèèè·è¾èèèºèè¹èèèè¥èè¹èèèè¾èºèè¢èè°è¿èä¹èèè§è±èè£è©èªèèè¶è¯èèè°èè £è«èèè©è¬èèè¯èèèèèè»èèèè¹èè´è¿è·è»è¥è©èè èè¸èèè´èè¨è®è"
  ],
  [
    "eaa1",
    "èè£èªè è¢èèè¯èè½èèéè«èè³èèè»è¯è²è è è è¾è¶è·è èè è è è ¢è ¡è ±è ¶è ¹è §è »è¡è¡è¡è¡è¡è¡¢è¡«è¢è¡¾è¢è¡µè¡½è¢µè¡²è¢è¢è¢è¢®è¢è¢¢è¢è¢¤è¢°è¢¿è¢±è£è£è£è£è£è£è£¹è¤è£¼è£´è£¨è£²è¤è¤è¤è¤è¥è¤è¤¥è¤ªè¤«è¥è¥è¤»è¤¶è¤¸è¥è¤è¥ è¥"
  ],
  [
    "eba1",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦è¦è¦è¦è¦è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§è§è§è§è§§è§´è§¸è¨è¨è¨è¨è¨è¨è¨¥è¨¶è©è©è©è©è©è©¼è©­è©¬è©¢èªèªèªèª¨èª¡èªèª¥èª¦èªèª£è«è«è«è«è««è«³è«§è«¤è«±è¬è« è«¢è«·è«è«è¬è¬è¬è«¡è¬è¬è¬è¬ è¬³é«è¬¦è¬«è¬¾è¬¨è­è­è­è­è­è­è­è­è­«"
  ],
  [
    "eca1",
    "è­è­¬è­¯è­´è­½è®è®è®è®è®è®è®è®è°ºè±è°¿è±è±è±è±è±è±¢è±¬è±¸è±ºè²è²è²è²è²è²è²è±¼è²æè²­è²ªè²½è²²è²³è²®è²¶è³è³è³¤è³£è³è³½è³ºè³»è´è´è´è´è´è´è´é½è´è³è´è´èµ§èµ­èµ±èµ³è¶è¶è·è¶¾è¶ºè·è·è·è·è·è·è·ªè·«è·è·£è·¼è¸è¸è·¿è¸è¸è¸è¸è¹è¸µè¸°è¸´è¹"
  ],
  [
    "eda1",
    "è¹è¹è¹è¹è¹è¹è¹¤è¹ è¸ªè¹£è¹è¹¶è¹²è¹¼èºèºèºèºèºèºèºèºèºèºèºªèº¡èº¬èº°è»èº±èº¾è»è»è»è»è»£è»¼è»»è»«è»¾è¼è¼è¼è¼è¼è¼è¼è¼è¼è¼è¼¦è¼³è¼»è¼¹è½è½è¼¾è½è½è½è½è½è½è½¢è½£è½¤è¾è¾è¾£è¾­è¾¯è¾·è¿è¿¥è¿¢è¿ªè¿¯éè¿´éè¿¹è¿ºééé¡ééééé§é¶éµé¹è¿¸"
  ],
  [
    "eea1",
    "ééééééé¾éééé¨é¯é¶é¨é²éé½éééééé¨é¯é±éµé¢é¤æééééé²é°éééé£é¥é©é³é²éééé¢é«é¯éªéµé´éºéééééééé¡éé¼éµé¶éé¿éé¬ééééééé¤ééé¿ééééééééé¹é·é©ééºéé®"
  ],
  [
    "efa1",
    "éé¢éé£éºéµé»éé é¼é®éé°é¬é­éé¹ééé¨é¥éééééé¤ééééééé¶é«éµé¡éºééééé é¢ééªé©é°éµé·é½éé¼é¾éé¿éééééééé é¨é§é­é¼é»é¹é¾éæ¿¶éééééééé¡é¥é¢é¡é¨é®é¯ééééé·éé"
  ],
  [
    "f0a1",
    "ééé¦é²é¬éééééªé§é±é²é°é´é¶é¸é¹ééééè¥éééé¹éééééééééé¤éªé°é¹é½é¾ééééééé é¤é¦é¨åé«é±é¹éé¼ééºéééééé¨é¦é£é³é´éééééé­é½é²ç«é¶éµé é é ¸é ¤é ¡é ·é ½é¡é¡é¡é¡«é¡¯é¡°"
  ],
  [
    "f1a1",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£é£é£é£©é£«é¤é¤é¤é¤é¤é¤¡é¤é¤é¤¤é¤ é¤¬é¤®é¤½é¤¾é¥é¥é¥é¥é¥é¥é¥é¥é¥é¦é¦é¦¥é¦­é¦®é¦¼é§é§é§é§é§é§­é§®é§±é§²é§»é§¸é¨é¨é¨é§¢é¨é¨«é¨·é©é©é©é©é¨¾é©é©é©é©é©é©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«é«é«é«é«é«é«é«¢é«£é«¦é«¯é««é«®é«´é«±é«·"
  ],
  [
    "f2a1",
    "é«»é¬é¬é¬é¬é¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­é­é­é­é­é­é­é­´é®é®é®é®é®é®é® é®¨é®´é¯é¯é®¹é¯é¯é¯é¯é¯£é¯¢é¯¤é¯é¯¡é°ºé¯²é¯±é¯°é°é°é°é°é°é°é°é°é°é°é°®é°é°¥é°¤é°¡é°°é±é°²é±é°¾é±é± é±§é±¶é±¸é³§é³¬é³°é´é´é³«é´é´é´ªé´¦é¶¯é´£é´éµé´é´éµé´¿é´¾éµéµ"
  ],
  [
    "f3a1",
    "éµéµéµ¤éµéµéµéµ²é¶é¶é¶«éµ¯éµºé¶é¶¤é¶©é¶²é·é·é¶»é¶¸é¶ºé·é·é·é·é·é·¸é·¦é·­é·¯é·½é¸é¸é¸é¹µé¹¹é¹½éºéºéºéºéºéºéºéºéº¥éº©éº¸éºªéº­é¡é»é»é»é»é»é»é»é»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼é¼ç·é¼é¼¡é¼¬é¼¾é½é½é½é½£é½é½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾é¾é¾ "
  ],
  [
    "f4a1",
    "å ¯æ§éç¤åç"
  ],
  [
    "f9a1",
    "çºè¤ééèä¿ç»æ±æ£é¹æ»å½ä¸¨ä»¡ä»¼ä¼ä¼ä¼¹ä½ä¾ä¾ä¾ä¾ä¿åå¢ä¿¿ååå°ååå´ååå¤åå¾å¬ååå¦ååååå¤å²åå²åï¨ååå©å¿ååå¥å¬ååï¨ï¨å¢å¢²å¤å¥å¥å¥å¥£å¦¤å¦ºå­å¯ç¯å¯å¯¬å°å²¦å²ºå³µå´§åµï¨åµåµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"
  ],
  [
    "faa1",
    "å¿ææææææ æ²ææ·æ°æææ¦æµæ ææææææ»ææ®ææ¤æ¥ææï¨æ³ææ æ²æ¿æºæï¤©æ¦æ»æ¡ææ æ¡æ£ï¨æ¥¨ï¨æ¦æ§¢æ¨°æ©«æ©æ©³æ©¾æ«¢æ«¤æ¯æ°¿æ±æ²æ±¯æ³æ´æ¶æµ¯æ¶æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹æ¸§æ¸¼æº¿æ¾æ¾µæ¿µççç¨çç«çççççï¨çç¾ç±"
  ],
  [
    "fba1",
    "ç¾ç¤ï¨ç·ç½ççç£çççµç¦çªç©ç®ç¢çççç¯ççççç¦ï¨çå¯ç ¡ç¡ç¡¤ç¡ºç¤°ï¨ï¨ï¨ç¦ï¨ç¦ç«ç«§ï¨ç««ç®ï¨çµçµç¶·ç¶ ç·ç¹ç½ç¾¡ï¨èè¢è¿èè¶èè´èèè«ï¨è°ï¨ ï¨¡è è£µè¨è¨·è©¹èª§èª¾è«ï¨¢è«¶è­è­¿è³°è³´è´èµ¶ï¨£è»ï¨¤ï¨¥é§éï¨¦éé§é"
  ],
  [
    "fca1",
    "ééé­é®é¤é¥ééééºéé¼éééé¹é§é§é·é¸é§éééï¨§éé éé¥é¡é»ï¨¨éé¿ééé°éé¤ééé¸é±éééï§ï¨©éé¯é³é»éééééé¡é¡¥ï¨ªï¨«é¤§ï¨¬é¦é©é«é«é­µé­²é®é®±é®»é°éµ°éµ«ï¨­é¸é»"
  ],
  [
    "fcf1",
    "â°",
    9,
    "ï¿¢ï¿¤ï¼ï¼"
  ],
  [
    "8fa2af",
    "ËËÂ¸ËËÂ¯ËËï½ÎÎ"
  ],
  [
    "8fa2c2",
    "Â¡Â¦Â¿"
  ],
  [
    "8fa2eb",
    "ÂºÂªÂ©Â®â¢Â¤â"
  ],
  [
    "8fa6e1",
    "ÎÎÎÎÎª"
  ],
  [
    "8fa6e7",
    "Î"
  ],
  [
    "8fa6e9",
    "ÎÎ«"
  ],
  [
    "8fa6ec",
    "Î"
  ],
  [
    "8fa6f1",
    "Î¬Î­Î®Î¯ÏÎÏÏÏÏÎ°Ï"
  ],
  [
    "8fa7c2",
    "Ð",
    10,
    "ÐÐ"
  ],
  [
    "8fa7f2",
    "Ñ",
    10,
    "ÑÑ"
  ],
  [
    "8fa9a1",
    "ÃÄ"
  ],
  [
    "8fa9a4",
    "Ä¦"
  ],
  [
    "8fa9a6",
    "Ä²"
  ],
  [
    "8fa9a8",
    "ÅÄ¿"
  ],
  [
    "8fa9ab",
    "ÅÃÅ"
  ],
  [
    "8fa9af",
    "Å¦Ã"
  ],
  [
    "8fa9c1",
    "Ã¦ÄÃ°Ä§Ä±Ä³Ä¸ÅÅÅÅÃ¸ÅÃÅ§Ã¾"
  ],
  [
    "8faaa1",
    "ÃÃÃÃÄÇÄÄÃÃÄÄÄÃÄÄÃÃÃÃÄÄÄÄ"
  ],
  [
    "8faaba",
    "ÄÄÄ¢Ä Ä¤ÃÃÃÃÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅÅÅÃÃÃÃÃÇÅÅÃÅÅÅÅÅÅ ÅÅ¤Å¢ÃÃÃÃÅ¬ÇÅ°ÅªÅ²Å®Å¨ÇÇÇÇÅ´ÃÅ¸Å¶Å¹Å½Å»"
  ],
  [
    "8faba1",
    "Ã¡Ã Ã¤Ã¢ÄÇÄÄÃ¥Ã£ÄÄÄÃ§ÄÄÃ©Ã¨Ã«ÃªÄÄÄÄÇµÄÄ"
  ],
  [
    "8fabbd",
    "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"
  ],
  [
    "8fabc5",
    "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼ÅÅÅÃ±Ã³Ã²Ã¶Ã´ÇÅÅÃµÅÅÅÅÅÅ¡ÅÅ¥Å£ÃºÃ¹Ã¼Ã»Å­ÇÅ±Å«Å³Å¯Å©ÇÇÇÇÅµÃ½Ã¿Å·ÅºÅ¾Å¼"
  ],
  [
    "8fb0a1",
    "ä¸ä¸ä¸ä¸ä¸ä¸ä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹ä¹ä¹ä¹ä¹ä¹ä¹ä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäºäºäºäº¯äº¹ä»ä»ä»ä»ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½ä½ä½ä½ä½ä½ä½ä½ä½ä½ä½ä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾ä¾"
  ],
  [
    "8fb1a1",
    "ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿åååååååååååååååå¢å§å®å°å²å³åµååååååååååååååå å¢å£å¦å§åªå­å°å±å»åååååååå"
  ],
  [
    "8fb2a1",
    "ååååååå",
    4,
    "åªå¯å°å¹åºå½åååååååååååååå¢å¤å¦å¨å©å¯å±å¶åºå¾ååååååååå²åååååååå£å§å¨å¬å­å¯å±å³å´åµå¸å¹ååååååååå¤å¦å¾ååååååå¡å£å­å¸åºå¼å¾å¿å"
  ],
  [
    "8fb3a1",
    "ååååååååå¢å¥å®å²å³å´å·ååååååååå¢å¨å±å²åµå¼ååååååååå å¡å¦å®å·å¸å¹ååååååååååååå¤å¥å¦å§å¯å°å¶å·å¸åºå»å½åååååååååååå¡å¥å¨å©åªå¬å°å±å´å¶å·åååå"
  ],
  [
    "8fb4a1",
    "ååååååååå¥å§å¨å©å«å¬å­å°å²åµå¼å½å¾åååååå¡å£å¥å¬å­å²å¹å¾ååååååååå¡å¤åªå«å¯å²å´åµå·å¸åºå½åååååååååå å¦å§åµåååå¡å§å¨åªå¯å±å´åµååååååå¢å¤å¦å§å©å«å­å®å´å¿"
  ],
  [
    "8fb5a1",
    "åååååååååååå¡å¦å§å©åªå­å®å±å·å¹åºå»å¿ååååå åªå¬å¯å¶å¼å¾å¿ååååååååååªå«å²åµå¶å»å¼å½åååååååååååå å¡å¤å¦å¿åååååååååååå£å¤å­å²å¿ååååååååå"
  ],
  [
    "8fb6a1",
    "åååååå¢å©å¶å¿åååå",
    5,
    "åå¬å°å³åµå·å¹å»å¼å½å¿åååååååååååå å¡å¢å£å¦å©å­å¯å±å²åµåååååååååååå¦å§å¨å©å«å¬å­å±å³å·å¾ååååååååååååå¡å¤",
    4,
    "å±å«å­"
  ],
  [
    "8fb7a1",
    "å¶å·ååååååååååå å¢å£å¤å¥å©åªå¬å®å¯å³å´å½å¾å¿åååååå¢å¥å§å¨å«å­",
    4,
    "å³å´åµå·å¹åºå»å¼å¾åååååååååååå¡åå§å¨å©å¬å¸å½åååååååå¤å¦å§å©å­å°åµå¶å¸å½å¾å¿å å å å å¡"
  ],
  [
    "8fb8a1",
    "å å å å å å  å ¦å §å ­å ²å ¹å ¿å¡å¡å¡å¡å¡å¡å¡å¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢å¢å¢å¢å¢å¢å¢å¢å¢å¢å¢å¢å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£å¢¼å£å£å£å£å£å£å£å£å£å£å£¡å£¢å£©å£³å¤å¤å¤å¤å¤å¤å¤èå¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥å¥å¥å¥å¥å¥å¥å¥å¥å¥¡å¥£å¥«å¥­"
  ],
  [
    "8fb9a1",
    "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦å¦å¦å¦å¦å¦å¦å¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§å§å§å§å§å§å§å§å§å§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨å¨å¨å¨å¨å¨å¨å¨å¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©å©å©å©å©å©å©å©å©£å©¥å©§å©­å©·å©ºå©»å©¾åªåªåªåªåªåªåªåªåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"
  ],
  [
    "8fbaa1",
    "å«å«å«å«å«å«å« å«¥å«ªå«®å«µå«¶å«½å¬å¬å¬å¬å¬´å¬å¬å¬å¬¡å¬¥å¬­å¬¸å­å­å­å­å­å­å­¨å­®å­¯å­¼å­½å­¾å­¿å®å®å®å®å®å®å®å®å®å®å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯å¯å¯å¯å¯",
    4,
    "å¯ å¯¯å¯±å¯´å¯½å°å°å°å°å°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±å±å±å±¢å±£å±§å±¨å±©"
  ],
  [
    "8fbba1",
    "å±­å±°å±´å±µå±ºå±»å±¼å±½å²å²å²å²å²å²å²å² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³å³å³å³å³å³®å³±å³²å³´å´å´å´å´å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµåµåµåµåµåµåµåµåµåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶å¶å¶å¶å¶å¶å¶å¶å¶å¶å¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·å·å·å·å·å·å·å· å·¤"
  ],
  [
    "8fbca1",
    "å·©å·¸å·¹å¸å¸å¸å¸å¸å¸å¸å¸å¸ å¸®å¸¨å¸²å¸µå¸¾å¹å¹å¹å¹å¹å¹å¹å¹å¹å¹¨å¹ª",
    4,
    "å¹°åºåºåºåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»å»å»å»å»å»å»å»å»å»å»¥å»«å¼å¼å¼å¼å¼å¼å¼å¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½å½å½å½å½å½å½å½å½å½ å½£å½¤å½§"
  ],
  [
    "8fbda1",
    "å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾å¾å¾å¾å¾å¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿å¿å¿å¿å¿å¿",
    4,
    "å¿å¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼ææææææææææ¤æ­æ³æµæææææææææææ¡æ§æ±æ¾æ¿ææææææææææææ¢æ¤æ¥æ¨æ°æ±æ·"
  ],
  [
    "8fbea1",
    "æ»æ¾æææææææææææææææ¢æ¥æ²æµæ¸æ¼æ½æææææ",
    4,
    "ææææææ¢æªæ«æ°æ±æµæ¶æ·æ¹ææææææ æ¬æ²æ¸æ»æ¼æ¿ææææææææææææææ æ¥æ¨æªæ­æ¸æ¹æ¼æææææææææææ¡æ¢æ§æ©æ¥"
  ],
  [
    "8fbfa1",
    "æ¬æ­æ¯ææææææææ æ¢æ£æ§æ©æ«æ¹æ½æææææææææææææ¤æ­æ¯æ³æºæ½æææææ¦æ¨æ³æ¶æ·æºæ¾æ¿ææææææªæ²æ´æ¼æ½ææææææææææ©æªæ­æµæ¶æ¹æ¼ææææææææææææææ¥æ¦æ¬æ­æ±æ´æµ"
  ],
  [
    "8fc0a1",
    "æ¸æ¼æ½æ¿æææææææææææ¤æ¦æ­æ®æ¯æ½ææææææææææ æ¥æªæ¬æ²æ³æµæ¸æ¹ææææææææ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿ææææææææææææ æ¡æ£æ­æ³æ´æ»æ½æææææææææææ¡æ£æ¦æ¨æ¬æ³æ½æ¾æ¿"
  ],
  [
    "8fc1a1",
    "æææææææææææ¤æ¥æ©æªæ­æ°æµæ·æ»æ¿ææææææææææææææ¢æ¦æ©æ®æ±æºæ¼æ½ææææææææ æ§æ«æºæ½ææææææææ æ£æ¦æ®æ²æ³æ´æ¿ææææææææææ°æ²æ´æµæ¹æ¾æ¿ææææææææææ"
  ],
  [
    "8fc2a1",
    "ææ¡æ¢æ£æ¤æ¦æ©æªæ«æ¬æ®æ°æ±æ³æ¹æ·æææææææææææææ æ¡æ»æªæ«æ¬æ¾æ³æµæ¿æ·æ¸æ¹æ»ææ¼æææææææææææ æ¤æ­æ±æ²æµæ»æ¿æææææææææææ¨æ«æ¬æ®æºæææææææ æ¢æ³æ¾æææææææ"
  ],
  [
    "8fc3a1",
    "æ¦æ¬æ®æ´æ¶æ»æææææææææææ°æ±æ²æµæ»æ¼æ½æ¹æææææææææææ¡æ¦æ°æ²æ¶æ·æ¡æ æ æ æ æ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡æ¡æ¡æ¡æ¡æ¡æ¡æ¡æ¡«æ¡®",
    4,
    "æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢æ¢æ¢æ¢æ¢æ¢æ¢æ¢æ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£æ£æ£æ£"
  ],
  [
    "8fc4a1",
    "æ£æ£æ£æ£æ£æ£æ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤æ¤æ¤æ¤æ¤æ¤æ¤æ¤æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥æ¥æ¥æ¥æ¥æ¥æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦æ¦æ¦æ¦æ¦æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§æ§æ§æ§æ§æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨æ¨æ¨æ¨æ¨æ¨æ¨æ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"
  ],
  [
    "8fc5a1",
    "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©æ©æ©æ©æ©æ©æ©æ©æ©æ©æ©æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªæªæªæªæªæªæªæªæªæªæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«æ«æ«æ«æ«æ«æ«æ«æ«æ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬æ¬æ¬æ¬æ¬æ¬æ¬æ¬æ¬æ¬æ¬æ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­æ­æ­æ­æ­æ­æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"
  ],
  [
    "8fc6a1",
    "æ­¾æ®æ®æ®æ®æ®æ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯æ¯æ¯æ¯æ¯æ¯æ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°æ°æ°æ°æ°æ°æ°æ°æ°æ°æ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±æ±æ±æ±æ±æ±æ±æ±æ±æ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²°æ²²æ²´æ³æ³æ³æ³æ³æ³æ³æ³æ³"
  ],
  [
    "8fc7a1",
    "æ³æ³æ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´æ´æ´æ´æ´æ´æ´æ´æ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµæµæµæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶æ¶æ¶æ¶æ¶æ¶æ¶æ¶æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·æ·æ·æ·æ·æ·æ·æ·æ·æ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸æ¸æ¸æ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹"
  ],
  [
    "8fc8a1",
    "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæºæºæº æº§æº­æº®æº±æº³æº»æº¿æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼æ¼æ¼æ¼æ¼æ¼æ¼æ¼æ¼æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½æ½æ½æ½æ½æ½æ½æ½æ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾æ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿æ¿æ¿æ¿"
  ],
  [
    "8fc9a1",
    "æ¿æ¿æ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ççççççç ç£ç¯ç´ç·ç¹ç¼çççççççççççç¤ç¥ç¬ç®çµç¶ç¾çççç",
    4,
    "çç¤ç«ç°ç±ç´ç·ççççççççç¤çºç",
    4,
    "ççççç ç«ç­ç¯ç°ç±ç¸ççççççççççççç "
  ],
  [
    "8fcaa1",
    "ç¨ç¹çççççççç ç¢ç¯ç°ç²ç³çºç¿ççççççççççç¸ç¾çççççççççç¤ç«ç¯ç´ç¸ç¹çççççççççççççç ç£ç¨ç«ç®ç¯ç±ç·ç¸ç»ç¼ç¿ççççççç¨ç­ç®ç±ç´ç¾ççççççççç¥ç³ç´çºç»"
  ],
  [
    "8fcba1",
    "ç¾çççççççççççç¢ç¤ç§ç¨ç¬ç±ç²çµçºç»ç½çççççççççç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼ççççççççççççççç ç¢ç¥ç¦çªç«ç­çµç·ç¹ç¼ç½ç¿çççççççççççç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"
  ],
  [
    "8fcca1",
    "ç¿ççççççççç¤ç¦ç¨",
    9,
    "ç¹çççççççççççç¢ç¦ç§ç¨ç«ç­ç®ç±ç²çççççççççççççççç ç¡ç£ç¦ç¨ç©çªç«ç®ç¯ç±ç²çµç¹ç»ç¿ççççççççççç¤ç¨çªç«ç¯ç´çºç»ç¼ç¿ç"
  ],
  [
    "8fcda1",
    "çççç ç¡ç¤ç§ç©çªç¯ç¶ç¹ç½ç¾ç¿ççççççççççç¡ç¯ç±ç¹",
    5,
    "ççççççççç¢ç¤ç´çºç¿ççççççççççç ç¡ç¤ç§ç¬ç®ç¯ç±ç¹ççççççççççççççççççç£ç¥ç¦ç©ç­ç²ç³çµç¸ç¹"
  ],
  [
    "8fcea1",
    "çºç¼çççççççççççç¤ç¥ç­ç®ç¯ç±ç´çççççççççç ç¢",
    6,
    "çªç­ç½ççççççççç ç¦ç¨ç¬ç°ç±ç¶ç¹ç¼çççççççççççç¢ç¨ç­ç®ç¯ç´çµç¶ç¹ç½ç¾çççççççççççççç ç¢"
  ],
  [
    "8fcfa1",
    "ç¤ç§çªç¬ç°ç²ç³ç´çºç½çççççççççç¢ç§çªç®ç¯ç±çµç¾ççççççççç ç¤ç¦çªç¬ç°ç±ç´ç¸ç»ç ç ç ç ç ç ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢ç¢ç¢ç¢ç¢¡ç¢ç¢ç¢ç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"
  ],
  [
    "8fd0a1",
    "ç¢»ç¢½ç¢¿ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£¤ç£ç£ç£ ç£¡ç£¦ç£ªç£²ç£³ç¤ç£¶ç£·ç£ºç£»ç£¿ç¤ç¤ç¤ç¤ç¤ç¤ç¤ç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§"
  ],
  [
    "8fd1a1",
    "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨ç¨ç¨ç¨ç¨ç¨ç¨ç¨ç¨ç¨ç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©ç©ç©ç©ç©ç©ç©ç©ç©ç©ç©ç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çªçªçªçªçªçªçªçªçªçªçª çª£çª¬çª³çªµçª¹çª»çª¼ç«ç«ç«ç«ç«ç«ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬ç¬ç¬ç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"
  ],
  [
    "8fd2a1",
    "ç¬±ç¬´ç¬½ç¬¿ç­ç­ç­ç­ç­ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®ç®ç®ç®ç®ç®ç®ç®ç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°ç°ç°ç°ç°ç°ç°ç°ç°ç°ç°ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±ç±ç±ç±ç±ç±ç±",
    5
  ],
  [
    "8fd3a1",
    "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²ç²ç²ç²ç²ç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³ç³ç³ç³ç³ç³ç³ç³ç³ç³ç³ç³ç³ç³¦ç³©ç³«ç³µç´ç´ç´ç´ç´ç´ç´ç´ç´ç´ç´ç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµçµçµçµçµçµçµçµçµçµçµçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶ç¶ç¶ç¶ç¶ç¶ç¶ç¶ç¶ç¶ç¶ç¶"
  ],
  [
    "8fd4a1",
    "ç¶ç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·",
    4,
    "ç·ç·ç·ç·ç·ç¸ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ç¸ç¸ç¸ç¸ç¸ç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹ç¹ç¹ç¹ç¹ç¹ç¹ç¹ç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçºçºçºçºçºçºçºçºçºçºç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ç½ç½ç½ç½ç½ç½ç½ç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"
  ],
  [
    "8fd5a1",
    "ç½±ç½½ç½¾ç½¿ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾ç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿èèèèèèèèèèèèèè è¤è¦è¬è®è°è´èµè·è¹èºè¼è¾èèè è¤è¦è­è±èµèèèèèè¦è§è«è¸è¹èèèèèèèèè è­è®"
  ],
  [
    "8fd6a1",
    "è°è²è³è¶è¹èºè¾èèèèèèèè è¤è§è¬è°èµèºè¼èèèèèèè è¡è§è¨è©è­è¯è·èèèèèèèèèèèè¢è®è²è´è»èèèèèèèèèèèè¡è¤è«è¬è°è±è²èµè¶è¸è¹è½è¿èèèèèèèèè¡è¢è¨è²è´èºèèèè"
  ],
  [
    "8fd7a1",
    "èèèèèèè è£è§è­è´è»è½è¿èèèèèèèèèèèèèèè è¡è£è¤è§è¨è©èªè®è°è²è´è·èºè¼è¾è¿èèèèè è¢è¤è¨èªè­è¯è¶è·è½è¾èèèèèèèèèèèè¡è¢è¬è­è®è°è³è·èºè¼è½èèèèèèèèèèè°è¸"
  ],
  [
    "8fd8a1",
    "è½è¿èèèèèèèèèèèèèè¦è§è©è¬è¾è¿èèèèèèèèèè¨èªè¶è¸è¹è¼èèèèèèèè­è¯è¹èèèèèèèèèèèèèè è¤è¥è§èªè°è³è´è¶è¸è¼è½èèèèèèè¦è¨è©èªè¯è±è´èºè½è¾èèèèèèè"
  ],
  [
    "8fd9a1",
    "èè§èªè¯è°è±è²è·è²èºè»è½èèèèèèèèè¢è£è¤è¥è§èªè«è¯è³è´è¶è¿èè",
    4,
    "èèè",
    6,
    "è¤è«è¯è¹èºè»è½è¿èèèèèèèèèèèè è¢è¥è§è´è¶è·è¸è¼è½è¾è¿èèèèèè­èèèè è¦è¨è­è³è¶è¼"
  ],
  [
    "8fdaa1",
    "è¿èèèèèèèèèèèèè¡è§è©è¶è¸èºè¼è½èèèèèèèèèèè ",
    4,
    "è©è¬è¯èµè¶è·èºèèèèèèè¡è¦è§è¨è­è±è³è´èµè·è¸è¹è¿èèèèèèèèèèè è£è¥è§èèºè¼è½èèèèèèèèèèèèè¡è£"
  ],
  [
    "8fdba1",
    "è¨è®è¯è±è²è¹èºè¼è½è¾èèèèèèè¡è¤è¥è¯è±è²è»è",
    6,
    "èèèèèèèèèè è£è§è¬è­è®è±èµè¾è¿èèèèèèèèèèèè¢è£è¤èªè«è­è±è³è¸èºè¿è è è è è è è è è è è è è è è è è è ¨è ­è ®è °è ²è µ"
  ],
  [
    "8fdca1",
    "è ºè ¼è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡è¡ è¡¤è¡©è¡±è¡¹è¡»è¢è¢è¢è¢è¢è¢è¢ è¢¨è¢ªè¢ºè¢½è¢¾è£è£",
    4,
    "è£è£è£è£è£è£§è£¯è£°è£±è£µè£·è¤è¤è¤è¤è¤è¤è¤è¤è¤è¤è¤è¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥è¥è¥è¥è¥è¥è¥è¥è¥è¥è¥è¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"
  ],
  [
    "8fdda1",
    "è¥»è¥¼è¥½è¦è¦è¦è¦è¦è¦è¦è¦è¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§",
    4,
    "è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨è¨è¨è¨è¨è¨è¨è¨è¨è¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©è©è©è©è©è©è©è©è©è©è©è©è©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èªèªèªèªèªèªèªèªèªèªèªèª§èª©èª®èª¯èª³"
  ],
  [
    "8fdea1",
    "èª¶èª·èª»èª¾è«è«è«è«è«è«è«è«è«è«è«è«è«¬è«°è«´è«µè«¶è«¼è«¿è¬è¬è¬è¬è¬è¬è¬è¬è¬­è¬°è¬·è¬¼è­",
    4,
    "è­è­è­è­è­è­è­è­£è­­è­¶è­¸è­¹è­¼è­¾è®è®è®è®è®è®è®è®è®è®è®è°¸è°¹è°½è°¾è±è±è±è±è±è±è±è±è±è±è±è±è±è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²"
  ],
  [
    "8fdfa1",
    "è²è²è²è²è²è²è²è²è²¤è²¹è²ºè³è³è³è³è³è³è³è³è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´è´è´è´è´èµ¥èµ©èµ¬èµ®èµ¿è¶è¶è¶è¶è¶è¶è¶è¶è¶è¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·è·è·è·è·è·è·è·è·è·è·è·è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸è¸è¸è¸è¸è¸è¸è¸ è¸¡è¸¢"
  ],
  [
    "8fe0a1",
    "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹è¹è¹è¹è¹è¹è¹è¹è¹è¹è¹è¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èºèºèºèºèºèºèºèºèºèºèº¢èº§èº©èº­èº®èº³èºµèººèº»è»è»è»è»è»è»è»è»è»è»¨è»®è»°è»±è»·è»¹è»ºè»­è¼è¼è¼è¼è¼è¼è¼è¼è¼è¼è¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½è½"
  ],
  [
    "8fe1a1",
    "è½è½è½è½",
    4,
    "è½è½è½è½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿è¿è¿è¿è¿è¿è¿è¿è¿è¿è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾ééééééé¨é©é¯éªé¬é­é³é´é·é¿éééééé¢é¦é§é¬é°é´é¹éééééééééééé é¡é¢é¥é°é²é³é´é¶é½éé¾é"
  ],
  [
    "8fe2a1",
    "éééééééééééé¥éé¶é«é¯é°é´é¾é¿ééééééééééééééé é¥é¢é£é§é©é®é¯é±é´é¶é·é¹éºé¼é½éééééééééé¡é¤é§é­é´é¹éºé»ééééééééééééé¡é¦é¨é¬é­é®é°é±é²é³é¶é»é¼é½é¿"
  ],
  [
    "8fe3a1",
    "éééééééééé¤é¥é©éªé¬",
    5,
    "é·é¹é»é½ééééééééééééééééé£é¤é¥é¦é¨é®é¯é°é³éµé¶é¸é¹éºé¼é¾ééééééééééééééé é¡é¥é§é¨é©é®é¯é°éµ",
    4,
    "é»é¼é½é¿ééééééé"
  ],
  [
    "8fe4a1",
    "ééé é¤é¥é§é¨é«é¯é²é¶é¸éºé»é¼é½é¿",
    4,
    "éééééééééééééééééé é¡é£é¥é§é¨é¬é®é°é¹é»é¿éééééééééééé¡é¤é¥é§é©éªé³é´é¶é·éééééééééééé¤é¥é§é©éªé­é¯é°é±é³é´é¶"
  ],
  [
    "8fe5a1",
    "éºé½é¿éééééééééééééé¡é£é¤é¦é¨é«é´éµé¶éºé©éééééé",
    4,
    "éééééé¢é¦é§é¹é·é¸éºé»é½ééééééééééééé®é¯é±é²é³é´é»é¿é½éééééééééé¡é£é¨é«é­é®é¯é±é²ééé¸é¹"
  ],
  [
    "8fe6a1",
    "é¾ééééééééé¡é¦é©é«é¬é´é¶éºé½é¿éééééééééééééé é¤é¦ééé¢é¤é¥é¦é¬é±é³é·é¸é¹éºé¼é½ééééééé¡é®é´é»é¼é¾é¿ééééééééééé¤é¥é¦é©é®é¯é³éºééå¶²éééééé©é¯é±éºé"
  ],
  [
    "8fe7a1",
    "ééééééé¡é¢é£é¨é±é³ééééééééééé£é§éªé®é³é¶é·é¸é»é½é¿éééééééééé¢é¬é®é±é²éµé¶é¸é¹éºé¼é¾é¿éééééééééééééééééé éé¡é¤é¯é±é´é·é¸éºé é é é é é é é é é  é £é ¦"
  ],
  [
    "8fe8a1",
    "é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡é¡é¡é¡é¡é¡é¡é¡é¡é¡é¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£é£é£é£é£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤é¤é¤é¤é¤é¤é¤é¤é¤é¤é¤é¤¢é¤¦é¤§é¤«é¤±",
    4,
    "é¤¹é¤ºé¤»é¤¼é¥é¥é¥é¥é¥é¥é¥é¥é¥é¥é¥é¥é¥é¥é¥ é¦é¦é¦é¦¦é¦°é¦±é¦²é¦µ"
  ],
  [
    "8fe9a1",
    "é¦¹é¦ºé¦½é¦¿é§é§é§é§é§é§é§é§é§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨é¨é¨é¨é¨é¨é¨é¨é¨é¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©é©é©é©é©é©é©é©é©é©é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«é«é«é«é«é«é«é«é«é«é«é« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",
    4
  ],
  [
    "8feaa1",
    "é¬é¬é¬é¬é¬é¬é¬é¬é¬é¬é¬é¬é¬é¬é¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­é­é­é­é­é­é­é­é­¡é­£é­¥é­¦é­¨é­ª",
    4,
    "é­³é­µé­·é­¸é­¹é­¿é®é®é®é®é®é®é®é®é®é®é®é®é®é®é®é®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯é¯é¯é¯é¯é¯é¯é¯é¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"
  ],
  [
    "8feba1",
    "é¯¹é¯ºé¯½é¯¿é°é°é°é°é°é°é°é°é°é°é°é°¢é°£é°¦",
    4,
    "é°±é°µé°¶é°·é°½é±é±é±é±é±é±é±é±é±é±é±é±é±é±é±é±é±é±£é±©é±ªé±é±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´é´é´é´é´é´é´é´é´¯é´°é´²é´³é´´é´ºé´¼éµé´½éµéµéµéµéµéµéµéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"
  ],
  [
    "8feca1",
    "éµ¼éµ¾é¶é¶é¶é¶é¶é¶é¶é¶é¶é¶é¶é¶é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·é·é·é·é·é·é·é·é·é·é·é· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸é¸é¸é¸é¸é¸é¸é¸é¸é¸é¸é¸é¹ºé¹»é¹¼éºéºéºéºéºéºéºéºéºéºéºéºéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»é»é»é»é»é»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"
  ],
  [
    "8feda1",
    "é»¸é»¿é¼é¼é¼é¼é¼é¼é¼é¼é¼é¼é¼é¼é¼é¼é¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½",
    4,
    "é½é½é½é½é½é½é½é½é½¨é½©é½­",
    4,
    "é½³é½µé½ºé½½é¾é¾é¾é¾é¾é¾é¾é¾é¾¡é¾¢é¾£é¾¥"
  ]
];
const require$$2 = [
  [
    "0",
    "\0",
    127,
    "â¬"
  ],
  [
    "8140",
    "ä¸ä¸ä¸ä¸ä¸ä¸ä¸ä¸ä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹ä¹ä¹ä¹ä¹ä¹ä¹ä¹ä¹ä¹ä¹ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",
    5,
    "ä¹²ä¹´",
    9,
    "ä¹¿",
    6,
    "äºäº"
  ],
  [
    "8180",
    "äºäºäºäºäºäºäºäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ä»ä»ä»ä»ä»ä»ä»ä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼ä¼",
    6,
    "ä¼ä¼ä¼",
    4,
    "ä¼ä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",
    4,
    "ä½ä½ä½",
    5,
    "ä½ä½ä½ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä¾¡ä¾¢"
  ],
  [
    "8240",
    "ä¾¤ä¾«ä¾­ä¾°",
    4,
    "ä¾¶",
    8,
    "ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿ä¿",
    4,
    "ä¿ä¿ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",
    11
  ],
  [
    "8280",
    "åååååååååååå å¢å£å¤å§å«å¯",
    10,
    "å»å½å¿ååååååååååå",
    4,
    "åååååå",
    7,
    "å¦",
    5,
    "å­",
    8,
    "å¸å¹åºå¼å½ååååååååååå",
    20,
    "å¤å¦åªå«å­",
    4,
    "å³",
    6,
    "å¼"
  ],
  [
    "8340",
    "å½",
    17,
    "å",
    5,
    "åååå",
    10,
    "å¨å©åªå«å¯å°å±å²å´å¶",
    4,
    "å¼",
    9,
    "å"
  ],
  [
    "8380",
    "ååå",
    5,
    "å",
    13,
    "å¢",
    28,
    "åååååååååååååå",
    4,
    "å£å¤å¦å§å©åªå¯å²åºå¾å¿åååååååååååååååååå¡å£å¦",
    4,
    "å­å®å´å¸å¹åºå¾å¿åååååååååå",
    5
  ],
  [
    "8440",
    "ååååååå¢å£å¥",
    5,
    "å¬å®å±å²å´å·å¾åååååååååååååå¡å¢å£å¥å¦å§åªå¬å¯å±å²å´åµå¼å¾å",
    5,
    "åååååååå"
  ],
  [
    "8480",
    "åååååå å¢å£å¤å¦å¨å«å¬å­å®å°å±å³",
    9,
    "å¾åå",
    4,
    "å",
    6,
    "ååå",
    6,
    "åå¤å¥å¦å§å®å¯å°å´",
    9,
    "åååååååååååååååååå",
    5,
    "å å¡å¢å£å¥",
    10,
    "å±",
    7,
    "å»å¼å½åååååååååå"
  ],
  [
    "8540",
    "åååååååååå¢å¤å¥å§å¨å©å«å¬å­å¯",
    9,
    "å¼å½åååååååååååååå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åååååååå"
  ],
  [
    "8580",
    "å",
    4,
    "ååååååå å¡å¤å§åªå«å¬å­å¯",
    6,
    "å·å¸å¹åºå¼å½å¾åå",
    4,
    "ååååååååååå¡å¢å§å´åºå¾å¿ååååååååååå¢å¤å¥åªå°å³å¶å·åºå½å¿ååååååååååååå",
    4,
    "å£å¥å§å©",
    7,
    "å´å¹åºå¾å¿åååååååååååååååå å¡"
  ],
  [
    "8640",
    "å¢å¥å®å°å²åµå¶å·å¹åºå¼å¾åååååååå ",
    4,
    "å«å¬å¯å°å±å´",
    5,
    "å»å¾ååååååå",
    4,
    "ååå",
    5,
    "ååååå¡å¥å¦"
  ],
  [
    "8680",
    "å¨å©å«å­å²å´åµå¶å¸å¹åºå»å½åååååå",
    4,
    "ååååå",
    4,
    "åååå å¢å£å¨å©å«å¯",
    5,
    "å¹åºå½å¿ååååååååååååååå ",
    6,
    "å¨",
    8,
    "å²å´å¶å¸åºå¼å¿",
    4,
    "åååååååååå",
    4,
    "åå å¢å§å©å­å®å°å±å´å¶å¸",
    4,
    "å¿åååå"
  ],
  [
    "8740",
    "åååååå",
    7,
    "ååååå å¡å¢å¥å¦å¨å©åªå«å®å¯å°å³åµå·å¸åºå¼å½å¾å",
    11,
    "å",
    4,
    "ååååå",
    4
  ],
  [
    "8780",
    "å£å¥å¦å§å­å®å¯å°å²å³å´åµå·å¸å¹åºå½",
    7,
    "å",
    6,
    "åååå",
    14,
    "å¤",
    10,
    "å°",
    6,
    "å¸å¹åºå»å½",
    12,
    "å",
    8,
    "åååååå£å¥",
    5,
    "å¬å®å¯å²å³å¶å·å¸å»å¼åååååå",
    6
  ],
  [
    "8840",
    "å",
    9,
    "ååå å¡å¢å¤å¥å¦å§å«å±å²å´",
    4,
    "å¼å½å¿ååååååååå",
    4,
    "ååå¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿å"
  ],
  [
    "8880",
    "åååååå",
    4,
    "å",
    6,
    "ååååå¥å¨åªå¬å¯å°å±å³åµå¶å·å¹",
    8,
    "å",
    6,
    "ååååååååååå¡å¢å£å¥",
    7,
    "å®å°å±å²å³åµå¶å·å»å¼å¾å¿å å å å å å å å å å å å å å å å å å å å å å å ¢å £å ¥",
    4,
    "å «",
    4,
    "å ±å ²å ³å ´å ¶",
    7
  ],
  [
    "8940",
    "å ¾",
    5,
    "å¡",
    6,
    "å¡å¡å¡å¡å¡å¡å¡å¡å¡",
    4,
    "å¡",
    5,
    "å¡¦",
    4,
    "å¡­",
    16,
    "å¡¿å¢å¢å¢å¢å¢å¢å¢å¢"
  ],
  [
    "8980",
    "å¢",
    4,
    "å¢",
    4,
    "å¢å¢å¢å¢ ",
    7,
    "å¢ª",
    17,
    "å¢½å¢¾å¢¿å£å£å£å£å£",
    10,
    "å£å£å£å£",
    13,
    "å£¥",
    5,
    "å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",
    7,
    "å¤å¤å¤å¤",
    4,
    "å¤å¤å¤å¤å¤å¤å¤å¤å¤å¤å¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"
  ],
  [
    "8a40",
    "å¤½å¤¾å¤¿å¥å¥å¥å¥å¥å¥å¥å¥å¥å¥å¥å¥",
    4,
    "å¥¡å¥£å¥¤å¥¦",
    12,
    "å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦å¦ å¦¡å¦¢å¦¦"
  ],
  [
    "8a80",
    "å¦§å¦¬å¦­å¦°å¦±å¦³",
    5,
    "å¦ºå¦¼å¦½å¦¿",
    6,
    "å§å§å§å§å§å§å§å§å§å§å§å§",
    4,
    "å§¤å§¦å§§å§©å§ªå§«å§­",
    11,
    "å§ºå§¼å§½å§¾å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨å¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",
    6,
    "å¨³å¨µå¨·",
    4,
    "å¨½å¨¾å¨¿å©",
    4,
    "å©å©å©",
    9,
    "å©å©å©å©å©",
    5
  ],
  [
    "8b40",
    "å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",
    8,
    "å©¸å©¹å©»å©¼å©½å©¾åª",
    17,
    "åª",
    6,
    "åª",
    13,
    "åª«åª¬"
  ],
  [
    "8b80",
    "åª­",
    4,
    "åª´åª¶åª·åª¹",
    4,
    "åª¿å«å«",
    5,
    "å«å«å«",
    4,
    "å«å«å«å«å«å«å«å«å«å«¢å«¤å«¥å«§å«¨å«ªå«¬",
    4,
    "å«²",
    22,
    "å¬",
    11,
    "å¬",
    25,
    "å¬³å¬µå¬¶å¬¸",
    7,
    "å­",
    6
  ],
  [
    "8c40",
    "å­",
    7,
    "å­å­å­å­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®å®å®å®å®å®å®å®å®å®å®å®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯å¯å¯å¯å¯å¯å¯å¯å¯å¯"
  ],
  [
    "8c80",
    "å¯å¯",
    8,
    "å¯ å¯¢å¯£å¯¦å¯§å¯©",
    4,
    "å¯¯å¯±",
    6,
    "å¯½å¯¾å°å°å°å°å°å°å°å°å°å°å°å°å°å°å°å°å°å°å° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±å±å±å±å±å±å±å±å±å±å±å±å±å±å±å±å±å±¢å±¤å±§",
    6,
    "å±°å±²",
    6,
    "å±»å±¼å±½å±¾å²å²",
    4,
    "å²å²å²å²å²å²å²å²å²",
    4,
    "å²¤",
    4
  ],
  [
    "8d40",
    "å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³å³å³å³",
    5,
    "å³",
    5,
    "å³",
    5,
    "å³",
    6,
    "å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",
    9,
    "å³¼",
    4
  ],
  [
    "8d80",
    "å´å´å´å´",
    5,
    "å´",
    4,
    "å´å´å´å´å´å´å´å´",
    4,
    "å´¥å´¨å´ªå´«å´¬å´¯",
    4,
    "å´µ",
    7,
    "å´¿",
    7,
    "åµåµåµ",
    10,
    "åµåµåµåµ",
    10,
    "åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",
    12,
    "å¶",
    21,
    "å¶å¶å¶å¶å¶å¶ "
  ],
  [
    "8e40",
    "å¶¡",
    21,
    "å¶¸",
    12,
    "å·",
    6,
    "å·",
    12,
    "å·å·å· å·£å·¤å·ªå·¬å·­"
  ],
  [
    "8e80",
    "å·°å·µå·¶å·¸",
    4,
    "å·¿å¸å¸å¸å¸å¸å¸å¸å¸å¸å¸å¸å¸",
    7,
    "å¸¨",
    4,
    "å¸¯å¸°å¸²",
    4,
    "å¸¹å¸ºå¸¾å¸¿å¹å¹å¹å¹",
    5,
    "å¹",
    6,
    "å¹",
    4,
    "å¹å¹å¹å¹ å¹£",
    14,
    "å¹µå¹·å¹¹å¹¾åºåºåºåºåºåºåºåºåºåºåºåºåºåº¡åº¢åº£åº¤åº¨",
    4,
    "åº®",
    4,
    "åº´åººåº»åº¼åº½åº¿",
    6
  ],
  [
    "8f40",
    "å»å»å»å»",
    5,
    "å»å»å»å»å»å»å»",
    11,
    "å»©å»«",
    8,
    "å»µå»¸å»¹å»»å»¼å»½å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼å¼¡å¼¢å¼£å¼¤"
  ],
  [
    "8f80",
    "å¼¨å¼«å¼¬å¼®å¼°å¼²",
    6,
    "å¼»å¼½å¼¾å¼¿å½",
    14,
    "å½å½å½å½å½å½å½å½å½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾å¾å¾å¾å¾å¾å¾å¾å¾å¾å¾å¾å¾å¾å¾ å¾¢",
    5,
    "å¾©å¾«å¾¬å¾¯",
    5,
    "å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",
    4,
    "å¿å¿å¿å¿å¿å¿å¿å¿å¿å¿å¿å¿å¿å¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ"
  ],
  [
    "9040",
    "æææææææææææææ¢æ£æ¤æ¬æ­æ®æ°",
    4,
    "æ¶",
    4,
    "æ½æ¾ææ",
    6,
    "ææææææææææææææ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ"
  ],
  [
    "9080",
    "ææææææææææææææææææææ¡æ¢æ¤æ¥æ§æ©æªæ®æ°æ³æµæ¶æ·æ¹æºæ½",
    7,
    "ææææ",
    4,
    "æææææææææ¡",
    4,
    "æªæ±æ²æµæ·æ¸æ»",
    4,
    "æææææææææ",
    4,
    "æææææææææ¡æ¢æ¥æ¨æ©æªæ¬",
    18,
    "æ",
    6
  ],
  [
    "9140",
    "ææææææææææ",
    6,
    "æææ æ¡æ£æ¤æ¥æ¦æ©",
    6,
    "æ±æ²æ³æ´æ¶æ¸",
    18,
    "æææ",
    4,
    "æ"
  ],
  [
    "9180",
    "æ",
    6,
    "æ",
    8,
    "æªæ«æ­",
    9,
    "æ¸",
    5,
    "æ¿æææ",
    4,
    "ææ",
    4,
    "ææ",
    16,
    "æ§",
    13,
    "æ¶",
    8,
    "æ",
    5,
    "æææææææææ æ£æ¦æ§æ¨æ©æ«æ­æ¯æ°æ±æ²æµæ¶æ¸",
    4,
    "æææææ"
  ],
  [
    "9240",
    "ææææææææ",
    6,
    "æ¤æ¥æ¨æ±æ²æ´æµæ·æ¸æºæ»æ½ææææææææ",
    5,
    "ææææææ£æ¦æ§æ©æªæ­æ®æ¯æ°æ²æ³æ´æ¶æ·æ¸æºæ¾ææ"
  ],
  [
    "9280",
    "ææææææææ æ¡æ¤æªæ«æ°æ²æµæ¸æ¹æºæ»ææææææææææææææææææææ¦æ§æ©æ¬æ­æ®æ°æ±æ³",
    5,
    "æ»æ¼æ¾æ¿æææææææææææ",
    7,
    "æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æææææææææææææ",
    6,
    "æ¡æ¤æ¦æ«æ¯æ±æ²æµæ¶æ¹æ»æ½æ¿æ"
  ],
  [
    "9340",
    "ææææææææææææææ",
    6,
    "ææ¢æ¤",
    4,
    "æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æææ",
    4,
    "æææææ",
    5,
    "æææ¢æ£æ¤"
  ],
  [
    "9380",
    "æ¥æ§æ¨æ©æ«æ®",
    5,
    "æµ",
    4,
    "æ»æ¼æ¾æææææ",
    6,
    "æææææ",
    4,
    "æ",
    7,
    "æ¨æªæ«æ¬æ®",
    9,
    "æ»",
    6,
    "æææ",
    8,
    "æææææææææ",
    4,
    "æ¥æ¦æ§æ¨æªæ«æ¯æ±æ²æ³æ´æ¶æ¹æ»æ½æ¾æ¿ææææ",
    6,
    "ææææææææ"
  ],
  [
    "9440",
    "æææææ æ¡æ£æ¥æ§",
    24,
    "æ",
    7,
    "æ",
    7,
    "æ",
    4,
    "æ",
    8
  ],
  [
    "9480",
    "æ¢æ£æ¤æ¦",
    4,
    "æ¬æ­æ°æ±æ²æ³æ·æºæ¼æ½æ",
    4,
    "ææææææææææææææææ æ¡æ¤æ¥æ§æ¨æ©æªæ­æ®æ¯æ±æ³æµæ¶æ¸",
    14,
    "æææææææææææææææ æ¢æ£æ¦æ¨æªæ¬æ®æ±",
    7,
    "æºæ»æ¾æ¿æææææææææææææ",
    7,
    "æ¡æ£æ¤æªæ«"
  ],
  [
    "9540",
    "æ²æ³æ´æµæ¸æ¹æ»",
    4,
    "æææææææææææææææææææ¡æ¢æ£æ¤æ¦æ©æªæ«æ¬æ®æ°æ²æ³æ·",
    4,
    "æ½æ¿æææ",
    6,
    "æææææ"
  ],
  [
    "9580",
    "ææææææ æ¢æ£æ¥æ§æ©",
    4,
    "æ±æ²æ³æµæ¸æ¹æ»æ¼æ½æ¿ææææææææææææææææææ",
    4,
    "æ",
    8,
    "æ©",
    4,
    "æ¯",
    4,
    "æµæ¶æ·æ¸æºæ»æ¼æ½æ¿",
    25,
    "ææ",
    7,
    "æ§æ¨æª",
    5,
    "æ±æµæ¶æ¸æºæ»æ½æææ"
  ],
  [
    "9640",
    "æææææææææææææææææ ",
    5,
    "æ§æ©æ®æ°æ²æ³æ¶æ·æ¸æ¹æ»æ¼æ¾æ¿æææææææææææ",
    4,
    "ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"
  ],
  [
    "9680",
    "æ¸æ¹æºæ»æ½ææææææææææææææææææææ æ¡æ¤æ¦æ©æ¬æ®æ±æ²æ´æ¹",
    7,
    "ææ",
    9,
    "ææææææ¡æ£æ¤æ¦æ§æ¨æªæ«æ­æ®æ²æµ",
    7,
    "æ¾æ æ æ æ æ æ æ æ æ æ æ ",
    4,
    "æ æ æ  æ ¢",
    6,
    "æ «",
    6,
    "æ ´æ µæ ¶æ ºæ »æ ¿æ¡æ¡æ¡æ¡æ¡æ¡",
    5
  ],
  [
    "9740",
    "æ¡æ¡æ¡æ¡æ¡ªæ¡¬",
    7,
    "æ¡µæ¡¸",
    8,
    "æ¢æ¢æ¢",
    7,
    "æ¢æ¢æ¢æ¢æ¢æ¢æ¢",
    9,
    "æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"
  ],
  [
    "9780",
    "æ¢¹",
    6,
    "æ£æ£",
    5,
    "æ£æ£æ£æ£æ£æ£æ£æ£æ£æ£æ£æ£",
    4,
    "æ£¡æ£¢æ£¤",
    9,
    "æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤æ¤æ¤æ¤æ¤",
    4,
    "æ¤æ¤æ¤æ¤",
    11,
    "æ¤¡æ¤¢æ¤£æ¤¥",
    7,
    "æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥æ¥æ¥",
    16,
    "æ¥æ¥æ¥æ¥æ¥æ¥æ¥"
  ],
  [
    "9840",
    "æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",
    4,
    "æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦æ¦æ¦æ¦æ¦æ¦",
    5,
    "æ¦æ¦æ¦æ¦æ¦",
    9,
    "æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"
  ],
  [
    "9880",
    "æ¦¾æ¦¿æ§æ§",
    7,
    "æ§æ§æ§æ§æ§æ§æ§",
    5,
    "æ§æ§æ§æ§¡",
    11,
    "æ§®æ§¯æ§°æ§±æ§³",
    9,
    "æ§¾æ¨",
    9,
    "æ¨",
    11,
    "æ¨",
    5,
    "æ¨ æ¨¢",
    5,
    "æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",
    6,
    "æ¨¿",
    4,
    "æ©æ©æ©",
    7,
    "æ©",
    6,
    "æ©"
  ],
  [
    "9940",
    "æ©",
    4,
    "æ©¢æ©£æ©¤æ©¦",
    10,
    "æ©²",
    6,
    "æ©ºæ©»æ©½æ©¾æ©¿æªæªæªæª",
    8,
    "æªæª",
    4,
    "æª",
    7,
    "æª¡",
    5
  ],
  [
    "9980",
    "æª§æª¨æªªæª­",
    114,
    "æ¬¥æ¬¦æ¬¨",
    6
  ],
  [
    "9a40",
    "æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­æ­æ­æ­æ­æ­æ­æ­æ­",
    11,
    "æ­",
    7,
    "æ­¨æ­©æ­«",
    13,
    "æ­ºæ­½æ­¾æ­¿æ®æ®æ®"
  ],
  [
    "9a80",
    "æ®æ®æ®æ®æ®æ®æ®æ®æ®æ®æ®",
    4,
    "æ®¢",
    7,
    "æ®«",
    7,
    "æ®¶æ®¸",
    6,
    "æ¯æ¯æ¯æ¯",
    4,
    "æ¯æ¯æ¯æ¯æ¯æ¯æ¯",
    4,
    "æ¯¢",
    7,
    "æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",
    6,
    "æ°",
    4,
    "æ°æ°æ°æ°æ°æ°æ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±æ±æ±æ±æ±",
    4,
    "æ±æ±æ±æ±æ±"
  ],
  [
    "9b40",
    "æ±æ±æ±¢æ±£æ±¥æ±¦æ±§æ±«",
    4,
    "æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ²æ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³æ³æ³æ³æ³æ³æ³æ³æ³æ³æ³æ³æ³æ³"
  ],
  [
    "9b80",
    "æ³æ³æ³æ³æ³æ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´æ´",
    5,
    "æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµæµæµæµæµæµæµæµæµæµæµæµæµæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",
    4,
    "æ¶æ¶æ¶æ¶æ¶æ¶æ¶æ¶æ¶æ¶æ¶",
    4,
    "æ¶æ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",
    5,
    "æ·æ·æ·æ·æ·æ·"
  ],
  [
    "9c40",
    "æ·æ·æ·æ·æ·æ·æ·æ·æ·æ·æ·æ·æ·æ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",
    7,
    "æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸æ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"
  ],
  [
    "9c80",
    "æ¸¶æ¸·æ¸¹æ¸»",
    7,
    "æ¹",
    7,
    "æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹æ¹ ",
    10,
    "æ¹¬æ¹­æ¹¯",
    14,
    "æºæºæºæºæºæºæº",
    4,
    "æº",
    6,
    "æºæºæºæºæºæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»æ»£æ»§æ»ª",
    5
  ],
  [
    "9d40",
    "æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",
    7,
    "æ¼æ¼æ¼æ¼æ¼æ¼",
    4,
    "æ¼æ¼æ¼æ¼",
    9,
    "æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",
    6,
    "æ¼¿æ½æ½æ½"
  ],
  [
    "9d80",
    "æ½æ½æ½æ½æ½æ½æ½æ½",
    9,
    "æ½æ½æ½æ½æ½æ½ æ½¡æ½£æ½¤æ½¥æ½§",
    5,
    "æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",
    6,
    "æ¾æ¾æ¾æ¾æ¾æ¾",
    12,
    "æ¾æ¾æ¾æ¾ æ¾¢",
    4,
    "æ¾¨",
    10,
    "æ¾´æ¾µæ¾·æ¾¸æ¾º",
    5,
    "æ¿æ¿",
    5,
    "æ¿",
    6,
    "æ¿",
    10,
    "æ¿æ¿¢æ¿£æ¿¤æ¿¥"
  ],
  [
    "9e40",
    "æ¿¦",
    7,
    "æ¿°",
    32,
    "ç",
    7,
    "ç",
    6,
    "ç¤",
    6
  ],
  [
    "9e80",
    "ç«",
    9,
    "ç¶ç·ç¸çº",
    17,
    "ççç",
    13,
    "ç",
    11,
    "ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ççççççççççççççççççç",
    12,
    "ç°ç²ç´çµç¶çºç¾ç¿çççççç",
    12,
    "ç"
  ],
  [
    "9f40",
    "çççç ç¡ç¢ç£ç¥çªç®ç°",
    6,
    "ç¸çºç»ç¼ç¾",
    10,
    "ç",
    4,
    "ççççç",
    10,
    "ç§",
    7,
    "ç²ç³ç´"
  ],
  [
    "9f80",
    "çµç·",
    13,
    "ççççççç",
    12,
    "çç",
    4,
    "ç¥ç©",
    4,
    "ç¯ç°ç±ç´çµç¶ç·ç¹ç»ç¼ç¾",
    5,
    "ç",
    4,
    "çççççççççççç",
    4,
    "ç¡",
    6,
    "ç©çªç«ç­",
    5,
    "ç´ç¶ç·ç¸çº",
    8,
    "ç",
    9,
    "ç",
    4
  ],
  [
    "a040",
    "ç",
    9,
    "ç¡ç¢ç£ç¤ç¦ç¨",
    5,
    "ç¯",
    9,
    "çº",
    11,
    "ç",
    19
  ],
  [
    "a080",
    "ççç",
    9,
    "ç©ç«ç­ç®ç¯ç²ç³ç´çºç¼ç¾ç",
    6,
    "çççççççççççççççç ç£ç¤ç¥ç¨çªç«ç¬ç­ç°ç±ç³ç´ç¶ç·ç¸ç»ç¼ç½ççç",
    4,
    "ççççç",
    11,
    "ç ",
    11,
    "ç®ç±ç²ç³çµçº",
    6,
    "çççççççççççççççç"
  ],
  [
    "a1a1",
    "ãããÂ·ËËÂ¨ããâï½ââ¦ââââããã",
    7,
    "ããããÂ±ÃÃ·â¶â§â¨âââªâ©ââ·ââ¥â¥â âââ«â®â¡âââ½ââ â®â¯â¤â¥ââµâ´ââÂ°â²â³âï¼Â¤ï¿ ï¿¡â°Â§âââââââââ¡â â³â²â»ââââã"
  ],
  [
    "a2a1",
    "â°",
    9
  ],
  [
    "a2b1",
    "â",
    19,
    "â´",
    19,
    "â ",
    9
  ],
  [
    "a2e5",
    "ã ",
    9
  ],
  [
    "a2f1",
    "â ",
    11
  ],
  [
    "a3a1",
    "ï¼ï¼ï¼ï¿¥ï¼",
    88,
    "ï¿£"
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã¡",
    85
  ],
  [
    "a6a1",
    "Î",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ï",
    6
  ],
  [
    "a6e0",
    "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹ï¸½ï¸¾ï¹ï¹ï¹ï¹"
  ],
  [
    "a6ee",
    "ï¸»ï¸¼ï¸·ï¸¸ï¸±"
  ],
  [
    "a6f4",
    "ï¸³ï¸´"
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "ÑÐ¶",
    25
  ],
  [
    "a840",
    "ËËËâââ¥âµâââââââââ£ââ¦â§â¿â",
    35,
    "â",
    6
  ],
  [
    "a880",
    "â",
    7,
    "ââââ¼â½â¢â£â¤â¥ââããã"
  ],
  [
    "a8a1",
    "ÄÃ¡ÇÃ ÄÃ©ÄÃ¨Ä«Ã­ÇÃ¬ÅÃ³ÇÃ²Å«ÃºÇÃ¹ÇÇÇÇÃ¼ÃªÉ"
  ],
  [
    "a8bd",
    "ÅÅ"
  ],
  [
    "a8c0",
    "É¡"
  ],
  [
    "a8c5",
    "ã",
    36
  ],
  [
    "a940",
    "ã¡",
    8,
    "ã£ãããããã¡ãããããï¸°ï¿¢ï¿¤"
  ],
  [
    "a959",
    "â¡ã±"
  ],
  [
    "a95c",
    "â"
  ],
  [
    "a960",
    "ã¼ããã½ã¾ãããï¹",
    9,
    "ï¹ï¹ï¹ï¹ï¹",
    8
  ],
  [
    "a980",
    "ï¹¢",
    4,
    "ï¹¨ï¹©ï¹ªï¹«"
  ],
  [
    "a996",
    "ã"
  ],
  [
    "a9a4",
    "â",
    75
  ],
  [
    "aa40",
    "çççç¢",
    5,
    "çªç«çµç¶ç¹ç½ç¾ç¿ççç",
    5,
    "ççççççççççççç ç£ç¤ç¦ç§ç¨ç­ç¯ç°ç²ç³çµç¶çºç»ç¼ç½ç",
    8
  ],
  [
    "aa80",
    "çççççççççççç",
    7,
    "ç¡",
    10,
    "ç®ç°ç±"
  ],
  [
    "ab40",
    "ç²",
    11,
    "ç¿",
    4,
    "çççççççççççççççççççç ç¡ç£",
    5,
    "çªç¬ç­ç±ç´çµç¶ç¸ç¹ç¼ç½ç¾ç¿çç",
    4
  ],
  [
    "ab80",
    "çççç",
    6,
    "çççççç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³",
    4
  ],
  [
    "ac40",
    "ç¸",
    10,
    "çççççççç",
    8,
    "ç",
    5,
    "ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",
    4,
    "ç½ç¾ç¿çç",
    11
  ],
  [
    "ac80",
    "ç",
    6,
    "çççç ",
    12,
    "ç®ç¯ç±",
    4,
    "ç¸ç¹çº"
  ],
  [
    "ad40",
    "ç»ç¼ç½ç¿ççççççççççç",
    10,
    "çç",
    7,
    "çª",
    15,
    "ç»",
    12
  ],
  [
    "ad80",
    "ç",
    9,
    "ç",
    8,
    "ççç¡ç¥ç§",
    6,
    "ç°ç±ç²"
  ],
  [
    "ae40",
    "ç³çµç¸",
    6,
    "ççççç",
    7,
    "ççççççççççç ",
    4,
    "ç¦ç§çªç®ç´ç¶ç¹ç¼ç½ç¿ççççççççççççççççç"
  ],
  [
    "ae80",
    "ç",
    7,
    "ç§ç¨ç©ç«",
    6,
    "ç³çµç¶ç·çº",
    4,
    "çççççç"
  ],
  [
    "af40",
    "çççççççççççççç¢ç¦",
    4,
    "ç­ç¶ç·çºç»ç¿ççççççççççççççççç ç¡ç¥ç©ç¬ç­ç®ç¯ç²ç³çµç¶ç·ç¸çºç»ç½ç¾çççç"
  ],
  [
    "af80",
    "çççççççççççççççç¡ç£ç§ç¨ç¬ç®ç¯ç±ç²ç¶ç·ç¹çºç»ç½ççç"
  ],
  [
    "b040",
    "ç",
    6,
    "ç",
    5,
    "çç",
    4,
    "ççç ç¡ç¢ç¤",
    6,
    "ç¬ç­ç®ç°",
    7,
    "ç¹çºç¼ç¿ççççççççççççççççç"
  ],
  [
    "b080",
    "ç",
    7,
    "ç¥",
    8,
    "ç¯ç°ç³çµ",
    9,
    "çççåé¿åæ¨åååççè¼ç®è¾ç¢ç±ééæ°¨å®ä¿ºææå²¸èºæ¡è®æçå¹æç¬ç¿±è¢å²å¥¥ææ¾³è­ææå­å§ç¬å«ç¤å·´æè·é¶æèåé¸ç½¢ç¸ç½æç¾æä½°è´¥æç¨æç­æ¬æ³è¬é¢æ¿çæ®æä¼´ç£ååç»é¦å¸®æ¢æ¦èç»æ£ç£èéåè°¤èèåè¤å¥"
  ],
  [
    "b140",
    "ççççççççççççç ",
    4,
    "ç¦",
    7,
    "ç°ç³çµç¶ç·çºç»ç½ç¿çççççççç",
    10,
    "ççççç¡ç£ç¤ç¥ç§çªç«"
  ],
  [
    "b180",
    "ç¬ç®ç°",
    4,
    "ç¹ç»ç½ç¾ç¿ççççç",
    7,
    "ç",
    7,
    "çèé¹ä¿å ¡é¥±å®æ±æ¥æ´è±¹é²çæ¯ç¢æ²ååè¾èè´é¡åçå¤æ«çè¢«å¥è¯æ¬ç¬¨å´©ç»·ç­æ³µè¹¦è¿¸é¼é¼»æ¯éç¬å½¼ç¢§èè½æ¯æ¯æ¯å¸åºç¹é­æå¼å¿è¾å£èé¿éé­è¾¹ç¼è´¬æä¾¿ååè¾¨è¾©è¾«éæ å½ªèè¡¨é³æå«çªå½¬ææ¿æ»¨å®¾æåµå°æä¸ç§é¥¼ç³"
  ],
  [
    "b240",
    "çççç ç¤ç§ç©çªç­",
    11,
    "çºç»ç¼çççç",
    5,
    "ççç",
    11,
    "ç¡ç£ç¤ç¦ç¨ç«ç­ç®ç¯ç±ç²ç´ç¶",
    4
  ],
  [
    "b280",
    "ç¼ç¾ç",
    12,
    "ç",
    8,
    "çççç",
    4,
    "ç¤çå¹¶ç»è æ­æ¨éµæ³¢ååæéç®ä¼¯å¸è¶èèæ¸¤æ³é©³æååºè¡¥å ä¸å¸æ­¥ç°¿é¨ææ¦çè£ææè´¢ç¬è¸©éå½©èè¡é¤åèæ®æ­æ¨ç¿èè±ä»æ²§èæç³æ§½æ¹èåç­ä¾§åæµå±è¹­æåè¬è¶æ¥ç¢´æ½å¯å²å·®è¯§ææ´è±ºææºèé¦è°ç¼ é²äº§éé¢¤æç"
  ],
  [
    "b340",
    "ç¦ç¨çªç¯ç°ç±ç²ç´çµç·ç¹çºç»ç¼ç ",
    5,
    "ç ç ç ç ç ç ç ç ç ç ç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡ç¡"
  ],
  [
    "b380",
    "ç¡ç¡ç¡",
    11,
    "ç¡¯",
    7,
    "ç¡¸ç¡¹ç¡ºç¡»ç¡½",
    6,
    "åºå°å¸¸é¿å¿è åæçå±å¡è¶æéæå²æ½®å·¢åµçè½¦æ¯æ¤æ£å½»æ¾é´è£è¾°å°æ¨å¿±æ²éè¶è¡¬æç§°åæ©æåä¹ç¨æ©æ¾è¯æ¿ééªç§¤åç´æåæ± è¿å¼é©°è»é½¿ä¾å°ºèµ¤ç¿æ¥ç½åå²è«å´å® æ½é¬ç´è¸ç¨ æç­¹ä»ç»¸çä¸è­ååºæ©±å¨èºééæ»é¤æ¥"
  ],
  [
    "b440",
    "ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ ç¢¢ç¢¤ç¢¦ç¢¨",
    7,
    "ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£ç£",
    9
  ],
  [
    "b480",
    "ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",
    4,
    "ç£³ç£µç£¶ç£¸ç£¹ç£»",
    5,
    "ç¤ç¤ç¤ç¤",
    6,
    "ç¡å¨çæè§¦å¤æ£å·ç©¿æ¤½ä¼ è¹åä¸²ç®çªå¹¢åºé¯åå¹çæ¶é¤åæ¥æ¤¿éåæ·³çº¯è ¢æ³ç»°çµè¨ç£éè¾æç·è¯æ­¤åºèµæ¬¡èªè±å±åä»ä¸åç²éç°ä¿è¹¿ç¯¡çªæ§å´å¬èçç²¹æ·¬ç¿ æå­å¯¸ç£æ®ææªæ«éæ­è¾¾ç­ç©æå¤§åæ­¹å£æ´å¸¦æ®ä»£è´·è¢å¾é®"
  ],
  [
    "b540",
    "ç¤",
    5,
    "ç¤",
    9,
    "ç¤",
    4,
    "ç¤¥",
    14,
    "ç¤µ",
    4,
    "ç¤½ç¤¿ç¥ç¥ç¥ç¥ç¥ç¥",
    8,
    "ç¥ç¥ç¥ç¥ç¥¡ç¥£"
  ],
  [
    "b580",
    "ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",
    6,
    "ç¥¹ç¥»",
    4,
    "ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦ç¦æ è½æä¸¹åé¸æ¸èæ¦æ°®ä½æ®æ·¡è¯å¼¹èå½æ¡åè¡æ¡£åæ£è¹åå²ç¥·å¯¼å°ç¨»æ¼éçå¾·å¾çè¹¬ç¯ç»ç­çªå³éå ¤ä½æ»´è¿ªæç¬çæ¶¤ç¿å«¡æµåºå°èç¬¬å¸å¼éç¼é¢ ææ»ç¢ç¹å¸éå«çµä½ç¸åºæ¦å¥ æ·æ®¿ç¢å¼éååæåéè°è·ç¹ç¢è¶è¿­è°å "
  ],
  [
    "b640",
    "ç¦",
    6,
    "ç¦",
    11,
    "ç¦¨",
    10,
    "ç¦´",
    4,
    "ç¦¼ç¦¿ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§ç§",
    5,
    "ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"
  ],
  [
    "b680",
    "ç§¬ç§®ç§±",
    6,
    "ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨ç¨ç¨ç¨ç¨ç¨ç¨ç¨",
    4,
    "ç¨ç¨ç¨ç¨ç¨ç¨ä¸ç¯å®éé¡¶é¼é­å®è®¢ä¸¢ä¸å¬è£æå¨æ ä¾æ«å»æ´åææé¡è±éçé½ç£æ¯çç¬è¯»å µç¹èµæéèåº¦æ¸¡å¦ç«¯ç­é»æ®µæ­ç¼å åéå¯¹å¢©å¨è¹²æ¦é¡¿å¤éç¾éæåå¤å¤ºåèº²æµè·ºèµåæ°å è¾å³¨é¹ä¿é¢è®¹å¨¥æ¶åæ¼ééé¥¿æ©èå¿è³å°é¥µæ´±äº"
  ],
  [
    "b740",
    "ç¨ç¨ç¨¡ç¨¢ç¨¤",
    14,
    "ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©",
    5,
    "ç©",
    9,
    "ç©",
    4,
    "ç©",
    16
  ],
  [
    "b780",
    "ç©©",
    6,
    "ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çªçªçªçªçªçªçªçªçªçªçªçªçªçªçªçªçª¡çª¢è´°åç½ç­ä¼ä¹éæ³çè©å¸çªç¿»æ¨ç¾éç¹å¡ç¦åè¿èè´©ç¯é¥­æ³åè³æ¹èªæ¿é²å¦¨ä»¿è®¿çººæ¾è²éå¡é£è¥åªè¯½å èºåºæ²¸è´¹è¬éå©æ°åçº·åçæ±¾ç²å¥ä»½å¿¿æ¤ç²ªä¸°å°æ«èå³°éé£ç¯ç½é¢å¯ç¼è®½å¥å¤ä½å¦å¤«æ·è¤å­µæ¶æè¾å¹æ°ç¬¦ä¼ä¿æ"
  ],
  [
    "b840",
    "çª£çª¤çª§çª©çªªçª«çª®",
    4,
    "çª´",
    10,
    "ç«",
    10,
    "ç«",
    9,
    "ç«ç«ç«ç«ç«ç«ç«¡ç«¢ç«¤ç«§",
    5,
    "ç«®ç«°ç«±ç«²ç«³"
  ],
  [
    "b880",
    "ç«´",
    4,
    "ç«»ç«¼ç«¾ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼ç«æè¾ä¿¯éæ§è¯èåºèèµ´å¯è¦èµå¤åä»éç¶è¹è´å¯è®£éå¦ç¼åå¶åè¯¥æ¹æ¦éçæºå¹²çææç«¿èèµ¶æç§æ¢èµ£ååé¢ç¼¸èçº²å²æ¸¯æ ç¯çé«èç¾ç³æéç¨¿åå¥æ­ææé¸½è³çå²é©èæ ¼è¤ééé¬ä¸ªåç»æ ¹è·èæ´åºç¾¹"
  ],
  [
    "b940",
    "ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",
    5,
    "ç­ç­ç­ç­ç­ç­ç­ç­ç­ç­ç­ç­ç­¡ç­£",
    10,
    "ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®ç®ç®ç®",
    6,
    "ç®ç®"
  ],
  [
    "b980",
    "ç®ç®ç®ç®ç®ç®ç®ç®ç®ç®ç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",
    7,
    "ç¯ç¯ç¯åè¿æ¢å·¥æ»åæ­é¾ä¾èº¬å¬å®«å¼å·©æ±æ±è´¡å±é©å¾æ²èçå¢æè´­å¤è¾èåç®ä¼°æ²½å­¤å§é¼å¤èéª¨è°·è¡æé¡¾åºéå®çåå¯¡æè¤ä¹ææªæ£ºå³å®å è§ç®¡é¦ç½æ¯çè´¯åå¹¿éç°è§å­ç¡å½é¾éºè½¨é¬¼è¯¡ç¸æ¡æè·ªè´µå½è¾æ»æ£éé­å½æè£¹è¿å"
  ],
  [
    "ba40",
    "ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯ç¯",
    4,
    "ç¯ç¯ç¯ç¯ç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",
    4,
    "ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",
    7,
    "ç°ç°ç°ç°ç°ç°",
    5,
    "ç°ç°ç°"
  ],
  [
    "ba80",
    "ç°",
    4,
    "ç° ",
    5,
    "ç°¨ç°©ç°«",
    12,
    "ç°¹",
    5,
    "ç±éª¸å­©æµ·æ°¦äº¥å®³éªé£æ¨é¯é©å«æ¶µå¯å½åç½ç¿°æ¼ææ±æ¾æçæ±æ±å¤¯æ­èªå£åè±ªæ¯«éå¥½èå·æµ©åµåè·èæ ¸ç¦¾åä½åçè²éæ²³æ¶¸èµ«è¤é¹¤è´ºå¿é»çå¾ç æ¨å¼äº¨æ¨ªè¡¡æè½°åçè¹é¸¿æ´ªå®å¼çº¢åä¾¯ç´å¼åååå¼ä¹å¿½çå£¶è«è¡è´çç³æ¹"
  ],
  [
    "bb40",
    "ç±",
    9,
    "ç±",
    36,
    "ç±µ",
    5,
    "ç±¾",
    9
  ],
  [
    "bb80",
    "ç²ç²",
    6,
    "ç²ç²ç²ç²ç²ç²ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",
    4,
    "ç²ºç²»å¼§èå¬æ¤äºæ²ªæ·è±ååç¾æ»ç»ååè¯æ§å¾ææ·®åæ¬¢ç¯æ¡è¿ç¼æ¢æ£å¤çªè±¢çæ¶£å®¦å¹»èæé»ç£ºèç°§çå°æ¶çæå¹æè°ç°æ¥è¾å¾½æ¢èåæ¯ææ§åæ æ¦è´¿ç§½ä¼ç©æ±è®³è¯²ç»è¤æå©é­æµæ··è±æ´»ä¼ç«è·ææéè´§ç¥¸å»å¾åºæºç¸ç¨½ç§¯ç®"
  ],
  [
    "bc40",
    "ç²¿ç³ç³ç³ç³ç³ç³ç³ç³",
    6,
    "ç³ç³ç³ç³ç³ç³¡",
    6,
    "ç³©",
    5,
    "ç³°",
    7,
    "ç³¹ç³ºç³¼",
    13,
    "ç´",
    5
  ],
  [
    "bc80",
    "ç´",
    14,
    "ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",
    6,
    "èé¥¥è¿¹æ¿è®¥é¸¡å§¬ç»©ç¼åææ£è¾ç±éåæ¥ç¾æ±²å³å«çº§æ¤å èå·±èæåå­£ä¼ç¥­åæ¸æµå¯å¯è®¡è®°æ¢å¿éå¦ç»§çºªåæ·å¤¹ä½³å®¶å èé¢è´¾ç²é¾åç¨¼ä»·æ¶é©¾å«æ­¼çåå°ç¬ºé´çå¼è©è°å¥¸ç¼è§æ£æ¬ç¢±ç¡·æ£æ¡ç®ä¿­åªåèæ§é´è·µè´±è§é®ç®­ä»¶"
  ],
  [
    "bd40",
    "ç´·",
    54,
    "çµ¯",
    7
  ],
  [
    "bd80",
    "çµ¸",
    32,
    "å¥è°åé¥¯æ¸æºæ¶§å»ºåµå§å°æµæ±çèæ¡¨å¥è®²å é±éèæ¤ç¤ç¦è¶äº¤éæµéªå¨å¼æé°ç«ä¾¥èç¡è§é¥ºç¼´ç»å¿æéµè½¿è¾å«çªæ­æ¥çç§¸è¡é¶æªå«èæ¡æ°æ·ç«ç«­æ´ç»è§£å§æèè¥çåä»ç¥è¯«å±å·¾ç­æ¤éä»æ´¥è¥ç´§é¦ä»è°¨è¿é³æç¦è¿ç¬æµ¸"
  ],
  [
    "be40",
    "ç¶",
    12,
    "ç¶§",
    6,
    "ç¶¯",
    42
  ],
  [
    "be80",
    "ç·",
    32,
    "å°½å²èå¢èçæ¶é²¸äº¬æç²¾ç²³ç»äºè­¦æ¯é¢éå¢æ¬éå¾çéç«ç«åç¯çªæªç©¶çº çé­ä¹ç¸ä¹éå©ææ§è¼èåå°±çé æçç½å±é©¹èå±åç©ä¸¾æ²®èææ®å·¨å·è·è¸é¯ä¿±å¥æ§ç¬å§æé¹å¨å¦ç·å·ç»¢ææ«ææåçµè§å³è¯ç»åèé§ååå³»"
  ],
  [
    "bf40",
    "ç·»",
    62
  ],
  [
    "bf80",
    "ç¸ºç¸¼",
    4,
    "ç¹",
    4,
    "ç¹",
    21,
    "ä¿ç«£æµé¡éªååå¡å¯å¼æ©æ¥·å¯æ¨åå ªååç çåº·æ·ç³ ææäº¢çèæ·ç¤é å·èæ¯æ£µç£é¢ç§å£³å³å¯æ¸´åå»å®¢è¯¾è¯åå¦æ³åå­ç©ºæå­æ§æ å£æ£å¯æ¯å­çªè¦é·åºè£¤å¤¸å®æè·¨è¯åç­·ä¾©å¿«å®½æ¬¾å¡ç­çæ¡ç¿ç¶æ·åµäºçå²¿çª¥èµå¥é­å"
  ],
  [
    "c040",
    "ç¹",
    35,
    "çº",
    23,
    "çºçºçº"
  ],
  [
    "c080",
    "çº®çº´çº»çº¼ç»ç»¤ç»¬ç»¹ç¼ç¼ç¼ç¼·ç¼¹ç¼»",
    6,
    "ç½ç½",
    9,
    "ç½ç½é¦æ§æºå¤ææå°æ¬æ©å»éåæåè¡èè¾£å¦è±æ¥èµèå©ªæ æ¦ç¯®éå°æ¾è°°æ½è§æç¼çæ»¥çæ¦ç¼å»éææµªæå³ç¢èä½¬å§¥éªçæ¶åä¹é·é­è¾ç£ç´¯å¡åæèç±»æ³ªæ£±æ¥å·åæ¢¨çé»ç¯±ç¸ç¦»æ¼çæéé²¤ç¤¼èèåæ ä¸½åå±ç ¾åå©åä¾ä¿"
  ],
  [
    "c140",
    "ç½ç½ç½ç½ç½ç½ç½ ç½£",
    4,
    "ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾ç¾",
    7,
    "ç¾ç¾ç¾",
    4,
    "ç¾",
    4,
    "ç¾ç¾ç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",
    6,
    "ç¾±"
  ],
  [
    "c180",
    "ç¾³",
    4,
    "ç¾ºç¾»ç¾¾ç¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿",
    4,
    "ç¿ç¿ç¿",
    5,
    "ç¿¢ç¿£ç¢ç«ç²æ²¥é¶åçå©ä¿©èè²è¿é°å»ææ¶å¸æè¸é¾æç¼ç»ç²®åæ¢ç²±è¯ä¸¤è¾éæ¾äº®è°æ©èåççå¯¥è¾½æ½¦äºæé£å»æåè£çå£çç³æç£·éä¸´é»é³æ·åèµåæç²è±é¶é¾éä¼¶ç¾åçµéµå²­é¢å¦ä»¤æºçæ¦´ç¡«é¦çåç¤æµæ³å­é¾èåç¬¼çª¿"
  ],
  [
    "c240",
    "ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",
    6,
    "ç¿½ç¿¾ç¿¿èèèèèèèèèèèèèèè¡è£è¤è«",
    5,
    "è²è´è¹èºè¼è¾èèèèèèèèèèèèèèè"
  ],
  [
    "c280",
    "èè",
    13,
    "è«",
    5,
    "è²",
    11,
    "éåæ¢éæ¥¼å¨æç¯æ¼éè¦å¢é¢åºçæ³å¤èé²éºç¢é²è·¯èµé¹¿æ½ç¦å½éæ®é©´åéä¾£æå±¥å±¡ç¼èæ°¯å¾çæ»¤ç»¿å³¦æå­ªæ»¦åµä¹±æ ç¥æ¡è½®ä¼¦ä»æ²¦çº¶è®ºèèºç½é»é£ç®©éª¡è£¸è½æ´éªç»å¦éº»çç èé©¬éªåååä¹°éº¦åè¿èçé¦è®æ»¡èæ¼æ¢æ¼«"
  ],
  [
    "c340",
    "è¾èèèèèè",
    5,
    "èèèèèè£è¦è§è¨è¬è°è³èµè¶è¸è¹è»èè",
    4,
    "è",
    6,
    "èèè è¢è£è¦è®èµè·è¹è»è¾è¿èèèèèèèè"
  ],
  [
    "c380",
    "èèèèèèèè",
    12,
    "è­è®è°è³è´èµè·è¹",
    4,
    "è¿è°©èè«ç²æ°å¿è½ç«èéæ¯çéå¯èåå¸½è²è´¸ä¹ç«ææ¢é¶éç¤æ²¡çåªéæ¯ç¾æ§å¯å¦¹åªé¨é·ä»¬èèæª¬çé°çæ¢¦å­ç¯éé¡ç³è¿·è°å¼¥ç±³ç§è§æ³èå¯å¹æ£ç ç»µåååå¨©ç¼é¢èæçèç§æ¸ºåºå¦èç­æ°æ¿ç¿ææ¯é½æèé¸£é­åå½è°¬æ¸"
  ],
  [
    "c440",
    "è",
    5,
    "èèèèèèèèèè",
    4,
    "è¡è¢è£è¤è¦è¨èªè«è¬è¯è²è³èµè¶è·è¸èè",
    4,
    "èèèèèèè",
    5,
    "èèè",
    4,
    "è¤è¥"
  ],
  [
    "c480",
    "è§è©è«",
    7,
    "è´",
    5,
    "è¼è½è¾è¿èèèèèèè",
    6,
    "æ¹èæ¨¡èç£¨æ©é­æ¹æ«è«å¢¨é»æ²«æ¼ å¯éè°çææç¡äº©å§æ¯å¢æ®å¹åææ¨ç®ç¦ç§ç©æ¿åªåé é£å¨çº³æ°ä¹å¥¶èå¥åç·é¾åæ èæ¼é¹æ·å¢é¦åå«©è½å¦®éåªæ³¥å°¼æä½ å¿è»éæººè«æå¹´ç¢¾æµæ»å¿µå¨é¿é¸å°¿æèå­½å®ééæ¶æ¨æ çåå®"
  ],
  [
    "c540",
    "è",
    14,
    "è¤è¥è¦è¨è©è«è®",
    4,
    "èµ",
    5,
    "è½è¿èè",
    4,
    "èèèèè",
    5,
    "èè è¤è¥è¦è§è©è®è²èºè¼è½è¿"
  ],
  [
    "c580",
    "èèèèèèèèèèèè",
    7,
    "èèèèèè ",
    7,
    "è©æ§æ³çæ­é®çº½èæµåå¼å¥´åªæå¥³æèçæªæ¦ç³¯è¯ºå¦æ¬§é¸¥æ®´èåå¶æ²¤åªè¶´ç¬å¸æç¶ææçå¾æ¹æ´¾ææ½çç£ç¼çå¤åä¹åºæèªèæåå¨ç®è¢è·æ³¡å¸èå¹è£´èµéªéä½©æ²å·çç °æ¨ç¹æ¾å½­è¬æ£ç¡¼ç¯·è¨æé¹æ§ç¢°å¯ç é¹æ¹æ«åçµæ¯"
  ],
  [
    "c640",
    "èªè«è¬è­è±èµè¶è·è¸è»è¼èèèèèèèèèèèèèèèèè è¢è£è§è²èµè¶èºè»è¼è¿èèèèèèèèèèèè¢è§è¨è©èªè¬è­è®è°è²è³èµè¶è¸"
  ],
  [
    "c680",
    "èºè¼",
    4,
    "èèèèèèèèèè",
    9,
    "è©èªè®è°è²è·è»è½å¤è¾ç²ç®å¹çå»å±è­¬ç¯åçéªé£æ¼ç¢ç¥¨æç¥æ¼é¢è´«åèä¹åªè¹èå¹³å­ç¶è¯å±å¡æ³¼é¢å©ç ´é­è¿«ç²åæéºä»èè¡è©è²åæ´åæ®æµ¦è°±æçææ¬ºæ æå¦»ä¸åæ¼ææ²å¶æ£å¥æ­§ç¦å´èé½æç¥ç¥éªèµ·å²ä¹ä¼å¯å¥ç å¨æ°è¿å¼æ±½æ³£è®«æ"
  ],
  [
    "c740",
    "è¾è¿èèèèèè",
    4,
    "èè",
    4,
    "èè¢è°",
    6,
    "è¹èºè¾",
    6,
    "èèèèèèèèèèèèèèèèèè¡",
    6,
    "è¬è­è®"
  ],
  [
    "c780",
    "è¯èµè»è¾è¿èèèèèèèèèèèèèèèèèèèè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½çµæ¦ééåè¿ç­¾ä»è°¦ä¹¾é»é±é³åæ½é£æµè°´å åµæ¬ æ­æªåèç¾å¢è·å¼ºæ¢æ©é¹æ²ææ¡¥ç§ä¹ä¾¨å·§éæ¬ç¿å³­ä¿çªåèä¸æ¯çªé¦ä¾µäº²ç§¦ç´å¤è¹æç¦½å¯æ²éè½»æ°¢å¾å¿æ¸ææ´æ°°æé¡·è¯·åºç¼ç©·ç§ä¸é±çæ±åéæ³è¶åºèæ²èº¯å±é©±æ¸ "
  ],
  [
    "c840",
    "è®è¯è³",
    4,
    "èºè»è¼è¾è¿èèèèèèèèè",
    5,
    "èèèè",
    5,
    "è©",
    7,
    "è²",
    5,
    "è¹èºè»è¾",
    7,
    "èèè"
  ],
  [
    "c880",
    "è",
    6,
    "è",
    4,
    "èèèèè è¢è¤",
    4,
    "èªè®è¯è°è²è´è·è¹è»è¼åå¨¶é¾è¶£å»åé¢§æéæ³å¨çæ³ç¬å¸åç¼ºçç¸å´é¹æ¦·ç¡®éè£ç¾¤ç¶çåæç¤å£¤æå·è®©é¥¶æ°ç»æ¹ç­å£¬ä»äººå¿é§ä»»è®¤åå¦çº«æä»æ¥æè¸èè£èçæº¶å®¹ç»åææèè¹è åå­ºå¦è¾±ä¹³æ±å¥è¤¥è½¯é®èçéé°æ¶¦è¥å¼±ææ´è¨è®é³å¡èµä¸å"
  ],
  [
    "c940",
    "è½",
    4,
    "èèèèèèè",
    7,
    "èèèèèèè è¢",
    12,
    "è°è±è³èµè¶è·è»è¼è¾èèèèèèèèèèèèèèè"
  ],
  [
    "c980",
    "è",
    4,
    "èè¡è¢è¤è§",
    4,
    "è­è®è¯è±",
    10,
    "è½è¾èèèä¼æ£æ¡åä¸§æéªæ«å«çè²æ¶©æ£®å§èç æå¹æ²çº±å»å¥çç­æçè«æå±±å ç½è¡«éªéæèµ¡è³åæ±æç¼®å¢ä¼¤åèµæä¸å°è£³æ¢¢æç¨ç§èåºé¶å°å¨éµç»å¥¢èµèèèèµ¦æå°ææ¶ç¤¾è®¾ç ·ç³å»ä¼¸èº«æ·±å¨ ç»ç¥æ²å®¡å©¶çè¾ææ¸å£°çç¥ç²åç»³"
  ],
  [
    "ca40",
    "è",
    8,
    "èèèèèèèèèèèèèèè è¢",
    8,
    "è­",
    9,
    "è¾",
    4,
    "èèèèè",
    10
  ],
  [
    "ca80",
    "èèèèèèè",
    4,
    "è¥è¦è§è©",
    8,
    "è³èµè¶è·è¸è¼è½è¿èèççå©èå£å¸å¤±ç®æ½æ¹¿è¯å°¸è±åç³æ¾æ¶ä»é£èå®è¯å²ç¢ä½¿å±é©¶å§å¼ç¤ºå£«ä¸æ¿äºæ­èªéå¿æ¯åå¬éä»ä¾éé¥°æ°å¸æå®¤è§è¯æ¶æé¦å®å¯¿æå®åç¦å½è¬æ¢æ¢³æ®æè¾åèæ·çä¹¦èµå­°çè¯ææç½²èé»é¼ å±æ¯è¿°æ ææç«å¢åº¶æ°æ¼±"
  ],
  [
    "cb40",
    "èèèè",
    6,
    "è",
    10,
    "è",
    6,
    "è¥è¦è§è©è«è¬è­è±",
    5,
    "è¸èº",
    6,
    "è",
    6,
    "è",
    4,
    "èè"
  ],
  [
    "cb80",
    "èè",
    5,
    "è",
    6,
    "è¥è¦è§è¨èª",
    14,
    "æå·èæè¡°ç©å¸æ æ´éåç½è°æ°´ç¡ç¨å®ç¬é¡ºèè¯´ç¡æçæ¯æå¶æç§å¸ä¸æ­»èå¯ºå£åä¼ºä¼¼é¥²å·³æ¾è¸æé¢éå®è®¼è¯µæèæå½èé¥ä¿ç´ éç²å³å¡æº¯å®¿è¯èé¸èç®è½ééç»¥é«ç¢å²ç©éé§ç¥å­æç¬èæ¢­åç¼©çç´¢éæå¡ä»å®å¥¹å¡"
  ],
  [
    "cc40",
    "è¹èºè¼è½è¾è",
    4,
    "è",
    10,
    "èèèèè",
    15,
    "è¨èª",
    13,
    "è¹èºè»è½è¾è¿è"
  ],
  [
    "cc80",
    "è",
    11,
    "èèè",
    4,
    "èèèèè è¡è£",
    7,
    "ç­æè¹è¸èèæ¬å°æ³°éå¤ªææ±°åæè´ªç«æ»©åæªç°æ½­è°­è°å¦æ¯¯è¢ç¢³æ¢å¹ç­æ±¤å¡æªå æ£ èåç³åèººæ·è¶ç«ææ¶æ»ç»¦èæ¡éæ·é¶è®¨å¥ç¹è¤è¾ç¼èªæ¢¯åè¸¢éæé¢è¹å¼ä½æ¿åææ¶åå±å¤©æ·»å¡«ç°çæ¬èèææ¡è¿¢çºè·³è´´éå¸åå¬ç"
  ],
  [
    "cd40",
    "è­è¯è°è²",
    6,
    "è",
    6,
    "è",
    4,
    "èè",
    5,
    "è",
    4,
    "è¥è¦è«è­è®è²è³è·è¸è¹è»",
    4,
    "èèèèèèèèèèèèèè"
  ],
  [
    "cd80",
    "èè è¡è¢è£è¥è¦è§è¨èªè«è¬è¯èµè¶è·èºè»è¼è½è¿èèèèèèèèèèèèæ±å»·åäº­åº­æºèéæ¡é®ç³åéå½¤ç«¥æ¡¶æç­ç»çå·æå¤´éå¸ç§çªå¾å¾éæ¶å± åååæ¹å¢æ¨é¢è¿èè¤ªéåå±¯èææè±é¸µéé©®é©¼æ¤­å¦¥æå¾æåèæ´¼å¨ç¦è¢æ­ªå¤è±å¼¯æ¹¾ç©é¡½ä¸¸ç·å®ç¢æ½æçæå®å©ä¸èæ±ªçäº¡æç½å¾æºæå¿å¦å¨"
  ],
  [
    "ce40",
    "èèèèè è¤è¦è§è¨èªè«è¬è­è¯è°è²è³èµè¶è¸è¹èºè¼è½è",
    6,
    "èèèèèèèèèèèè",
    5,
    "è¡è¢è¦",
    7,
    "è¯è±è²è³èµ"
  ],
  [
    "ce80",
    "è·è¸è¹èºè¿èèèèèèèèè",
    4,
    "èèèè",
    6,
    "è ",
    4,
    "å·å¾®å±é¦è¿æ¡å´å¯æä¸ºæ½ç»´èèå§ä¼ä¼ªå°¾çº¬æªèå³çèåé­ä½æ¸­è°å°æ°å«çæ¸©èæé»çº¹å»ç¨³ç´é®å¡ç¿ç®æèæ¶¡çªææ¡å§æ¡æ²å·«åé¨ä¹æ±¡è¯¬å±æ èæ¢§å¾å´æ¯æ­¦äºæåèä¼ä¾®åæé¾æ¤ç©å¿å¡æè¯¯æçæè¥¿ç¡ç½æ°å»å¸é¡çº"
  ],
  [
    "cf40",
    "è¥è¦è§è©èªè®è°è±è²è´è¶è·è¸è¹è»è¼è¾è¿è",
    4,
    "èèèè",
    4,
    "è",
    6,
    "èèèèè¡è¢è£è¤è¦è§è¨è©è«è¬è­è¯",
    9
  ],
  [
    "cf80",
    "èºè»è¼è½è¿è è è è ",
    5,
    "è ",
    7,
    "è è è è è è ",
    4,
    "è £ç¨æ¯å¸æèå¤æçç¯æºªæ±çæªè¢­å¸­ä¹ åª³åé£æ´ç³»éæç»çè¾å£éè¾æå³¡ä¾ ç­ä¸å¦å¤åæé¨åä»é²çº¤å¸è´¤è¡è·é²æ¶å¼¦å«æ¾é©ç°ç®å¿èºé¦ç¾¡å®ªé·éçº¿ç¸å¢é¶é¦ç®±è¥æ¹ä¹¡ç¿ç¥¥è¯¦æ³åäº«é¡¹å··æ©¡ååè±¡è§ç¡éåå®å£éæ¶å®µæ·æ"
  ],
  [
    "d040",
    "è ¤",
    13,
    "è ³",
    5,
    "è ºè »è ½è ¾è ¿è¡è¡è¡è¡",
    5,
    "è¡",
    5,
    "è¡è¡è¡è¡",
    6,
    "è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"
  ],
  [
    "d080",
    "è¡»è¡¼è¢è¢è¢è¢è¢è¢è¢è¢è¢è¢è¢è¢è¢è¢è¢",
    4,
    "è¢",
    4,
    "è¢£è¢¥",
    5,
    "å°å­æ ¡èå¸ç¬ææ¥äºæ­èéåææºéªæèè°åæ¢°å¸è¹ææ³æ³»è°¢å±èªè¯éæ¬£è¾æ°å¿»å¿ä¿¡è¡æè¥ç©æºå´ååå½¢é¢è¡éå¹¸ææ§å§åå¶è¸åæ±¹éçä¼ä¿®ç¾æ½åéç§è¢ç»£å¢æéèåé¡»å¾è®¸èéåæ­åºçæ¤çµ®å©¿ç»ªç»­è½©å§å®£æ¬æç"
  ],
  [
    "d140",
    "è¢¬è¢®è¢¯è¢°è¢²",
    4,
    "è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£è£è£è£è£è£è£è£è£è£è£è£è£è£è£è£",
    4,
    "è£ è£¡è£¦è£§è£©",
    6,
    "è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤è¤è¤",
    5
  ],
  [
    "d180",
    "è¤è¤",
    4,
    "è¤è¤",
    4,
    "è¤",
    4,
    "è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·éç£ç©ç»é´èå­¦ç©´éªè¡åçå¾ªæ¬è¯¢å¯»é©¯å·¡æ®æ±è®­è®¯éè¿åæ¼é¸¦é¸­åä¸«è½çèå´è¡æ¶¯éåäºè®¶çå½éçæ·¹çä¸¥ç èå²©å»¶è¨é¢éçæ²¿å¥æ©ç¼è¡æ¼è³å °çåç éåå½¦ç°å®´è°éªæ®å¤®é¸¯ç§§æ¨æ¬ä½¯ç¡ç¾æ´é³æ°§ä»°çå»æ ·æ¼¾éè°å¦ç¶"
  ],
  [
    "d240",
    "è¤¸",
    8,
    "è¥è¥è¥",
    24,
    "è¥ ",
    5,
    "è¥§",
    19,
    "è¥¼"
  ],
  [
    "d280",
    "è¥½è¥¾è¦è¦è¦è¦è¦",
    26,
    "æå°§é¥çªè°£å§å¬èè¯è¦èæ¤°åè¶ç·éå¶ä¹é¡µæä¸å¶æ³èå¤æ¶²ä¸å£¹å»æé±ä¾ä¼è¡£é¢å¤·éç§»ä»ªè°çæ²å®å§¨å½æ¤èåå·²ä¹ç£ä»¥èºææéå±¹äº¿å½¹èé¸èç«äº¦è£ææ¯å¿ä¹çæº¢è¯£è®®è°è¯å¼ç¿¼ç¿ç»èµè«å æ®·é³é´å§»åé¶æ·«å¯é¥®å°¹å¼é"
  ],
  [
    "d340",
    "è¦¢",
    30,
    "è§è§è§è§è§è§è§è§è§è§è§è§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",
    6
  ],
  [
    "d380",
    "è§»",
    4,
    "è¨",
    5,
    "è¨",
    21,
    "å°è±æ¨±å©´é¹°åºç¼¨è¹è¤è¥è§èè¿èµ¢çå½±é¢ç¡¬æ åæ¥ä½£èçåº¸éè¸è¹åæ³³æ¶æ°¸æ¿åç¨å¹½ä¼æ å¿§å°¤ç±é®éç¹æ²¹æ¸¸éæåå³ä½éè¯±åå¹¼è¿æ·¤äºçæ¦èæèä½ä¿é¾é±¼ææ¸æ¸éäºå¨±é¨ä¸å±¿ç¦¹å®è¯­ç¾½çåèéåéå»å³ªå¾¡ææ¬²ç±è²èª"
  ],
  [
    "d440",
    "è¨",
    31,
    "è¨¿",
    8,
    "è©",
    21
  ],
  [
    "d480",
    "è©",
    25,
    "è©º",
    6,
    "æµ´å¯è£é¢è±«é©­é¸³æ¸å¤åå£è¢åæ´è¾å­ååç¿æºç¼è¿èæ¿æ¨é¢æ°çº¦è¶è·é¥å²³ç²¤ææ¦éèäºé§åé¨åè¿è´éæéµå­åç ¸ææ ½åç¾å®°è½½åå¨å±ææèµèµèè¬é­ç³å¿è»æ£æ©æ¾¡è¤èºåªé çç¶ç¥è´£æ©åæ³½è´¼æå¢ææ¾èµ æå³æ¸£æ­è½§"
  ],
  [
    "d540",
    "èª",
    7,
    "èª",
    7,
    "èª",
    46
  ],
  [
    "d580",
    "è«",
    32,
    "é¡é¸ç¨æ æ¦¨åä¹ç¸è¯ææå®çªåºå¯¨ç»æ¯¡è©¹ç²æ²¾çæ©è¾å´­å±è¸æ å æç«æ¹ç»½æ¨ç« å½°æ¼³å¼ ææ¶¨æä¸å¸è´¦ä»èç´éææ­æ¾æ²¼èµµç§ç½©åèå¬é®æå²è°è¾èéèè¿æµçæççç §è»è´éä¾¦æç¹è¯éæ¯ééµè¸æ£çå¾ç°äºææ´æ¯æ­£æ¿"
  ],
  [
    "d640",
    "è«¤",
    34,
    "è¬",
    27
  ],
  [
    "d680",
    "è¬¤è¬¥è¬§",
    30,
    "å¸§çéè¯èææ¯å±èç¥è¢èæ±ä¹ç»èç´æ¤æ®æ§å¼ä¾åææ­¢è¶¾åªæ¨çº¸å¿ææ·è³è´ç½®å¸å³å¶æºç§©ç¨è´¨ççæ»æ²»çªä¸­çå¿ éè¡·ç»ç§è¿éä»²ä¼èå¨å·æ´²è¯ç²¥è½´èå¸åç±å®æ¼éª¤ç æ ªèæ±çªè¯¸è¯éç«¹çç®æç©å±ä¸»èæ±å©èè´®é¸ç­"
  ],
  [
    "d740",
    "è­",
    31,
    "è­§",
    4,
    "è­­",
    25
  ],
  [
    "d780",
    "è®",
    24,
    "è®¬è®±è®»è¯è¯è¯ªè°è°ä½æ³¨ç¥é©»æçªæ½ä¸ç è½¬æ°èµç¯æ¡©åºè£å¦æå£®ç¶æ¤é¥è¿½èµå ç¼è°åææåæ¡ç¢èéåçç¼æµå¹å¨èµå§¿æ»æ·å­ç´«ä»ç±½æ»å­èªæ¸å­é¬æ£è¸ªå®ç»¼æ»çºµé¹èµ°å¥æç§è¶³åæç¥è¯é»ç»é»çºå´éæç½ªå°éµæ¨å·¦ä½æåä½ååº§"
  ],
  [
    "d840",
    "è°¸",
    8,
    "è±è±è±è±è±è±è±è±",
    7,
    "è±è±è±è±è±",
    5,
    "è±£",
    6,
    "è±¬",
    6,
    "è±´è±µè±¶è±·è±»",
    6,
    "è²è²è²è²"
  ],
  [
    "d880",
    "è²è²è²",
    6,
    "è²è²è²è²",
    20,
    "äºä¸åä¸å»¿åä¸äºä¸é¬²å­¬å©ä¸¨ç¦ºä¸¿åä¹å¤­ç»å®æ°åè¤é¦æ¯ç¾é¼ä¸¶äºé¼ä¹ä¹©äºèå­å¬åä»ååå£å¥å®é¥èµååµå¦å®å¾èµå¦å£åååå­å³å¿åååå¡åè¯å½åååååç½äº»ä»ä»ä»ä»¨ä»¡ä»«ä»ä¼ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼ä¼«ä½ä½§æ¸ä½ä½"
  ],
  [
    "d940",
    "è²®",
    62
  ],
  [
    "d980",
    "è³­",
    32,
    "ä½ä½ä¼²ä¼½ä½¶ä½´ä¾ä¾ä¾ä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾ä¿¦ä¿¨ä¿ªä¿ä¿ä¿£ä¿ä¿ä¿ä¿¸å©åä¿³å¬åå®å­ä¿¾ååå¥å¨å¾ååååå¬å»å¥å§å©åºååå­å¬å¦å®ååä»æ°½ä½ä½¥ä¿é¾ æ±ç±´å®å·½é»é¦åå¤å¹åè¨åå«å¤åäº åäº³è¡®è¢¤äºµèè£ç¦å¬´è ç¾¸å«å±å½å¼"
  ],
  [
    "da40",
    "è´",
    14,
    "è´ èµèµèµèµèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",
    8,
    "è¶è¶è¶è¶è¶è¶è¶",
    4,
    "è¶è¶è¶",
    9,
    "è¶ è¶¡"
  ],
  [
    "da80",
    "è¶¢è¶¤",
    12,
    "è¶²è¶¶è¶·è¶¹è¶»è¶½è·è·è·è·è·è·è·è·è·è·è·è·è·ååå¢å¥è® è®¦è®§è®ªè®´è®µè®·è¯è¯è¯è¯è¯è¯è¯è¯è¯è¯è¯è¯è¯è¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°è°è°è°è°è°è°è°è°è°è°è°è°è°è°è°è° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºéé¢é¡é±éªé½é¼ééééé§é¬é²é´éééé°ééééé¬é¡é´é³é¶éº"
  ],
  [
    "db40",
    "è·è·è·è·è· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",
    6,
    "è¸è¸è¸è¸è¸è¸è¸è¸è¸è¸è¸",
    7,
    "è¸ è¸¡è¸¤",
    4,
    "è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"
  ],
  [
    "db80",
    "è¸¿è¹è¹è¹è¹",
    4,
    "è¹",
    5,
    "è¹",
    11,
    "è¹§è¹¨è¹ªè¹«è¹®è¹±é¸é°ééé¾ééééé¦é¢éééé«é¯é¾éé¢éé£é±é¯é¹ééåå¥å¢å¬å­å¾å¿ååå°åç®çå»´åµå¼é¬¯å¶å¼çå·¯åå©å¡å¡¾å¢¼å£å£å©å¬åªå³å¹å®å¯åå»åå©åå«åå¼å»å¨å­å¶å³å­å¤åå²åå§å´åå åååååå¸å´å¯å¸å¤å"
  ],
  [
    "dc40",
    "è¹³è¹µè¹·",
    4,
    "è¹½è¹¾èºèºèºèºèºèº",
    6,
    "èºèºèºèº",
    6,
    "èºèº",
    11,
    "èº­èº®èº°èº±èº³",
    6,
    "èº»",
    7
  ],
  [
    "dc80",
    "è»",
    10,
    "è»",
    21,
    "å å å½å­å å å å¡å  å¡¥å¡¬å¢å¢å¢å¢é¦¨é¼æ¿è¹è½è¿èèè¨èèèèèè«è¸è¾è°èèè£èè·è®èèèè©è´è¡èªèèèè¤è¡èè·è¤èèèè´èèèè»èèèèèèè èèèèèèèè¼è´è±èèè¯èèèèèèè è­èºè³è¦è¥"
  ],
  [
    "dd40",
    "è»¥",
    62
  ],
  [
    "dd80",
    "è¼¤",
    32,
    "è¨èè©è¬èªè­è®è°è¸è³è´è èªèèèè¼è¶è©è½è¸è»èèè¨èºè¼èèè¥èå èèèè½èèè¸èèèèèèè¸è¹èªèèè¦è°è¡èèèèè³èèèºèè¸è¼èè©è¶èèè±è­èèèè¦è½èèè¿èºè è¡è¹è´èè¥è£èçè¸è°è¹èèº"
  ],
  [
    "de40",
    "è½",
    32,
    "è½ªè¾è¾è¾è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿è¿è¿"
  ],
  [
    "de80",
    "è¿",
    4,
    "è¿è¿è¿è¿è¿è¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿éééééééèè»è¿è¼èèè¨è¤èèºç¢èè²è»è¤è¨èèè¹è®èèè¹è·è°èèèè¿è§èè©èè¼å»¾å¼å¤¼å¥è·å¥å¥å¥åå°¢å°¥å°¬å°´ææªææ»ææææ®æ¢æ¶æ¹æææ­æ¶æ±æºææ´æ­æ¬ææ©æ®æ¼æ²æ¸æ æ¿ææææææ¾æææææ ææ¦æ¡æææ­æ"
  ],
  [
    "df40",
    "ééé£é¤é¥é§",
    5,
    "é°",
    4,
    "é·é¹éºé½é¿ééééé",
    4,
    "ééééééé",
    5,
    "é¤é¦é§é©éªé«é¬é¯",
    4,
    "é¶",
    6,
    "é¾é"
  ],
  [
    "df80",
    "ééééééé",
    4,
    "ééééééééé é¤é¥é§é¨é©é«é­é²é·é¼é½é¿éæºæ·æ¸ææºææææ¤æ¢ææ¥æ®å¼å¿çå¼åå±å½å©å¨å»åååååååååå¡ååå£å²ååå·å±å¤åååå¶å¦ååå­åå´åå§å¦ååå²å£åå»å¿ååååå©åªå¤ååååå§å å½åå³å¢å£ååå§åªå§ååµåå­ååå¿åå¼"
  ],
  [
    "e040",
    "éééééééééééééééééé é£é¤é¥é©éªé¬é®é°é±é²é³éµé¶é·é¹éºé»é¼é¿éééé",
    19,
    "ééé"
  ],
  [
    "e080",
    "ééé é¡é¤",
    10,
    "é°é²",
    6,
    "éº",
    8,
    "éå·ååµå¶å·å³å°ååååå±å¹åååå¾ååå»åå½å¾åååªå·åååå«å¬åå¦ååå¯å¥å²å³ååå¨åµå¤è¾ååååå¤å£å¾åå§å­åå¹åå¬åå¢åååååå¤å±å«å»å¼ååå¯åååå¡åµå«å¹å¿ååååå¸å¸å¸å¸å¸±å¸»å¸¼"
  ],
  [
    "e140",
    "éééééééééééééé é¦é§é¨é«é­é³éºé»é¼é",
    4,
    "éééééé",
    6,
    "é",
    5,
    "é¤",
    5,
    "é«é¬é°é±é²é³é¶é·é¸é¹é»"
  ],
  [
    "e180",
    "é¼",
    10,
    "éééé",
    9,
    "é",
    8,
    "å¸·å¹å¹å¹å¹å¹¡å²å±ºå²å²å²å²å²å²å²å²å²å²µå²¢å²½å²¬å²«å²±å²£å³å²·å³å³å³¤å³å³¥å´å´å´§å´¦å´®å´¤å´å´å´åµå´¾å´´å´½åµ¬åµåµ¯åµåµ«åµåµåµ©åµ´å¶å¶å¶è±³å¶·å·å½³å½·å¾å¾å¾å¾å¾å¾å¾å¾¨å¾­å¾µå¾¼è¡¢å½¡ç­ç°ç´ç·ç¸çççççç¨ç¯ç©ç²ç´ç·çç³ççº"
  ],
  [
    "e240",
    "é¦",
    62
  ],
  [
    "e280",
    "é¥",
    32,
    "ç»ççç¡ççççç¢ç¹ç¥ç¬ç¸ç±çççç ç¬ç¯ç¾èå¤¥é£§å¤¤å¤é¥£é¥§",
    5,
    "é¥´é¥·é¥½é¦é¦é¦é¦é¦é¦é¦é¦é¦é¦åºåºåºåºåº¥åº åº¹åºµåº¾åº³èµå»å»å»å»¨å»ªèºå¿å¿å¿å¿æå¿®æå¿¡å¿¤å¿¾ææå¿ªå¿­å¿¸ææµæ¦ææææ©æ«ææ¿æ¡æ¸æ¹æ»æºæ"
  ],
  [
    "e340",
    "é",
    45,
    "éµ",
    16
  ],
  [
    "e380",
    "é",
    7,
    "é",
    24,
    "æªæ½æææ­ææææææ¬æ»æ±æææææ´æ æ¦ææ£æ´æææ«ææµæ¬ææ§æ·ææµå¿é³é©é«é±é³éµé¶é¼é¾éééééééééééééééä¸¬ç¿ææ°µæ±æ±æ±æ²£æ²æ²æ²æ²æ±¨æ±©æ±´æ±¶æ²æ²©æ³æ³æ²­æ³·æ³¸æ³±æ³æ²²æ³ æ³æ³ºæ³«æ³®æ²±æ³æ³¯æ³¾"
  ],
  [
    "e440",
    "é¨",
    5,
    "é¯",
    24,
    "é",
    31
  ],
  [
    "e480",
    "é©",
    32,
    "æ´¹æ´§æ´æµæµæ´æ´æ´æ´æ´«æµæ´®æ´µæ´æµæµæµæ´³æ¶æµ¯æ¶æ¶ æµæ¶æ¶æµæµ æµ¼æµ£æ¸æ·æ·æ·æ¸æ¶¿æ· æ¸æ·¦æ·æ·æ¸æ¶«æ¸æ¶®æ¸«æ¹®æ¹æ¹«æº²æ¹æºæ¹æ¹æ¸²æ¸¥æ¹æ»æº±æºæ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»æº´æ»æºæ»æºæ½¢æ½æ½æ¼¤æ¼æ»¹æ¼¯æ¼¶æ½æ½´æ¼ªæ¼æ¼©æ¾æ¾æ¾æ½¸æ½²æ½¼æ½ºæ¿"
  ],
  [
    "e540",
    "é",
    51,
    "é¿",
    10
  ],
  [
    "e580",
    "é",
    31,
    "é«æ¿æ¾§æ¾¹æ¾¶æ¿æ¿¡æ¿®æ¿æ¿ æ¿¯çç£çç¹çµççå®å®å®å®å®¥å®¸ç¯éªæ´å¯¤å¯®è¤°å¯°è¹è¬è¾¶è¿è¿è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨éééé¦éééé¡éµé¶é­é¯ééééé¨éé¢éæ¹é´é½ééééå½å½å½å½å°»å«å±å±å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è´å¼¼é¬»å±®å¦å¦å¦å¦©å¦ªå¦£"
  ],
  [
    "e640",
    "é¬",
    34,
    "é",
    27
  ],
  [
    "e680",
    "é¬",
    29,
    "éééå¦å§å¦«å¦å¦¤å§å¦²å¦¯å§å¦¾å¨å¨å§å¨å§£å§å§¹å¨å¨å¨²å¨´å¨å¨£å¨å©å©§å©å©å¨¼å©¢å©µè¬åªªåªå©·å©ºåª¾å««åª²å«å«åª¸å« å«£å«±å«å«¦å«å«å¬å¬å¬å¬²å¬·å­å°å°å­å­¥å­³å­å­å­¢é©µé©·é©¸é©ºé©¿é©½éªéªéªéªéªéªéªéªéªéªéªéªéªéªéª éª¢éª£éª¥éª§çºçº¡çº£çº¥çº¨çº©"
  ],
  [
    "e740",
    "é",
    7,
    "é",
    54
  ],
  [
    "e780",
    "é",
    32,
    "çº­çº°çº¾ç»ç»ç»ç»ç»ç»ç»ç»ç»ç»ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼ç¼¡",
    6,
    "ç¼ªç¼«ç¼¬ç¼­ç¼¯",
    4,
    "ç¼µå¹ºç¿å·ç¾éççç®ç¢ççççç·ç³çççç¥çé¡¼çç©ç§ççºç²ççªçç¦ç¥ç¨ç°ç®ç¬"
  ],
  [
    "e840",
    "é¯",
    14,
    "é¿",
    43,
    "é¬é­é®é¯"
  ],
  [
    "e880",
    "é°",
    20,
    "ééééééééé¦é»éé çççççççç·ç­ç¾çççççççç¨ç©çç§ççºéªé«é¬æææææ©æ¥ææªæ³ææ§æµæ¨ææ­ææ·æ¼æ°æ ææ æ©æ°æ ææµææ³ææ ææ¸æ¢æ ææ½æ ²æ ³æ¡ æ¡¡æ¡æ¡¢æ¡æ¡¤æ¢æ æ¡æ¡¦æ¡æ¡§æ¡æ ¾æ¡æ¡æ ©æ¢µæ¢æ¡´æ¡·æ¢æ¡«æ£æ¥®æ£¼æ¤æ¤ æ£¹"
  ],
  [
    "e940",
    "é§é³é½éééééé é®é´éµé·",
    7,
    "é",
    42
  ],
  [
    "e980",
    "é«",
    32,
    "æ¤¤æ£°æ¤æ¤æ¥æ££æ¤æ¥±æ¤¹æ¥ æ¥æ¥æ¦æ¥«æ¦æ¦æ¥¸æ¤´æ§æ¦æ¦æ§æ¦æ¥¦æ¥£æ¥¹æ¦æ¦§æ¦»æ¦«æ¦­æ§æ¦±æ§æ§æ§æ¦æ§ æ¦æ§¿æ¨¯æ§­æ¨æ¨æ©¥æ§²æ©æ¨¾æª æ©æ©æ¨µæªæ©¹æ¨½æ¨¨æ©æ©¼æªæªæª©æªæª«ç·çæ®æ®æ®æ®æ®æ®æ®æ®æ®æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾è¾è¾è¾"
  ],
  [
    "ea40",
    "é",
    27,
    "é¬é¿éééééé é£",
    6,
    "é«é¬é­é¯é°é·é¸é¹éºé¾éééééééééé"
  ],
  [
    "ea80",
    "ééééééé é£é¥é¦é«é­",
    4,
    "é³é¸",
    12,
    "éééè¾è¾è¾è¾è¾è»æææææ¢æ¡æ¥æ¤æ¬è§ç¯ç´ç¿çççæ´æ®æ¯æ°æææ²æææçæ·ææ´æ±æ¶æµèææææææ¡ææ·æææ§ææ¾æææ¦æ©è´²è´³è´¶è´»è´½èµèµèµèµèµèµèµèµèµè§è§è§è§è§è§è§è§ç®ççç¦ç¯ç¾ç¿çççççææ²æ°"
  ],
  [
    "eb40",
    "éééééééééé",
    9,
    "é¨",
    7,
    "é±é²é´éµé·é¸éºé»é¿éééééééééé",
    9,
    "é¡",
    6,
    "é«"
  ],
  [
    "eb80",
    "é¬é­é®é°é±é²é´éµé¸éºé»é¼é½é¿éééééééééééé",
    4,
    "ééé æ¿æèæ¯ªæ¯³æ¯½æ¯µæ¯¹æ°æ°æ°æ°æ°æ°æ°æ°æ°¡æ°©æ°¤æ°ªæ°²æµææ«çççç°è¢åèèèè¼æè½è±è«è­è´è·è§è¨è©èªèèèèèèæèè«è±è´è­èèè²è¼æèè±è¶èè¬èè²èèèè´èèè±è è©è¼è½è­è§å¡åªµèèèæ»è£èªèæ¦èè»"
  ],
  [
    "ec40",
    "é¡",
    8,
    "é«é¬é®é¯é±é³",
    4,
    "éºé»é¼é½é¿",
    18,
    "ééééééééé£é¤é¦é§é¨éª",
    7
  ],
  [
    "ec80",
    "é²éµé·",
    4,
    "é½",
    7,
    "é",
    4,
    "ééééééééé",
    4,
    "èè¦æ¬¤æ¬·æ¬¹æ­æ­æ­é£é£é£é£é£é£æ®³å½æ¯è§³æé½ææ¼æææææææççççç»çç·ç«ç±ç¨ççççç¯ç±ç³çç¨çç²çç¸çºçç³çµç¨ç ç çç§ç¹çç¨ç¬çç¦ç¹æ¾æ½æææç¤»ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç¥¢ç¥ç¥ ç¥¯ç¥§ç¥ºç¦ç¦ç¦ç¦§ç¦³å¿å¿"
  ],
  [
    "ed40",
    "ééé¡é¢é¤",
    6,
    "é¬é®é°é±é³éµ",
    46
  ],
  [
    "ed80",
    "é¤é¥é¨é®",
    4,
    "é´é·",
    23,
    "æ¼æææ§æææ£æ«ææææ©ææææèè¿æ²æ³¶æ·¼ç¶ç¸ç ç ç ç ç æ«ç ­ç ç ç ¹ç ºç »ç ç ¼ç ¥ç ¬ç £ç ©ç¡ç¡­ç¡ç¡ç ¦ç¡ç¡ç¡ç¡ªç¢ç¢ç¢ç¢ç¢ç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£ç£ç£ç£¬ç£²ç¤ç£´ç¤ç¤¤ç¤ç¤´é¾é»¹é»»é»¼ç±ççç¹çççç¢çç­ç¦çµç¸çççççç¨"
  ],
  [
    "ee40",
    "é ",
    62
  ],
  [
    "ee80",
    "é¡",
    32,
    "ç¢ç¥ç¿çç½ççççç ç°çµç½çºçççççç²ç¹çç½ç½¡ç½è©ç½¨ç½´ç½±ç½¹ç¾ç½¾çç¥è ²éééééééééééééééé£é¤é«éªé­é¬é¯é°é²é´é¶",
    4,
    "é¼é½é¿éé",
    6,
    "éééééééééééé é¢é¤é¥é§é¨éª"
  ],
  [
    "ef40",
    "é¡¯",
    5,
    "é¢é¢é¢é¢é¢é¢£é¢¨",
    37,
    "é£é£é£é£é£é£é£é£é£ ",
    4
  ],
  [
    "ef80",
    "é£¥é£¦é£©",
    30,
    "é©é«é®é¯é³é´éµé·é¹é¼é½é¿éééééééééé",
    4,
    "éééééé¢éªé«é©é¬é±é²é´é¶é·é¸é¼é¾é¿ééµééééééééééééééééééé¡é¢é¤",
    8,
    "é¯é±é²é³éºç§ç¬éç§ç§­ç§£ç§«ç¨åµç¨ç¨ç¨ç¨"
  ],
  [
    "f040",
    "é¤",
    4,
    "é¤é¤é¤",
    28,
    "é¤¯",
    26
  ],
  [
    "f080",
    "é¥",
    9,
    "é¥",
    12,
    "é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦é¦é¦ç¨¹ç¨·ç©é»é¦¥ç©°ççççç¤çç ç¬é¸ é¸¢é¸¨",
    4,
    "é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹£é¹¦",
    6,
    "é¹±é¹­é¹³çççç çç¬ç£ç³ç´ç¸çç±ç°ççççç£ç¨ç¦ç¤ç«ç§çç±ç¼ç¿ççççççç¥ççç"
  ],
  [
    "f140",
    "é¦é¦é¦",
    10,
    "é¦¦é¦§é¦©",
    47
  ],
  [
    "f180",
    "é§",
    32,
    "çç¼ç¢ç çç­ç°ç¿çµçç¾ç³çççççç«ç¯ç¿ç«¦ç©¸ç©¹çªçªçªçªçª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢è¢¢è£è¢·è¢¼è£è£¢è£è££è£¥è£±è¤è£¼è£¨è£¾è£°è¤¡è¤è¤è¤è¤è¤´è¤«è¤¶è¥è¥¦è¥»çè¥ç²ç´çèèèèè è¢è¥è¦è§è©è¨è±èèµèèèèè©è±è¦é¡¸é¢é¢"
  ],
  [
    "f240",
    "é§º",
    62
  ],
  [
    "f280",
    "é¨¹",
    32,
    "é¢é¢é¢é¢é¢é¢é¢é¢é¢é¢¡é¢¢é¢¥é¢¦èèè¬è®è¿èºè¼è»è¨èèè¬èè§è£èªèè©è¶èèµèè°èºè±è¯èèè´è©è±è²è­è³èèèè´èèèèèè¸èèèèè£è»èè¥è®èè¾èè´è±è©è·è¿èè¢è½è¾è»è è°èè®èèè£è¼è¤èè¥èè¯è¨è"
  ],
  [
    "f340",
    "é©",
    17,
    "é©²éªéªéªéªéªéªéªéª¦éª©",
    6,
    "éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«é«é«",
    4,
    "é«é«é«é«é«é«é«é«é«é«é«é«é«"
  ],
  [
    "f380",
    "é«é«é« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",
    8,
    "é«ºé«¼",
    6,
    "é¬é¬é¬èèèè­èèè«è¥è¬èµè³èèè½èèèèèªè è®è è è¾è è è ¡è ¹è ¼ç¼¶ç½ç½ç½èç«ºç«½ç¬ç¬ç¬ç¬ç¬ç¬«ç¬ç­ç¬¸ç¬ªç¬ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬ç­ç­ç­ç­µç­ç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®ç®ªç®ç®¢ç®«ç®´ç¯ç¯ç¯ç¯ç¯ç¯¥ç¯¦ç¯ªç°ç¯¾ç¯¼ç°ç°ç°"
  ],
  [
    "f440",
    "é¬é¬",
    5,
    "é¬é¬é¬é¬",
    10,
    "é¬ é¬¡é¬¢é¬¤",
    10,
    "é¬°é¬±é¬³",
    7,
    "é¬½é¬¾é¬¿é­é­é­é­é­é­é­é­é­é­",
    5
  ],
  [
    "f480",
    "é­",
    32,
    "ç°ç°ªç°¦ç°¸ç±ç±è¾èèèè¬è¡è¡è¢è£è­è¯è¨è«è¸è»è³è´è¾èèèèèèè¨è¡¾è¢è¢è£è£è¥ç¾ç¾ç¾§ç¾¯ç¾°ç¾²ç±¼æç²ç²ç²ç²ç²¢ç²²ç²¼ç²½ç³ç³ç³ç³ç³ç³ç³ç³¨è®æ¨ç¾¿ç¿ç¿ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹çºéº¸éº´èµ³è¶è¶è¶è¶±èµ§èµ­è±è±ééééé¤"
  ],
  [
    "f540",
    "é­¼",
    62
  ],
  [
    "f580",
    "é®»",
    32,
    "é¢é¡é°é©é¯é½é¾é²é´é¹éééééé¢é£éªé­é®é¯éµé´éºè±é¹¾è¶¸è·«è¸è¹è¹©è¶µè¶¿è¶¼è¶ºè·è·è·è·è·è·è·è·è·è·¬è··è·¸è·£è·¹è·»è·¤è¸è·½è¸è¸è¸è¸¬è¸®è¸£è¸¯è¸ºè¹è¸¹è¸µè¸½è¸±è¹è¹è¹è¹è¹è¹è¹°è¹¶è¹¼è¹¯è¹´èºèºèºèºèºèºè±¸è²è²è²è²è²æè§è§è§è§"
  ],
  [
    "f640",
    "é¯",
    62
  ],
  [
    "f680",
    "é°",
    32,
    "è§¥è§«è§¯è¨¾è¬¦éé©é³é¯ééééééªé­é°é¾é¾é¾é¾",
    5,
    "é¾é»¾é¼é¼é¹é¼é½ééç¿é éé®éé¾éªééé¾é«é±¿é²é²é²é²é²ç¨£é²é²é²é²é²é²é²é²é²é²",
    5,
    "é²¥",
    4,
    "é²«é²­é²®é²°",
    7,
    "é²ºé²»é²¼é²½é³é³é³é³é³é³"
  ],
  [
    "f740",
    "é°¼",
    62
  ],
  [
    "f780",
    "é±»é±½é±¾é²é²é²é²é²é²é²é²é²é²é²é²é²é²ªé²¬é²¯é²¹é²¾",
    4,
    "é³é³é³é³é³é³é³ é³¡é³",
    4,
    "é³é³é³é³é³é³é³é³é³é³¢é¼ééééé¯é«é£é²é´éª±éª°éª·é¹éª¶éªºéª¼é«é«é«é«é«é«é«é­é­é­é­é­é­é­é£¨é¤é¤®é¥é¥é«é«¡é«¦é«¯é««é«»é«­é«¹é¬é¬é¬é¬é¬£éº½éº¾ç¸»éºéºéºéºéºééºéºé»é»é»é» é»é»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½"
  ],
  [
    "f840",
    "é³£",
    62
  ],
  [
    "f880",
    "é´¢",
    32
  ],
  [
    "f940",
    "éµ",
    62
  ],
  [
    "f980",
    "é¶",
    32
  ],
  [
    "fa40",
    "é¶£",
    62
  ],
  [
    "fa80",
    "é·¢",
    32
  ],
  [
    "fb40",
    "é¸",
    27,
    "é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹é¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",
    9,
    "éº"
  ],
  [
    "fb80",
    "éºéºéºéºéºéºéºéº",
    5,
    "éº",
    8,
    "éºéº ",
    5,
    "éº§éº¨éº©éºª"
  ],
  [
    "fc40",
    "éº«",
    8,
    "éºµéº¶éº·éº¹éººéº¼éº¿",
    4,
    "é»é»é»é»é»é»é»é»é»é»é»é»é»é»é»é»é»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",
    8,
    "é»ºé»½é»¿",
    6
  ],
  [
    "fc80",
    "é¼",
    4,
    "é¼é¼é¼é¼é¼é¼é¼é¼é¼",
    5,
    "é¼¡é¼£",
    8,
    "é¼­é¼®é¼°é¼±"
  ],
  [
    "fd40",
    "é¼²",
    4,
    "é¼¸é¼ºé¼¼é¼¿",
    4,
    "é½",
    10,
    "é½",
    38
  ],
  [
    "fd80",
    "é½¹",
    5,
    "é¾é¾é¾",
    11,
    "é¾é¾é¾é¾¡",
    4,
    "ï¤¬ï¥¹ï¦ï§§ï§±"
  ],
  [
    "fe40",
    "ï¨ï¨ï¨ï¨ï¨ï¨ï¨ï¨ï¨ï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"
  ]
];
const require$$3 = [
  [
    "a140",
    "î",
    62
  ],
  [
    "a180",
    "î",
    32
  ],
  [
    "a240",
    "î¦",
    62
  ],
  [
    "a280",
    "î¥",
    32
  ],
  [
    "a2ab",
    "î¦",
    5
  ],
  [
    "a2e3",
    "â¬î­"
  ],
  [
    "a2ef",
    "î®î¯"
  ],
  [
    "a2fd",
    "î°î±"
  ],
  [
    "a340",
    "î",
    62
  ],
  [
    "a380",
    "î",
    31,
    "ã"
  ],
  [
    "a440",
    "î¦",
    62
  ],
  [
    "a480",
    "î¥",
    32
  ],
  [
    "a4f4",
    "î²",
    10
  ],
  [
    "a540",
    "î",
    62
  ],
  [
    "a580",
    "î",
    32
  ],
  [
    "a5f7",
    "î½",
    7
  ],
  [
    "a640",
    "î¦",
    62
  ],
  [
    "a680",
    "î¥",
    32
  ],
  [
    "a6b9",
    "î",
    7
  ],
  [
    "a6d9",
    "î",
    6
  ],
  [
    "a6ec",
    "îî"
  ],
  [
    "a6f3",
    "î"
  ],
  [
    "a6f6",
    "î",
    8
  ],
  [
    "a740",
    "î",
    62
  ],
  [
    "a780",
    "î",
    32
  ],
  [
    "a7c2",
    "î ",
    14
  ],
  [
    "a7f2",
    "î¯",
    12
  ],
  [
    "a896",
    "î¼",
    10
  ],
  [
    "a8bc",
    "á¸¿"
  ],
  [
    "a8bf",
    "Ç¹"
  ],
  [
    "a8c1",
    "îîîî"
  ],
  [
    "a8ea",
    "î",
    20
  ],
  [
    "a958",
    "î¢"
  ],
  [
    "a95b",
    "î£"
  ],
  [
    "a95d",
    "î¤î¥î¦"
  ],
  [
    "a989",
    "ã¾â¿°",
    11
  ],
  [
    "a997",
    "î´",
    12
  ],
  [
    "a9f0",
    "î ",
    14
  ],
  [
    "aaa1",
    "î",
    93
  ],
  [
    "aba1",
    "î",
    93
  ],
  [
    "aca1",
    "î¼",
    93
  ],
  [
    "ada1",
    "î",
    93
  ],
  [
    "aea1",
    "î¸",
    93
  ],
  [
    "afa1",
    "î",
    93
  ],
  [
    "d7fa",
    "î ",
    4
  ],
  [
    "f8a1",
    "î´",
    93
  ],
  [
    "f9a1",
    "î",
    93
  ],
  [
    "faa1",
    "î°",
    93
  ],
  [
    "fba1",
    "î",
    93
  ],
  [
    "fca1",
    "î¬",
    93
  ],
  [
    "fda1",
    "î",
    93
  ],
  [
    "fe50",
    "âºî î î âºã³ãâºâºî ãããâºâºã¥®ã¤î ¦ã§ã§ã©³ã§î «î ¬ã­ã±®ã³ âº§î ±î ²âºªääâº®ä·âº³âº¶âº·î »ä±ä¬âº»äää¡äî¡"
  ],
  [
    "fe80",
    "ä£ä©ä¼äâ»ä¥ä¥ºä¥½ä¦ä¦ä¦ä¦ä¦ä¦ä¦·ä¦¶î¡î¡ä²£ä²ä² ä²¡ä±·ä²¢ä´",
    6,
    "ä¶®î¡¤î¨",
    93
  ],
  [
    "8135f437",
    "î"
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "ê°ê°ê°ê°ê°",
    4,
    "ê°ê°ê°ê°¡ê°¢ê°£ê°¥",
    6,
    "ê°®ê°²ê°³ê°´"
  ],
  [
    "8161",
    "ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±",
    9,
    "ê±ê±",
    5,
    "ê±"
  ],
  [
    "8181",
    "ê±ê±ê±ê±ê±ê±",
    18,
    "ê±²ê±³ê±µê±¶ê±¹ê±»",
    4,
    "ê²ê²ê²ê²ê²ê²ê²ê²ê²ê²",
    6,
    "ê²ê²¢",
    5,
    "ê²«ê²­ê²®ê²±",
    6,
    "ê²ºê²¾ê²¿ê³ê³ê³ê³ê³ê³ê³ê³ê³ê³",
    7,
    "ê³ê³",
    7,
    "ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",
    4,
    "ê³¾ê³¿ê´ê´ê´ê´ê´",
    4,
    "ê´ê´ê´ê´"
  ],
  [
    "8241",
    "ê´ê´ê´ê´ê´ê´ê´ê´ê´ê´ê´¡",
    7,
    "ê´ªê´«ê´®",
    5
  ],
  [
    "8261",
    "ê´¶ê´·ê´¹ê´ºê´»ê´½",
    6,
    "êµêµêµ",
    5,
    "êµêµêµêµêµêµ"
  ],
  [
    "8281",
    "êµ",
    7,
    "êµ¢êµ¤",
    7,
    "êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶ê¶",
    4,
    "ê¶ê¶ê¶ê¶ê¶ê¶",
    10,
    "ê¶",
    5,
    "ê¶¥",
    17,
    "ê¶¸",
    7,
    "ê·ê·ê·ê·ê·ê·",
    6,
    "ê·ê·",
    7,
    "ê·ê·ê·ê·¡ê·¢ê·£ê·¥",
    18
  ],
  [
    "8341",
    "ê·ºê·»ê·½ê·¾ê¸",
    5,
    "ê¸ê¸ê¸",
    5,
    "ê¸",
    7
  ],
  [
    "8361",
    "ê¸",
    18,
    "ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"
  ],
  [
    "8381",
    "ê¸½ê¸¾ê¸¿ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹",
    4,
    "ê¹ê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",
    6,
    "ê¹ºê¹¾",
    5,
    "êº",
    5,
    "êº",
    46,
    "êº¿ê»ê»ê»ê»",
    6,
    "ê»ê»",
    5,
    "ê»ê»ê»",
    8
  ],
  [
    "8441",
    "ê»¦ê»§ê»©ê»ªê»¬ê»®",
    5,
    "ê»µê»¶ê»·ê»¹ê»ºê»»ê»½",
    8
  ],
  [
    "8461",
    "ê¼ê¼ê¼ê¼ê¼ê¼ê¼ê¼",
    18
  ],
  [
    "8481",
    "ê¼¤",
    7,
    "ê¼®ê¼¯ê¼±ê¼³ê¼µ",
    6,
    "ê¼¾ê½ê½ê½ê½ê½ê½",
    5,
    "ê½",
    10,
    "ê½",
    5,
    "ê½¦",
    18,
    "ê½º",
    5,
    "ê¾ê¾ê¾ê¾ê¾ê¾ê¾",
    6,
    "ê¾ê¾ê¾ê¾",
    5,
    "ê¾",
    26,
    "ê¾ºê¾»ê¾½ê¾¾"
  ],
  [
    "8541",
    "ê¾¿ê¿",
    5,
    "ê¿ê¿ê¿",
    4,
    "ê¿",
    6,
    "ê¿",
    4
  ],
  [
    "8561",
    "ê¿¢",
    5,
    "ê¿ª",
    5,
    "ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹",
    6,
    "ëë"
  ],
  [
    "8581",
    "ë",
    6,
    "ëëëëëëë",
    6,
    "ë",
    9,
    "ë©",
    26,
    "ëëëëëëëëëëëëëëë",
    29,
    "ë¾ë¿ëëëë",
    6,
    "ëëë",
    5,
    "ëëëë£ë¤"
  ],
  [
    "8641",
    "ë¥ë¦ë§ëªë°ë²ë¶ë·ë¹ëºë»ë½",
    6,
    "ëë",
    5,
    "ë"
  ],
  [
    "8661",
    "ëëëëë",
    6,
    "ë¡ë¢ë£ë¤ë¦",
    10
  ],
  [
    "8681",
    "ë±",
    22,
    "ëëëëëëëëëëë",
    4,
    "ë¦ë§ë©ëªë«ë­",
    6,
    "ë¶ëº",
    5,
    "ëëëëëë",
    6,
    "ëëëëëëëëëëë¡",
    22,
    "ëºë»ë½ë¾ë¿ëë",
    4,
    "ëëëëëëëëëëëëë"
  ],
  [
    "8741",
    "ë",
    9,
    "ë©",
    15
  ],
  [
    "8761",
    "ë¹",
    18,
    "ëëëëëëë"
  ],
  [
    "8781",
    "ë",
    5,
    "ëë ",
    7,
    "ëªë«ë­ë®ë¯ë±",
    7,
    "ëºë¼ë¾",
    5,
    "ëëëëë",
    6,
    "ëëë",
    5,
    "ë¡",
    18,
    "ëµ",
    6,
    "ë½",
    26,
    "ëëëëëëë¡",
    6,
    "ëª",
    4
  ],
  [
    "8841",
    "ë¯",
    4,
    "ë¶",
    5,
    "ë½",
    6,
    "ëëëë",
    4
  ],
  [
    "8861",
    "ëëëëëëë",
    4,
    "ë¢ë¤ë§ë¨ë©ë«ë­ë®ë¯ë±ë²ë³ëµë¶ë·"
  ],
  [
    "8881",
    "ë¸",
    15,
    "ëëëëëëë",
    4,
    "ëëëëë ë¡ë£ë§ë©ëªë°ë±ë²ë¶ë¼ë½ë¾ëëëëëë",
    6,
    "ëë",
    5,
    "ë",
    54,
    "ëëëëë ë¡ë¢ë£"
  ],
  [
    "8941",
    "ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹",
    6,
    "ëë",
    5,
    "ë"
  ],
  [
    "8961",
    "ëëëëëë",
    10,
    "ë¢",
    5,
    "ë©ëªë«ë­"
  ],
  [
    "8981",
    "ë®",
    21,
    "ëëëëëëëëëëëëëëëë¡ë¢ë£ë¥ë¦ë§ë©",
    18,
    "ë½",
    18,
    "ë",
    6,
    "ëëëëëëë¡",
    6,
    "ëªë¬",
    7,
    "ëµ",
    15
  ],
  [
    "8a41",
    "ë",
    10,
    "ëëëëëë",
    6,
    "ë¢ë¤ë¦"
  ],
  [
    "8a61",
    "ë§",
    4,
    "ë­",
    18,
    "ëë"
  ],
  [
    "8a81",
    "ë",
    4,
    "ë",
    19,
    "ë",
    5,
    "ë¥ë¦ë§ë©ëªë«ë­",
    7,
    "ë¶ë¸ëº",
    5,
    "ëëëëëëë",
    6,
    "ëëëëë",
    5,
    "ëëë¡ë¢ë¥ë§",
    4,
    "ë®ë°ë²",
    5,
    "ë¹",
    26,
    "ëëëëë"
  ],
  [
    "8b41",
    "ë",
    5,
    "ë¦ë«",
    4,
    "ë²ë³ëµë¶ë·ë¹",
    6,
    "ëë"
  ],
  [
    "8b61",
    "ëëëëëëëëëë",
    6,
    "ëë¢",
    8
  ],
  [
    "8b81",
    "ë«",
    52,
    "ë¢ë£ë¥ë¦ë§ë©ë¬ë­ë®ë¯ë²ë¶",
    4,
    "ë¾ë¿ëëëë",
    6,
    "ëë",
    5,
    "ë",
    18,
    "ë­",
    18
  ],
  [
    "8c41",
    "ë",
    15,
    "ëëëëëë",
    4
  ],
  [
    "8c61",
    "ë",
    6,
    "ë¦",
    5,
    "ë­",
    6,
    "ëµ",
    5
  ],
  [
    "8c81",
    "ë»",
    12,
    "ë",
    26,
    "ë¥ë¦ë§ë©",
    50,
    "ëëë¡ë¢ë£ë¥",
    5,
    "ë­ë®ë¯ë°ë²",
    16
  ],
  [
    "8d41",
    "ë",
    16,
    "ë",
    8
  ],
  [
    "8d61",
    "ë",
    17,
    "ë±ë²ë³ëµë¶ë·ë¹ëº"
  ],
  [
    "8d81",
    "ë»",
    4,
    "ëëëë",
    33,
    "ëªë«ë­ë®ë±",
    6,
    "ëºë¼",
    7,
    "ëëëëëëë",
    6,
    "ë",
    9,
    "ë¡ë¢ë£ë¥ë¦ë§ë©",
    6,
    "ë²ë´ë¶",
    5,
    "ë¾ë¿ëëëë",
    6,
    "ëëëëëëëë"
  ],
  [
    "8e41",
    "ëë¡",
    6,
    "ëªë®",
    5,
    "ë¶ë·ë¹",
    8
  ],
  [
    "8e61",
    "ë",
    4,
    "ëë",
    19
  ],
  [
    "8e81",
    "ë",
    13,
    "ë®ë¯ë±ë²ë³ëµ",
    6,
    "ë¾ë ",
    4,
    "ë ë ë ë ë ë ",
    6,
    "ë ë ë ",
    5,
    "ë ¦ë §ë ©ë ªë «ë ­",
    6,
    "ë ¶ë º",
    5,
    "ë¡ë¡ë¡ë¡",
    11,
    "ë¡ë¡",
    7,
    "ë¡ë¡ë¡¡ë¡¢ë¡£ë¡¥",
    6,
    "ë¡®ë¡°ë¡²",
    5,
    "ë¡¹ë¡ºë¡»ë¡½",
    7
  ],
  [
    "8f41",
    "ë¢",
    7,
    "ë¢",
    17
  ],
  [
    "8f61",
    "ë¢ ",
    7,
    "ë¢©",
    6,
    "ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹",
    4
  ],
  [
    "8f81",
    "ë¢¾ë¢¿ë£ë£ë£",
    5,
    "ë£ë£ë£ë£ë£ë£ë£",
    7,
    "ë£ë£ ë£¢",
    5,
    "ë£ªë£«ë£­ë£®ë£¯ë£±",
    6,
    "ë£ºë£¼ë£¾",
    5,
    "ë¤",
    18,
    "ë¤",
    6,
    "ë¤¡",
    26,
    "ë¤¾ë¤¿ë¥ë¥ë¥ë¥",
    6,
    "ë¥ë¥ë¥ë¥",
    5
  ],
  [
    "9041",
    "ë¥ë¥ë¥ë¥ë¥ë¥¡",
    6,
    "ë¥ªë¥¬ë¥®",
    5,
    "ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"
  ],
  [
    "9061",
    "ë¥¾",
    5,
    "ë¦ë¦ë¦ë¦ë¦",
    15
  ],
  [
    "9081",
    "ë¦",
    12,
    "ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",
    6,
    "ë¦¾ë§ë§",
    5,
    "ë§ë§ë§ë§",
    4,
    "ë§ë§ë§ë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",
    6,
    "ë§¶ë§»",
    4,
    "ë¨",
    5,
    "ë¨",
    11,
    "ë¨",
    33,
    "ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ë©ë©ë©"
  ],
  [
    "9141",
    "ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©",
    6,
    "ë©¦ë©ª",
    5
  ],
  [
    "9161",
    "ë©²ë©³ë©µë©¶ë©·ë©¹",
    9,
    "ëªëªëªëªëªëª",
    5
  ],
  [
    "9181",
    "ëª",
    20,
    "ëªªëª­ëª®ëª¯ëª±ëª³",
    4,
    "ëªºëª¼ëª¾",
    5,
    "ë«ë«ë«ë«",
    14,
    "ë«",
    33,
    "ë«½ë«¾ë«¿ë¬ë¬ë¬ë¬",
    7,
    "ë¬ë¬ë¬",
    5,
    "ë¬ë¬ë¬ë¬ë¬ë¬ë¬¡",
    6
  ],
  [
    "9241",
    "ë¬¨ë¬ªë¬¬",
    7,
    "ë¬·ë¬¹ë¬ºë¬¿",
    4,
    "ë­ë­ë­ë­ë­ë­ë­ë­"
  ],
  [
    "9261",
    "ë­ë­ë­ë­ë­",
    7,
    "ë­¢ë­¤",
    7,
    "ë­­",
    4
  ],
  [
    "9281",
    "ë­²",
    21,
    "ë®ë®ë®ë®ë®ë®ë®",
    18,
    "ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",
    6,
    "ë®µë®¶ë®¸",
    7,
    "ë¯ë¯ë¯ë¯ë¯ë¯ë¯",
    6,
    "ë¯ë¯ë¯",
    35,
    "ë¯ºë¯»ë¯½ë¯¾ë°"
  ],
  [
    "9341",
    "ë°",
    4,
    "ë°ë°ë°ë°ë°ë°ë°ë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"
  ],
  [
    "9361",
    "ë°¶ë°·ë°¹",
    6,
    "ë±ë±ë±ë±ë±ë±ë±ë±ë±",
    8
  ],
  [
    "9381",
    "ë±ë±ë±ë±",
    37,
    "ë²ë²ë²ë²ë²ë²",
    4,
    "ë²ë²ë²",
    4,
    "ë²¢ë²£ë²¥ë²¦ë²©",
    6,
    "ë²²ë²¶",
    5,
    "ë²¾ë²¿ë³ë³ë³ë³",
    7,
    "ë³ë³ë³ë³ë³ë³ë³ë³ë³ë³",
    22,
    "ë³·ë³¹ë³ºë³»ë³½"
  ],
  [
    "9441",
    "ë³¾",
    5,
    "ë´ë´ë´",
    5,
    "ë´ë´ë´ë´",
    8
  ],
  [
    "9461",
    "ë´",
    5,
    "ë´¥",
    6,
    "ë´­",
    12
  ],
  [
    "9481",
    "ë´º",
    5,
    "ëµ",
    6,
    "ëµëµëµëµëµëµ",
    6,
    "ëµ",
    9,
    "ëµ¥ëµ¦ëµ§ëµ©",
    22,
    "ë¶ë¶ë¶ë¶ë¶",
    4,
    "ë¶ë¶ë¶ë¶ë¶ë¶ë¶",
    6,
    "ë¶¥",
    10,
    "ë¶±",
    6,
    "ë¶¹",
    24
  ],
  [
    "9541",
    "ë·ë·ë·ë·ë·ë·ë·ë·",
    11,
    "ë·ª",
    5,
    "ë·±"
  ],
  [
    "9561",
    "ë·²ë·³ë·µë·¶ë··ë·¹",
    6,
    "ë¸ë¸ë¸ë¸",
    5,
    "ë¸ë¸ë¸ë¸ë¸"
  ],
  [
    "9581",
    "ë¸",
    6,
    "ë¸ë¸ ",
    35,
    "ë¹ë¹ë¹ë¹ë¹ë¹ë¹",
    4,
    "ë¹ë¹ë¹ë¹ë¹ë¹ë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",
    4,
    "ë¹²ë¹¶",
    4,
    "ë¹¾ë¹¿ëºëºëºëº",
    6,
    "ëºëº",
    5,
    "ëº",
    13,
    "ëº©",
    14
  ],
  [
    "9641",
    "ëº¸",
    23,
    "ë»ë»"
  ],
  [
    "9661",
    "ë»ë»ë»",
    6,
    "ë»¡ë»¢ë»¦",
    5,
    "ë»­",
    8
  ],
  [
    "9681",
    "ë»¶",
    10,
    "ë¼",
    5,
    "ë¼",
    13,
    "ë¼ë¼",
    33,
    "ë½ë½ë½ë½ë½ë½",
    6,
    "ë½ë½ë½ë½",
    44
  ],
  [
    "9741",
    "ë¾",
    16,
    "ë¾",
    8
  ],
  [
    "9761",
    "ë¾",
    17,
    "ë¾±",
    7
  ],
  [
    "9781",
    "ë¾¹",
    11,
    "ë¿",
    5,
    "ë¿ë¿ë¿ë¿ë¿ë¿",
    6,
    "ë¿ë¿ë¿ ë¿¢",
    89,
    "ì½ì¾ì¿"
  ],
  [
    "9841",
    "ì",
    16,
    "ì",
    5,
    "ììì"
  ],
  [
    "9861",
    "ìììì¡",
    6,
    "ìª",
    15
  ],
  [
    "9881",
    "ìº",
    21,
    "ìììììì",
    6,
    "ì¢ì¤ì¦",
    5,
    "ì®ì±ì²ì·",
    4,
    "ì¾ììììììììììì",
    6,
    "ìì",
    5,
    "ì¦ì§ì©ìªì«ì­",
    6,
    "ì¶ì¸ìº",
    5,
    "ììììììì",
    6,
    "ììììì",
    5,
    "ì¡ì¢ì¥ì¨ì©ìªì«ì®"
  ],
  [
    "9941",
    "ì²ì³ì´ìµì·ìºì»ì½ì¾ì¿ì",
    6,
    "ìì",
    5,
    "ìì"
  ],
  [
    "9961",
    "ìììì",
    6,
    "ì¦ìª",
    5,
    "ì±ì²ì³ìµì¶ì·ì¹ìºì»"
  ],
  [
    "9981",
    "ì¼",
    8,
    "ì",
    5,
    "ìììììì",
    4,
    "ìì ì¢ì£ì¤ì¦ì§ìªì«ì­ì®ì¯ì±",
    11,
    "ì¾",
    5,
    "ììììììì",
    6,
    "ììì",
    6,
    "ì¡ì¢ì£ì¥ì¦ì§ì©",
    6,
    "ì²ì´",
    7,
    "ì¾ì¿ìììì",
    6,
    "ììì",
    5,
    "ììììì¡ì¢ì£"
  ],
  [
    "9a41",
    "ì¤ì¥ì¦ì§ìªì¬ì®ì°ì³ìµ",
    16
  ],
  [
    "9a61",
    "ììì",
    6,
    "ìììììì",
    6,
    "ì¡ì¢ì£ì¤ì¦"
  ],
  [
    "9a81",
    "ì§",
    4,
    "ì®ì¯ì±ì²ì³ìµ",
    6,
    "ì¾ìì",
    5,
    "ì",
    5,
    "ì",
    6,
    "ìììì",
    5,
    "ì¦ì§ì©ìªì«ì®",
    5,
    "ì¶ì¸ìº",
    33,
    "ììì¡ì¢ì¥",
    5,
    "ì®ì°ì²ì³ì´ìµì·ìºì½ì¾ì¿ì",
    6,
    "ìììì"
  ],
  [
    "9b41",
    "ììììììììì",
    6,
    "ì¦ì§ìª",
    8
  ],
  [
    "9b61",
    "ì³",
    17,
    "ì",
    7
  ],
  [
    "9b81",
    "ì",
    25,
    "ìªì«ì­ì®ì¯ì±ì³",
    4,
    "ìºì»ì¾",
    5,
    "ììììììì",
    50,
    "ì",
    22,
    "ì"
  ],
  [
    "9c41",
    "ìììì¡ì£",
    4,
    "ìªì«ì¬ì®",
    5,
    "ì¶ì·ì¹",
    5
  ],
  [
    "9c61",
    "ì¿",
    8,
    "ì",
    6,
    "ì",
    9
  ],
  [
    "9c81",
    "ì",
    8,
    "ì¥",
    6,
    "ì­ì®ì¯ì±ì²ì³ìµ",
    6,
    "ì¾",
    9,
    "ì",
    26,
    "ì¦ì§ì©ìªì«ì­",
    6,
    "ì¶ì·ì¸ìº",
    5,
    "ì",
    18,
    "ì",
    6,
    "ì",
    12
  ],
  [
    "9d41",
    "ìª",
    13,
    "ì¹ìºì»ì½",
    8
  ],
  [
    "9d61",
    "ì",
    25
  ],
  [
    "9d81",
    "ì ",
    8,
    "ìª",
    5,
    "ì²ì³ìµì¶ì·ì¹ì»ì¼ì½ì¾ì",
    9,
    "ììììììì",
    6,
    "ì",
    10,
    "ìªì«ì­ì®ì¯ì±",
    6,
    "ìºì¼ì¾",
    5,
    "ììììììììììììì¢ì£ì¥ì¦ì§ì©",
    6,
    "ì²ì¶",
    5,
    "ì¾ì¿ìììììììììììììì"
  ],
  [
    "9e41",
    "ìììììììì¡",
    7,
    "ìª",
    9,
    "ì¶"
  ],
  [
    "9e61",
    "ì·ìºì¿",
    4,
    "ììììììììì",
    6,
    "ì¢ì¤ì¦ì§"
  ],
  [
    "9e81",
    "ì¨ì©ìªì«ì¯ì±ì²ì³ìµì¸ì¹ìºì»ìììììììììì",
    6,
    "ìì",
    6,
    "ì¦ì§ì©ìªì«ì¯ì±ì²ì¶ì¸ìºì¼ì½ì¾ì¿ìììììì",
    6,
    "ìì",
    5,
    "ììì¡",
    10,
    "ì­ì®ì°ì²",
    5,
    "ìºì»ì½ì¾ì¿ì",
    6,
    "ììì",
    5,
    "ìììììì",
    6,
    "ì¦"
  ],
  [
    "9f41",
    "ì¨ìª",
    5,
    "ì²ì³ìµì¶ì·ì»",
    4,
    "ììì",
    5,
    "ì"
  ],
  [
    "9f61",
    "ììììì",
    6,
    "ììì¢",
    5,
    "ìªì«ì­ì®ì¯ì±ì²"
  ],
  [
    "9f81",
    "ì³",
    4,
    "ìºì»ì¼ì¾",
    5,
    "ìììììì",
    6,
    "ììì",
    5,
    "ì¢ì£ì¥ì¦ì§ì©",
    6,
    "ì²ì´ì¶ì¸ì¹ìºì»ì¾ì¿ìììì",
    4,
    "ìììììììììì¡",
    6,
    "ì©ìªì¬",
    7,
    "ì¶ì·ì¹ìºì»ì¿ììììììììììììì",
    4,
    "ì¢ì§",
    4,
    "ì®ì¯ì±ì²ì³ìµì¶ì·"
  ],
  [
    "a041",
    "ì¸ì¹ìºì»ì¾ì",
    5,
    "ììììì",
    6,
    "ìììì"
  ],
  [
    "a061",
    "ì",
    5,
    "ì¥ì¦ì§ì©ìªì«ì­",
    13
  ],
  [
    "a081",
    "ì»",
    4,
    "ì ì ì ì ì ì ì ",
    4,
    "ì ì ì ",
    4,
    "ì ì ì ¡ì ¢ì £ì ¥",
    6,
    "ì ®ì °ì ²",
    5,
    "ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",
    6,
    "ì¡ì¡ì¡",
    5,
    "ì¡",
    26,
    "ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",
    4,
    "ì¢ì¢ì¢ì¢ì¢ì¢",
    5,
    "ì¢",
    7,
    "ì¢ì¢ ì¢¢ì¢£ì¢¤"
  ],
  [
    "a141",
    "ì¢¥ì¢¦ì¢§ì¢©",
    18,
    "ì¢¾ì¢¿ì£ì£"
  ],
  [
    "a161",
    "ì£ì£ì£ì£ì£ì£ì£ì£ì£",
    6,
    "ì£ì£ì£",
    5,
    "ì£¢ì££ì£¥"
  ],
  [
    "a181",
    "ì£¦",
    14,
    "ì£¶",
    5,
    "ì£¾ì£¿ì¤ì¤ì¤ì¤",
    4,
    "ì¤ãããÂ·â¥â¦Â¨ãÂ­ââ¥ï¼¼â¼ââââããã",
    9,
    "Â±ÃÃ·â â¤â¥ââ´Â°â²â³ââ«ï¿ ï¿¡ï¿¥âââ â¥ââââ¡âÂ§â»ââââââââ¡â â³â²â½â¼âââââãâªâ«ââ½ââµâ«â¬âââââââªâ©â§â¨ï¿¢"
  ],
  [
    "a241",
    "ì¤ì¤",
    5,
    "ì¤",
    18
  ],
  [
    "a261",
    "ì¤­",
    6,
    "ì¤µ",
    18
  ],
  [
    "a281",
    "ì¥",
    7,
    "ì¥ì¥ì¥ì¥ì¥ì¥",
    6,
    "ì¥¢ì¥¤",
    7,
    "ì¥­ì¥®ì¥¯ââââÂ´ï½ËËËËËÂ¸ËÂ¡Â¿Ëâ®ââÂ¤ââ°âââ·â¶â¤â â¡â¥â§â£âââ£ââââ¤â¥â¨â§â¦â©â¨ââââÂ¶â â¡ââââââ­â©âªâ¬ã¿ãâãâ¢ããâ¡â¬Â®"
  ],
  [
    "a341",
    "ì¥±ì¥²ì¥³ì¥µ",
    6,
    "ì¥½",
    10,
    "ì¦ì¦ì¦ì¦ì¦"
  ],
  [
    "a361",
    "ì¦",
    6,
    "ì¦ì¦ì¦",
    16
  ],
  [
    "a381",
    "ì¦¯",
    16,
    "ì§ì§ì§ì§ì§ì§",
    4,
    "ì§ì§ì§ì§ì§ï¼",
    58,
    "ï¿¦ï¼½",
    32,
    "ï¿£"
  ],
  [
    "a441",
    "ì§ì§ì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²",
    5,
    "ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨ì¨ì¨"
  ],
  [
    "a461",
    "ì¨ì¨ì¨ì¨ì¨",
    5,
    "ì¨ì¨ì¨ì¨",
    12
  ],
  [
    "a481",
    "ì¨¦ì¨§ì¨¨ì¨ª",
    28,
    "ã±",
    93
  ],
  [
    "a541",
    "ì©",
    4,
    "ì©ì©ì©ì©ì©ì©",
    6,
    "ì©ì©¢",
    5,
    "ì©©ì©ª"
  ],
  [
    "a561",
    "ì©«",
    17,
    "ì©¾",
    5,
    "ìªìª"
  ],
  [
    "a581",
    "ìª",
    16,
    "ìª",
    14,
    "â°",
    9
  ],
  [
    "a5b0",
    "â ",
    9
  ],
  [
    "a5c1",
    "Î",
    16,
    "Î£",
    6
  ],
  [
    "a5e1",
    "Î±",
    16,
    "Ï",
    6
  ],
  [
    "a641",
    "ìª¨",
    19,
    "ìª¾ìª¿ì«ì«ì«ì«"
  ],
  [
    "a661",
    "ì«",
    5,
    "ì«ì«ì«ì«ì«ì«ì«ì«",
    5,
    "ì«¡",
    6
  ],
  [
    "a681",
    "ì«¨ì«©ì«ªì««ì«­",
    6,
    "ì«µ",
    18,
    "ì¬ì¬ââââââââ¬â¤â´â¼âââââââ£â³â«â»ââ â¯â¨â·â¿ââ°â¥â¸ââââââââââââ¡â¢â¦â§â©âªâ­â®â±â²âµâ¶â¹âºâ½â¾âââ",
    7
  ],
  [
    "a741",
    "ì¬",
    4,
    "ì¬ì¬ì¬ì¬ì¬ì¬ì¬",
    6,
    "ì¬¢",
    7
  ],
  [
    "a761",
    "ì¬ª",
    22,
    "ì­ì­ì­"
  ],
  [
    "a781",
    "ì­ì­ì­ì­ì­ì­ì­ì­ì­",
    6,
    "ì­ì­ì­ì­",
    5,
    "ì­¥",
    7,
    "ãããâããã£ã¤ã¥ã¦ã",
    9,
    "ããããããããã§ã¨ã°",
    9,
    "ã",
    4,
    "ãº",
    5,
    "ã",
    4,
    "â¦ãããããããã­ã®ã¯ãã©ãªã«ã¬ããããããã"
  ],
  [
    "a841",
    "ì­­",
    10,
    "ì­º",
    14
  ],
  [
    "a861",
    "ì®",
    18,
    "ì®",
    6
  ],
  [
    "a881",
    "ì®¤",
    19,
    "ì®¹",
    11,
    "ÃÃÂªÄ¦"
  ],
  [
    "a8a6",
    "Ä²"
  ],
  [
    "a8a8",
    "Ä¿ÅÃÅÂºÃÅ¦Å"
  ],
  [
    "a8b1",
    "ã ",
    27,
    "â",
    25,
    "â ",
    14,
    "Â½ââÂ¼Â¾ââââ"
  ],
  [
    "a941",
    "ì¯",
    14,
    "ì¯",
    10
  ],
  [
    "a961",
    "ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª",
    18
  ],
  [
    "a981",
    "ì¯½",
    14,
    "ì°ì°ì°ì°ì°ì°",
    6,
    "ì°ì°ì° ì°£ì°¤Ã¦ÄÃ°Ä§Ä±Ä³Ä¸ÅÅÃ¸ÅÃÃ¾Å§ÅÅã",
    27,
    "â",
    25,
    "â´",
    14,
    "Â¹Â²Â³â´â¿ââââ"
  ],
  [
    "aa41",
    "ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±",
    6,
    "ì°ºì°¿",
    4,
    "ì±ì±ì±ì±ì±ì±ì±"
  ],
  [
    "aa61",
    "ì±",
    4,
    "ì±ì±",
    5,
    "ì±¡ì±¢ì±£ì±¥ì±§ì±©",
    6,
    "ì±±ì±²"
  ],
  [
    "aa81",
    "ì±³ì±´ì±¶",
    29,
    "ã",
    82
  ],
  [
    "ab41",
    "ì²ì²ì²ì²ì²ì²ì²ì²ì²ì²¡",
    6,
    "ì²ªì²®",
    5,
    "ì²¶ì²·ì²¹"
  ],
  [
    "ab61",
    "ì²ºì²»ì²½",
    6,
    "ì³ì³ì³",
    5,
    "ì³ì³ì³ì³",
    5
  ],
  [
    "ab81",
    "ì³",
    8,
    "ì³¥",
    6,
    "ì³­ì³®ì³¯ì³±",
    12,
    "ã¡",
    85
  ],
  [
    "ac41",
    "ì³¾ì³¿ì´ì´",
    5,
    "ì´ì´ì´ì´ì´ì´",
    6,
    "ì´ì´ì´ì´ì´ "
  ],
  [
    "ac61",
    "ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­",
    11,
    "ì´º",
    4
  ],
  [
    "ac81",
    "ì´¿",
    28,
    "ìµìµìµÐ",
    5,
    "ÐÐ",
    25
  ],
  [
    "acd1",
    "Ð°",
    5,
    "ÑÐ¶",
    25
  ],
  [
    "ad41",
    "ìµ¡ìµ¢ìµ£ìµ¥",
    6,
    "ìµ®ìµ°ìµ²",
    5,
    "ìµ¹",
    7
  ],
  [
    "ad61",
    "ì¶",
    6,
    "ì¶",
    10,
    "ì¶ì¶ì¶ì¶ì¶ì¶ì¶ì¶"
  ],
  [
    "ad81",
    "ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª",
    5,
    "ì¶±",
    18,
    "ì·"
  ],
  [
    "ae41",
    "ì·",
    5,
    "ì·ì·ì·ì·",
    16
  ],
  [
    "ae61",
    "ì·¢",
    5,
    "ì·©ì·ªì·«ì·­ì·®ì·¯ì·±",
    6,
    "ì·ºì·¼ì·¾",
    4
  ],
  [
    "ae81",
    "ì¸ì¸ì¸ì¸ì¸ì¸ì¸ì¸",
    6,
    "ì¸ì¸ì¸ì¸ì¸",
    5,
    "ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"
  ],
  [
    "af41",
    "ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶",
    19
  ],
  [
    "af61",
    "ì¹",
    13,
    "ì¹ì¹ì¹ì¹ì¹¢",
    5,
    "ì¹ªì¹¬"
  ],
  [
    "af81",
    "ì¹®",
    5,
    "ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½",
    6,
    "ìºìºìº",
    5,
    "ìºìºìºìºìºìº"
  ],
  [
    "b041",
    "ìº",
    5,
    "ìº¢ìº¦",
    5,
    "ìº®",
    12
  ],
  [
    "b061",
    "ìº»",
    5,
    "ì»",
    19
  ],
  [
    "b081",
    "ì»",
    13,
    "ì»¦ì»§ì»©ì»ªì»­",
    6,
    "ì»¶ì»º",
    5,
    "ê°ê°ê°ê°ê°ê°ê°ê°",
    7,
    "ê°",
    4,
    "ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±ê±ê±ê±ê±ê±ê±°ê±±ê±´ê±·ê±¸ê±ºê²ê²ê²ê²ê²ê²ê²ê²ê²ê²ê²ê²ê²ê²ê²ê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³ê³ê³ê³ê³ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´ê´ê´"
  ],
  [
    "b141",
    "ì¼ì¼ì¼ì¼ì¼ì¼",
    6,
    "ì¼ì¼ì¼",
    5,
    "ì¼ì¼ì¼ì¼¡ì¼¢ì¼£"
  ],
  [
    "b161",
    "ì¼¥",
    6,
    "ì¼®ì¼²",
    5,
    "ì¼¹",
    11
  ],
  [
    "b181",
    "ì½",
    14,
    "ì½ì½ì½ì½ì½ì½",
    6,
    "ì½¦ì½¨ì½ªì½«ì½¬ê´ê´ê´ê´ê´ê´ê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµêµêµêµêµêµêµêµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶ê¶ê¶ê¶ê¶ê¶ê¶ê¶¤ê¶·ê·ê·ê·ê·ê·ê·ê·ê·ê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸ê¸ê¸ê¸ê¸ê¸ê¸ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"
  ],
  [
    "b241",
    "ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹",
    6,
    "ì¾ì¾ì¾ì¾ì¾",
    5,
    "ì¾"
  ],
  [
    "b261",
    "ì¾",
    18,
    "ì¾¢",
    5,
    "ì¾©"
  ],
  [
    "b281",
    "ì¾ª",
    5,
    "ì¾±",
    18,
    "ì¿",
    6,
    "ê¹¹ê¹»ê¹¼ê¹½êºêºêºêº¼êº½êº¾ê»ê»ê»ê»ê»ê»ê»ê»ê»ê»ê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼ê¼ê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½ê½ê½ê½ê½ê½ê½ê½¤ê½¥ê½¹ê¾ê¾ê¾ê¾ê¾ê¾ê¾ê¾¸ê¾¹ê¾¼ê¿ê¿ê¿ê¿ê¿ê¿ê¿ê¿ê¿ê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ëëëëëëëëë¨ëëëëëëëëëëë"
  ],
  [
    "b341",
    "ì¿",
    19,
    "ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"
  ],
  [
    "b361",
    "ì¿ª",
    5,
    "ì¿²ì¿´ì¿¶",
    5,
    "ì¿½ì¿¾ì¿¿íííí",
    5
  ],
  [
    "b381",
    "í",
    5,
    "í",
    5,
    "í",
    19,
    "ëë¼ë½ëëëëëëëëëëëë ë¡ë¢ë¨ë©ë«",
    4,
    "ë±ë³ë´ëµë¸ë¼ëëëëëëëëëë ë¥ëëëëëëëëëëëëë£ë¤ë¥ë¨ë¬ë´ëµë·ë¸ë¹ëëëëëëëëëëë ë¸ë¹ë¼ëëëëëëëëëëëë¨ëëëëë"
  ],
  [
    "b441",
    "í®",
    5,
    "í¶í·í¹íºí»í½",
    6,
    "ííí",
    5
  ],
  [
    "b461",
    "ííííííí",
    6,
    "í¡",
    10,
    "í®í¯"
  ],
  [
    "b481",
    "í±í²í³íµ",
    6,
    "í¾í¿íí",
    18,
    "ëë¨ë©ë¬ë°ë¹ë»ë½ëëëëëëëëëë ë´ë¼ëëë ë¨ë©ë´ëµë¼ëëëëëëëëëë ë¡ë£ë¥ë¦ëªë¬ë°ë´ëëëëëëëëëë¢ë¤ë¥ë¦ë¨ë«",
    4,
    "ë³ë´ëµë·",
    4,
    "ë¿ëëëëëëëëëëëëëëëëëëë¤ë¥"
  ],
  [
    "b541",
    "í",
    14,
    "í¦í§í©íªí«í­",
    5
  ],
  [
    "b561",
    "í³í¶í¸íº",
    5,
    "íííííí",
    5,
    "íí",
    4
  ],
  [
    "b581",
    "íííí¡í¢í£í¥",
    6,
    "í®í²",
    5,
    "í¹",
    11,
    "ë§ë©ë«ë®ë°ë±ë´ë¸ëëëëëëëëë ë¡ë¨ë¬ëëëëëëëëëëëëëë ë¤ë¨ë¼ëëëë ë¨ë©ë«ë´ëëëëë ë¡ë£ë¥ë¬ëëëë¤ë¨ë¬ëµë·ë¹ëëëëëëëë ë£ë¤ë¦ë¬ë­ë¯ë±ë¸ëëëëëë¤ë¥ë§ë¨ë©ëªë°ë±ë´ë¸"
  ],
  [
    "b641",
    "í",
    7,
    "í",
    17
  ],
  [
    "b661",
    "í ",
    15,
    "í²í³íµí¶í·í¹í»í¼í½í¾"
  ],
  [
    "b681",
    "í¿íí",
    5,
    "íííííí",
    6,
    "íí í¢",
    5,
    "í©íªí«í­ëëëëëëëëëëëëëë ë¡ë ë¡ë¤ë¨ëªë«ë°ë±ë³ë´ëµë»ë¼ë½ëëëëëëëëë¬ëëëëë¥ë¬ë´ëë¤ë¨ëëë ë¤ë«ë¬ë±ëë°ë´ë¸ëëëë¨ë©ë¬ë¯ë°ë¸ë¹ë»ëëëëëë ë¤ë¨ë°ë±ë³ëµë¼ë½ëëëëëëëëëë"
  ],
  [
    "b741",
    "í®",
    13,
    "í½",
    6,
    "ííííí"
  ],
  [
    "b761",
    "í",
    20,
    "í¢í£í¥í¦í§"
  ],
  [
    "b781",
    "í©",
    6,
    "í²í´í¶í·í¸í¹í»í½í¾í¿í",
    14,
    "ëëëë ë¨ë©ë«ë¬ë­ë´ëµë¸ëëë¬ë­ë°ë´ë¼ë½ë¿ë ë ë ë ë ë ë ë ë ë ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡ë¡ë¡ë¡ë¡ë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£ë£ë£ë£ë£ë£ë£ë£ë£ë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤ë¤ë¤ ë¤¼ë¤½ë¥ë¥ë¥ë¥ë¥ë¥ë¥ë¥ë¥ ë¥¨ë¥©"
  ],
  [
    "b841",
    "í",
    7,
    "í",
    17
  ],
  [
    "b861",
    "í«",
    8,
    "íµí¶í·í¹",
    13
  ],
  [
    "b881",
    "íí",
    5,
    "í",
    24,
    "ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦ë¦ë¦ë¦ë¦ë¦ë¦ë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ë§ë§ë§",
    4,
    "ë§ë§ë§ë§ë§ë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨ë¨ë¨ë¨ë¨¸ë¨¹ë¨¼ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©ë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªëªëªëªëªëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«ë«ë«ë«ë«¼"
  ],
  [
    "b941",
    "íªí«í®í¯í±í²í³íµ",
    6,
    "í¾íí",
    5,
    "íííí"
  ],
  [
    "b961",
    "í",
    14,
    "í",
    6,
    "í¥í¦í§í¨"
  ],
  [
    "b981",
    "í©",
    22,
    "íííííííííë¬ë¬ë¬ë¬ë¬ë¬ë¬ë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­ë­ë­ë­ë­ë­ë­ë­ë­ë­¡ë­£ë­¬ë®ë®ë®ë®¤ë®¨ë®¬ë®´ë®·ë¯ë¯ë¯ë¯ë¯ë¯¸ë¯¹ë¯¼ë¯¿ë°ë°ë°ë°ë°ë°ë°ë°ë°ë°",
    4,
    "ë°",
    4,
    "ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±ë±ë±ë±ë±ë±ë±ë±ë±ë±ë²ë²ë²ë²ë²ë²ë²ë²ë²"
  ],
  [
    "ba41",
    "ííííííí",
    5,
    "íííí¡í¢í£í¥",
    6,
    "í­"
  ],
  [
    "ba61",
    "í®í¯í°í²",
    5,
    "íºí»í½í¾íí",
    4,
    "íí",
    5
  ],
  [
    "ba81",
    "ííííííííí",
    6,
    "í¦",
    9,
    "í²í³íµí¶í·í¹íºë²ë²ë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³ë³ë³ë³ë³ë³ë³ë³ë³ë³´ë³µë³¶ë³¸ë³¼ë´ë´ë´ë´ë´ë´ë´¤ë´¬ëµëµëµëµëµëµëµëµ¤ëµ¨ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶ë¶¤ë¶°ë¶¸ë·ë·ë·ë·ë·©ë·°ë·´ë·¸ë¸ë¸ë¸ë¸ë¸ë¸ë¸ë¸ë¸ë¸ë¹ë¹ë¹ë¹ë¹ë¹ë¹ë¹ë¹ë¹ë¹ë¹ ë¹¡ë¹¤"
  ],
  [
    "bb41",
    "í»",
    4,
    "ííí",
    5,
    "íííííí",
    4,
    "íí¢í£"
  ],
  [
    "bb61",
    "í¤í¦í§íªí«í­í®í¯í±",
    6,
    "íºí¾",
    5,
    "íííí"
  ],
  [
    "bb81",
    "í",
    31,
    "ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëºëºëºëºëºëºëºëºëºëº¨ë»ë»ë»ë»ë»ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ë¼ë¼ë¼ë¼ë¼ë¼ë½ë½ë½ë½ë½ë½ë½ë¾ë¾°ë¿ë¿ë¿ë¿ë¿ë¿ë¿ë¿¡ì¼ìììì ì¨ì©ììììì ì¡ì£ì¥ì¬ì­ì¯ì°ì³ì´ìµì¶ì¼ì½ì¿ììììììììììììì¤"
  ],
  [
    "bc41",
    "íª",
    17,
    "í¾í¿íííííí"
  ],
  [
    "bc61",
    "íííííí",
    5,
    "íííííí¡",
    6,
    "íªí¬í®"
  ],
  [
    "bc81",
    "í¯",
    4,
    "íµí¶í·í¹íºí»í½",
    6,
    "ííí",
    5,
    "í",
    5,
    "ì¥ì¨ì¬ì´ìµì·ì¹ìììììì",
    4,
    "ì£ì¤ì¦ì§ì¬ì­ì¯ì°ì±ì¶ì¸ì¹ì¼ììììììììììì¤ì¥ì§ì¨ì©ì°ì´ì¸ììììììììììì¡ì¥ì¨ì©ì¬ì°ì½ììììììì ì¤ì¨ì°ì±ì³ì¼ì½ììììììììììì ì¨ì©ì«ì­"
  ],
  [
    "bd41",
    "íí",
    7,
    "í¢í¤",
    7,
    "í®í¯í±í²í³íµí¶í·"
  ],
  [
    "bd61",
    "í¸í¹íºí»í¾íí",
    5,
    "í",
    13
  ],
  [
    "bd81",
    "í",
    5,
    "í",
    25,
    "ì¯ì±ì²ì´ìììììì ì¥ì¬ì­ì°ì´ì¼ì½ì¿ìììììììì¤ì¥ì¨ì¬ì­ì´ìµì·ì¹ììì ì£ì¤ì«ì¬ì­ì¯ì±ì¶ì¸ì¹ì»ì¼ììììììììììì¤ì¥ì¨ì©ìì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ììììììììì ì¢ì¨ì©ì­ì´ìµì¸ììì¤ì¬ì°"
  ],
  [
    "be41",
    "í¸",
    7,
    "íííí",
    14
  ],
  [
    "be61",
    "í",
    7,
    "íííí¡í¢í£í¥",
    7,
    "í®í°í±í²"
  ],
  [
    "be81",
    "í³",
    4,
    "íºí»í½í¾íí",
    4,
    "ííí",
    5,
    "í",
    8,
    "ì´ì¼ì½ìì¤ì¥ì¨ì¬ì´ìµì¹ìììì¸ì¼ì©ì°ì±ì´ì¸ìºì¿ììììììì¨ì©ì¬ì°ì¸ì¹ì»ì½ììììììììììììììììì ì¡ì¤ì¨ì°ì±ì³ì´ìµì¼ì½ìììììììììììì ì©ì´ìµì¸ì¹ì»ì¼ì½ì¾ì",
    6,
    "ìì"
  ],
  [
    "bf41",
    "í",
    10,
    "íª",
    14
  ],
  [
    "bf61",
    "í¹",
    18,
    "ííííííí"
  ],
  [
    "bf81",
    "í",
    5,
    "ííí ",
    7,
    "í©íªí«í­í®í¯í±",
    6,
    "í¹íºí¼ììììì ì¡ì£ì¥ì¬ì­ì®ì°ì´ì¶ì·ì¼",
    5,
    "ììììììììììì¤ì¥ì¨ì¬ì­ì®ì°ì³ì´ìµì·ì¹ì»ìììììììììììì ì¬ì¯ì±ì¸ì¹ì¼ìììììììììì¤ì¥ì§ì©ì°ì±ì´ì¸ì¹ìºììììììììììì ì¡ì¨"
  ],
  [
    "c041",
    "í¾",
    5,
    "ííííííí",
    6,
    "íí",
    5
  ],
  [
    "c061",
    "í",
    25
  ],
  [
    "c081",
    "í¸í¹íºí»í¾í¿íííí",
    6,
    "ííí",
    5,
    "íííííí¡í¢í£ì©ì¬ì°ì¸ì¹ì½ììììììììì ì¡ì¤ì¨ì°ì±ì³ìµì·ì¼ì½ììììììì",
    7,
    "ìì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìììììììììììììììì ì¡ì£ì¤ì¥ì¦ì¬ì­ì°ì´ì¼ì½ì¿ìììììììììì¤ì¨ì¬ì ì ì ì ì "
  ],
  [
    "c141",
    "í¤í¦í§íªí¬í®",
    5,
    "í¶í·í¹íºí»í½",
    6,
    "ííí"
  ],
  [
    "c161",
    "ííííí",
    19,
    "í¦í§"
  ],
  [
    "c181",
    "í¨",
    31,
    "ì ì ì ì ì ì ì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡ì¡ì¡ì¡ì¡ì¡ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢ì¢ì¢ì¢ì¢ì¢ì¢ì¢ì¢ì¢ì¢ì¢ì¢¡ì¢¨ì¢¼ì¢½ì£ì£ì£ì£ì£ì£ì£ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤ì¤ì¤ì¤ì¤ì¤ì¤ì¤ì¤ì¤¬ì¤´ì¥ì¥ì¥ì¥ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ì¦ì¦ì¦ì¦ì¦ì¦ì¦ì§ì§ì§ì§ì§ì§ì§ì§ì§"
  ],
  [
    "c241",
    "ííííííí",
    4,
    "ííí",
    5,
    "í¦í§í©íªí«í­í®"
  ],
  [
    "c261",
    "í¯",
    4,
    "í¶í¸íº",
    5,
    "íííííí",
    6,
    "í"
  ],
  [
    "c281",
    "í",
    5,
    "íííí¡í¢í£í¥",
    7,
    "í®",
    9,
    "íºí»ì§ì§ì§ì§ì§ì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨ì¨ì¨ì¨ì¨ì¨ì¨ì¨ì¨©ì©ì©ì©ì©ì©ì©ì©ì© ì©¡ì©¨ì©½ìªìªìª¼ìª½ì«ì«ì«ì«ì«ì«ì«ì«ì«ì« ì«¬ì«´ì¬ì¬ì¬ì¬ì¬ ì¬¡ì­ì­ì­ì­ì­ì­ì­ì­ì­¤ì­¸ì­¹ì®ì®¸ì¯ì¯¤ì¯§ì¯©ì°ì°ì°ì°ì°ì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"
  ],
  [
    "c341",
    "í½í¾í¿ííííííííííííííííííí",
    4
  ],
  [
    "c361",
    "í¢",
    4,
    "í¨íª",
    5,
    "í²í³íµ",
    11
  ],
  [
    "c381",
    "íííí",
    5,
    "íííííí",
    7,
    "íí í¢",
    5,
    "í©íªì°¼ì°½ì°¾ì±ì±ì±ì±ì±ì±ì±ì±ì±ì± ì±¤ì±¦ì±¨ì±°ì±µì²ì²ì²ì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³ì³ì³ì³ì³ì³ì³¤ì³¬ì³°ì´ì´ì´ì´ì´ì´ì´ì´ì´ì´¤ì´¨ì´¬ì´¹ìµìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ì¶ì¶ì¶ì¶ì¶¤ì¶¥ì¶§ì¶©ì¶°ì·ì·ì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸ì¸ì¸ì¸ì¸ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"
  ],
  [
    "c441",
    "í«í­í®í¯í±",
    7,
    "íºí¼",
    7,
    "ííííí"
  ],
  [
    "c461",
    "íííííííííí",
    5,
    "í¡í¢í£í¥í¦í§í©",
    4
  ],
  [
    "c481",
    "í®í¯í±í²í³í´í¶",
    5,
    "í¾í¿íííí",
    11,
    "íííì¹ì¹ì¹ì¹ì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìºìºìºìºìºìºìºìºìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼ì¼ì¼ì¼ì¼ì¼ì¼ì¼ì¼ì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½ì½ì½ì½ì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾ì¾ì¾ì¾¡ì¾¨ì¾°ì¿ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼ííííí­í´íµí¸í¼"
  ],
  [
    "c541",
    "ííííííííí¡",
    6,
    "íªí¬í®",
    5,
    "í¶í·í¹"
  ],
  [
    "c561",
    "íºí»í½",
    6,
    "íííí",
    5,
    "íííí",
    4
  ],
  [
    "c581",
    "íí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",
    6,
    "í¾í¿íí",
    5,
    "íííííííííí í¬í­í°í´í¼í½íí¤í¥í¨í¬í´íµí·í¹ííííííííííííí í¤í¬í­í¯í°í±í¸íí°í±í´í¸íºííííííííííííí¡í¨í¬í¼ííí í¡í¤í¨í°í±í³íµíºí¼ííí´í¸íííí¬í­í°í´í¼í½í¿ííí"
  ],
  [
    "c641",
    "íííí",
    6,
    "ííí",
    5
  ],
  [
    "c6a1",
    "í¤ííííííííí í¤í¬í±í¸í¹í¼í¿ííííííííí¤í¥í°í±í´í¸íííííííííííííí í¡í¥í¨í©í¬í°í¸í¹í»í¼í½ííí¼í½ííííííííííí í¨í©í«í­í´í¸í¼ííííííí¡í£í¬í­í°í´í¼í½í¿í"
  ],
  [
    "c7a1",
    "íííííí í¤í­í¯í¸í¹í¼í¿íííííííí©íííííí¨í¬í°í¸í»í½ííííííí¼í½íííííííííí í¥í¨í©í«í­í´íµí¸í¼ííííííí¥íííííííííí¤í¥í¨í¬í´íµí·í¹ííííííííííí "
  ],
  [
    "c8a1",
    "í¤í­í¸í¹í¼íííííííííííí§í©í°í±í´ííííííííí¡í¨í¬í°í¹í»ííííííííí í¤í¨í°íµí¼í½ííííííí í¨í©í«í­í´íµí¸í¼ííííííííííí í¡í£í¥í©í¬í°í´í¼í½ííííííííí"
  ],
  [
    "caa1",
    "ä¼½ä½³åå¹å å¯åµå¥åå«å®¶ææ¶æ·æ¯æ­ççç¨¼èèè¡è¢è¨¶è³è·è»»è¿¦é§å»å´åæªæ¤æ®¼çèè¦ºè§é£ä¾åå¢¾å¥¸å§¦å¹²å¹¹ææææ¬æ¡¿æ¾ççç£µç¨ç«¿ç°¡èè®è±è««éä¹«åæ·æ¸´ç¢£ç«­èè¤èé¨ååå ªåµææ¾æ¡æ¢ææ©æ¸çç³ç£ç°ç´ºé¯ééé¾"
  ],
  [
    "cba1",
    "å£å²¬ç²èééåå å§å²¡å´åº·å¼ºå½æ·æ±çºçç³ çµ³ç¶±ç¾èè¡èè¥è¬é¼éé±ä»ä»·åå±å¡æ·æ¾æ¨æ¹æ§ªæ¼ç¥ççç®è¥èï¤é§éåå®¢åï¤ç²³ç¾¹éµå¨å»å±å·¨ææ®ææ§æ¸ ç¬ç¥è·è¸ï¤é½éé¸ä¹¾ä»¶å¥å·¾å»ºææ¥è±èè¹éµé¨«ä¹åæ°æ¡åååæª¢"
  ],
  [
    "cca1",
    "ç¼éé»å«æ¯è¿²åæ©æ­ææ ¼æªæ¿èè¦¡éå ç½ç¬ççµ¹ç¹­è©è¦è­´é£éµææ±ºæ½çµç¼ºè¨£å¼æç®è¬ééäº¬ä¿åå¾åååå¿å°å¢åºå¾æ¶æ¬ææ¬æ¯æ»æ´æ¢æ¶çç±çç¥ççç¡¬ç£¬ç«ç«¶çµç¶èè¿èèè­¦è¼éé¡é é ¸é©é¯¨ä¿åå ºå¥å­£å±æ¸ææ¡æ¢°"
  ],
  [
    "cda1",
    "æ£¨æºªçç¸ç£ç¨½ç³»ç¹«ç¹¼è¨èª¡è°¿éé·å¤å©åå±åºå§å­¤å°»åº«æ·æ·ææ²æ æ¯æ§æ²½ç¼çç¾ç¨¿ç¾èè¡èè¦è½è°èè ±è¢´èª¥ï¤è¾é®éé¡§é«é¼å­ææ²æ¢ç©è°·éµ å°å¤å´ææ¢±æ£æ»¾ç¨è¢é¯¤æ±¨ï¤éª¨ä¾å¬å±åå­å·¥ææ­æ±æ§æ»çç©ºè£è²¢éä¸²å¯¡ææç"
  ],
  [
    "cea1",
    "ç§èèªèª²è·¨ééé¡å»æ§¨è¿é­ï¤å å®å¯¬æ£æ£ºæ¬¾çç¯çç®¡ç½èè§è²«éé¤¨å®ææ¬éä¾åå¡å£å»£æ æ´¸çççç­è±éå¦æç½«ä¹åå¡å£æªæ§ææ§é­å®ç´è±è½äº¤åå¬å¬å¬å¶ å·§æªææ ¡æ©ç¡çç¯çµç¿¹è èèè¼è½éé¤é©é®«ä¸ä¹ä¹ä»ä¿±å·å¾"
  ],
  [
    "cfa1",
    "åå£å¥åååµå¢å¯å¶å»æ¼æææ¸æ©æ§æ­æ¯æ¯¬æ±æºç¸çççç¿ç©ç©¶çµ¿èè¼èèèè¡¢è¬³è³¼è»éé±é¤é¶é§é©é³©é·é¾åå±èé é«éº´åçªç¾¤è£è»é¡å å±æçªå®®å¼ç©¹çª®èèº¬å¦å¸å¸å·åæ³æ²æ¬æ·ç·å¥çè¨è¹¶éæºæ«æ½°è©­è»é¥ï¤æ·æ­¸è²´"
  ],
  [
    "d0a1",
    "é¬¼ï¤å«å­å¥ææ§»çªç¡çªºç«ç³¾èµè¦èµ³éµé¨å»åçç­ èéï¤æ©åååææ£æ¥µéåå¤å¤ææ¤æ ¹æ§¿ç¾ç­è¹è«è¦²è¬¹è¿é¥ï¤ä»å¦æææªç´ç¦ç¦½è©è¡¾è¡¿è¥ï¤é¦ä¼åæ¥æ±æ±²ç´çµ¦äºå¢çè¯ä¼ä¼å¶ååå¨å»åºå¼å¤å¥å¦å¯å²å´å·±å¹¾å¿æææ£"
  ],
  [
    "d1a1",
    "ææææ£æ£æ©æ¬ºæ°£æ±½æ²æ·çç¦çªçç£ç¸ç¿ç¢ç£¯ç¥ç¥ç¥ç¥ºç®ç´ç¶ºç¾èè­èè¨è­è±èµ·é¡é¤é£¢é¥é¨é¨é©¥éºç·ä½¶åæ®æ¡éå«åºï¤ï¤å¨æ¦ï¤ææ¿ï¤",
    5,
    "é£ï¤",
    4,
    "è«¾ï¤ï¤ï¤ï¤æï¤çï¤ï¤é£ï¤ ææºåï¤¡ææ¥ æ¹³ï¤¢ç·ï¤£ï¤¤ï¤¥"
  ],
  [
    "d2a1",
    "ç´ï¤¦ï¤§è¡²åå¨ï¤¨",
    4,
    "ä¹ï¤­å§å¥æ°èï¤®å¥³å¹´æç§å¿µæ¬ææ»å¯§å¯åªï¤¯å¥´å¼©æï¤°ï¤±ï¤²çï¤³",
    5,
    "é§ï¤¹",
    10,
    "æ¿ï¥ï¥è¿è¾²æ±ï¥ï¥è¦ï¥ï¥å°¿ï¥",
    7,
    "å«©è¨¥æ»ç´ï¥",
    5,
    "è½ï¥ï¥å°¼æ³¥å¿æººå¤è¶"
  ],
  [
    "d3a1",
    "ä¸¹äº¶ä½å®åå£å½æ·æ¦æªæ®µæ¹ç­ç«¯ç°ç·èè¢é²éæ»æ¾¾çºç¸éååæºæææ·¡æ¹æ½­æ¾¹ç°èè½èè¦è«è­éæ²çç­è¸éåå å¡å¹¢æææ£ ç¶ç³è³é»¨ä»£åå®å¤§å°å²±å¸¶å¾æ´æ¡ç³èºè¢è²¸éé»å®å¾·æ³ååå°åå µå¡å°å± å³¶å¶åº¦å¾æ¼ææææ¡"
  ],
  [
    "d4a1",
    "æ£¹æ«æ·æ¸¡æ»æ¿¤ç¾çç¹ç¦±ç¨»èè¦©è³­è·³è¹éééé½éé¶éæ¯ççç¢ç¨ç£ç¦¿ç¯¤çºè®å¢©ææ¦æ½æ¾æ²ççè±é ä¹­çªä»å¬åååæ§æ±æ¡æ£æ´æ½¼ç¼ç³ç«¥è´è£éåæææçç«è³ï¥è±éé ­å±¯èèéé¯éå¾å¶æ©çç»ç­è¤è¬é§é¨°åæ¶ï¥ç©ç¾"
  ],
  [
    "d5a1",
    "è¿èºè£¸éï¥æ´çççµ¡è½ï¥éªé§±ï¥äºåµæ¬æ¬ç¾çè­é¸åè¾£åµæ¥æ¬æ¬æ¿«ç±çºèè¥¤è¦½æèè å»ææµªç¼çç¯èéä¾å´å¾ èå·æ ç¥äº®åå©åæ¢æ¨ç²®ç²±ç³§è¯è«è¼éä¾¶å·åµåå»¬æ®æ¾ææ«æ¿¾ç¤ªèè £é­é©¢é©ªéºé»åææ­·çç¤«è½¢éæææ£æ¼£"
  ],
  [
    "d6a1",
    "ççç·´è¯è®è¼¦é£éå½åå£æ´çè£å»ææ®®æ¿ç°¾çµä»¤ä¼¶å¹ï¥å²ºå¶ºæç²ç¬­ç¾ç¿èéé´é¶éé é½¡ä¾æ¾§ç¦®é´é·åï¥ æææ«æ½ççç§èèèè·¯è¼é²é­¯é·ºé¹µç¢ç¥¿ç¶ èéé¹¿éºè«å£å¼æ§ç§çç± è¾å¡ç¨ç¢ç£è³è³è³´é·äºåå¯®å»æççç­èè¼"
  ],
  [
    "d7a1",
    "é¼é¬§é¾å£å©å±¢æ¨æ·æ¼ç»ç´¯ç¸·èè¤¸é¤éåææ³æ¦´æµæºççç çç¤ç¡«è¬¬é¡å­æ®é¸ä¾å«å´æ·ªç¶¸è¼ªå¾ææ ï¥¡éåèååæ¥ç¨ç¶¾è±éµä¿å©åååå±¥æ§ææ¢¨æµ¬çç¸ççï¥¢ç¢ç±¬ç½¹ç¾¸èè£è£¡ééé¢é¯åæ½¾ççèºèºªé£é±éºææ·ç³è¨éç ¬"
  ],
  [
    "d8a1",
    "ç«ç¬ ç²æ©çªç²ç¢¼ç£¨é¦¬é­éº»å¯å¹æ¼ èè«éä¸åå¨©å·å½æ¢æ½æ©æ¼æ»¿æ¼«ç£çè¬èè »è¼é¥é°»åæ¹æ«æ²«èè¥ªéºäº¡å¦å¿å¿æç¶²ç½èè«è½è¼éåå¦¹åªå¯æ§ææ¢æ¯ç¤ç½µè²·è³£éé­èè²éé©éº¥å­æ°çç²çèåªè¦åååæ£æ²çç ç¶¿ç·¬é¢éºµæ»"
  ],
  [
    "d9a1",
    "èå¥åå½æææ¤§æºç¿çèèèé©éé³´è¢ä¾®ååå§å¸½ææ¸æ¹æ®ææ¨¡æ¯æ¯çç¡çç¸çèè¼èè¬è¬¨è²æ¨æ²ç§ç®ç¦ç©é¶©æ­¿æ²å¤¢æ¦èå¯å¢å¦å»ææ´æ³æ¸ºç«ç«èé¨åå·«æ®ææææ«æ æ¥æ­¦æ¯ç¡ç·çç¹èèèªèª£è²¿é§éµ¡å¢¨é»ååå»åæ"
  ],
  [
    "daa1",
    "æ±¶ç´ç´èèéé¯å¿æ²ç©å³åªå°¾åµå½å¾®æªæ¢¶æ¥£æ¸¼æ¹çç±³ç¾èè¬è¿·é¡é»´å²·æ¶ææ«ææ»æ¼æ°æ³¯ççç·¡éå¯èè¬ååæææ²æ´æ¨¸æ³ççç®ç²ç¸èè¶èè¿«é¹é§ä¼´åååææ¬æææ§æ³®æ½ç­çç¢ç¤ç¼ç£ç£»ç¤¬çµè¬è è¿é é£¯åææ¥æ¸¤æ½"
  ],
  [
    "dba1",
    "ç¼è·é±é¢é«®é­å£ååå¦¨å°¨å¹å½·æ¿æ¾æ¹ææææ¦æ»ç£ç´¡èªèè«è³è¡èè¨ªè¬é¦é²é¾åä¿³ï¥£å¹å¾æææ¯æ¹ççèèè£´è£µè¤è³ è¼©ééªä¼¯ä½°å¸ææ ¢ç½ç¾é­å¹¡æ¨ç©ççªï¥¤ç¹èè©é£ä¼ç­ç½°é¥å¡å¸æ¢µæ°¾æ±æ³ç¯ç¯èæ³çºå»åå£ææªç§ç"
  ],
  [
    "dca1",
    "ç¢§èé¢é¹ï¥¥åå¼è®è¾¨è¾¯éå¥ç¥é±é¼ä¸ååµå±å¹·ææºææ£ç³ççç§ç«è¼§é¤ é¨ä¿å ¡å ±å¯¶æ®æ­¥æ´æ¹ºæ½½ç¤ç«è©è£è¤è­è¼ä¼åååå®å¾©æç¦è¹è¯èè¤è¦è¼¹è¼»é¦¥é°æ¬ä¹¶ä¿¸å¥å°å³¯å³°æ§æ£ç½ç¢ç«ç¸«è¬èé¢éé³³ä¸ä»ä¿¯ååå¯å¦åå å¤«å©¦"
  ],
  [
    "dda1",
    "å­å­µå¯åºï¥¦æ¶æ·æ§æµ®æº¥ç¶ç¬¦ç°¿ç¼¶èèèèèè©è¨è² è³¦è³»èµ´è¶ºé¨éééé§é³§ååå©å´å¢³å¥å¥®å¿¿æ¤æ®ææ±¾ççç²ç³ç´è¬è³é°ï¥§ä½å¼å½¿æå´©ææ£ç¡¼ç¹éµ¬ä¸åååªåå¦å©¢åºæ²æææ¹æææ¦§æ¯æ¯æ¯æ¯æ²¸ï¥¨çµçºç ç¢ç§ç§ç²ç·ç¿¡è¥"
  ],
  [
    "dea1",
    "è¾èè²èè£¨èª¹è­¬è²»ééé£é¼»å¬å¬ªå½¬ææª³æ®¯æµæ¿±ççç­è²§è³é »ææ°·èé¨ä¹äºäºä»ä¼ºä¼¼ä½¿ä¿å¿å²å¸åå£åå£«å¥¢å¨å¯«å¯ºå°å·³å¸«å¾ææ¨ææ¯æ¶æ»æ¢­æ­»æ²æ³æ¸£ççç ç¤¾ç¥ç¥ ç§ç¯©ç´çµ²èèèèèè£è©è©è¬è³èµ¦è¾­éªé£¼é§éºåï¥©æï¥ª"
  ],
  [
    "dfa1",
    "ååªå±±æ£æ±çç£çç®èé¸é°ä¹·ææ®ºçè©ä¸ï¥«ææ£®æ¸èèè¡«æ·æ¾éé¢¯ä¸å·ååååªåå­å°å³ å¸¸åºåº å»æ³æ¡æ©¡æ¹ç½ççç¸ç¥¥ç®±ç¿è£³è§´è©³è±¡è³éå¡ç½è³½åï¥¬ç©¡ç´¢è²ç²çç¥ï¥­ç¬å¢å£»å¶¼åºåº¶å¾æææ¿ææææ¸æ æ£²ççç­®çµ®ç·ç½²"
  ],
  [
    "e0a1",
    "è¥èè¯è¥¿èªéé¤é»é¼ å¤å¥­å¸­æææ³ææ±æ·æ½ç³ç¢©èéé«ä»åååå¬å®£ææ¾ææ¸²ç½çççç¿ç¬ç¦ªç·ç¹ç¾¨èºè³è¹èè¬è©µè·£é¸éé¥é¥é®®å¨å±æ¥æ³æ´©æ¸«èèè¤»è¨­èªªéªé½§å¡æ¹æ®²çºè¾è´ééææ¶ç®ï¥®åå§å®¬æ§æºæææç©ç¹ççç­¬"
  ],
  [
    "e1a1",
    "èè²è¥èª éä¸å¢æ­²æ´ç¨ç¬¹ç´°ï¥¯è²°å¬å¯å¡å®µå°å°å·¢ææææ­æ¢³æ²¼æ¶æº¯çç¤çç¦çççç¬ç¯ ç°«ç´ ç´¹è¬è­èè¨´éé¡éµé·é¶é¨·ä¿å±¬ææ¶ç²çºè¬è´éå­«å·½æèéé£¡çå®ææ¾æ·è¨èª¦éé å·ï¥°çç¢éè¡°éä¿®åå½ååå£½å«å®å²«å³å¸¥æ"
  ],
  [
    "e2a1",
    "æææææ¶æ¸æ¨¹æ®æ°´æ´æ¼±ç§ç©ç¸çç²ç¦ç¡ç§ç©ç«ªç²¹ç¶ç¶¬ç¹¡ç¾è©è±èèèªè¢èª°è®è¼¸ééé¬éé¹éé§é¨ééé é¦é«é¬åå¡¾å¤å­°å®¿æ·æ½çç¡ç¹èè½å·¡å¾å¾ªææ¬æ æ¥¯æ©æ®æ´µæ·³ç£ç¾ç¬ç­ç´è£èèè´è£è©¢è«ééé é¦´æè¡è¿°é¥å´å´§"
  ],
  [
    "e3a1",
    "åµ©çèè¨æ¿æ¾ç¿è¤¶è¥²ä¸ä¹å§ååæ¿æç¹©è éä¾åå¶å§åª¤å°¸å±å±å¸å¼ææ½æ¯ææ¾æ´çç¢ç¤ºç¿èèè¦è©¦è©©è«¡è±è±ºå´å¯å¼æ¯æ­æ¤æ®æ¹çç¯èè­è»¾é£é£¾ä¼¸ä¾ä¿¡å»å¨ å®¸æ¼æ°æ¨ç¼ç³ç¥ç´³èè£èèªèèè¨èº«è¾ï¥±è¿å¤±å®¤å¯¦æå¯©å°å¿æ²"
  ],
  [
    "e4a1",
    "ï¥²æ·±ççè¯è«¶ä»åï¥³éæ°äºä¿ååå¨¥å³¨æçè½èªè¾è¡è¨é¿éé¤é´éµå å²³å¶½å¹æ¡ææ¡æ¨æ¸¥ééé¡é°é½·å®å²¸æææ¡ç¼ééé¡é®æ¡è¬è»é¼åµå²©å·åºµæçè´éå£æ¼çé´¨ä»°å¤®ææ»æ®ç§§é´¦åååå´æææ¶¯ç¢è¾ééåæ¼ææ¶²ç¸èé¡"
  ],
  [
    "e5a1",
    "æ«»ç½é¶¯é¸ä¹å»å¶å¤æ¹æ¶æ¤°çºè¶ï¥´éå¼±ï¥µï¥¶ç´è¥è¯è»è¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ææææ­æï¥ºæ¥æ¨£æ´çç¬ççç¦³ç©°ï¥»ç¾ï¥¼è¥ï¥½è®éé½ï¥¾é¤åå¾¡æ¼æ¼çç¦¦èªé¦­é­é½¬åæ¶ææªèåå °å½¦çè¨è«ºå­¼èä¿ºå¼å´å¥æ©æ·¹å¶ªæ¥­åäºä½ï¥¿ï¦ï¦å¦ï¦"
  ],
  [
    "e6a1",
    "ï¦æ­æ±ï¦çµç¤ï¦èèè¹è¼¿è½ï¦é¤ï¦ï¦ï¦äº¦ï¦åå½¹æï¦ï¦ç«ç¹¹è­¯ï¦éé©å¥å §å§¸å¨å®´ï¦å»¶ï¦ï¦ææ»ï¦æ¤½æ²æ²¿æ¶æ¶æ·µæ¼ï¦çç¶çï¦ççï¦ç¡ç¡¯ï¦ç­µç·£ï¦ç¸¯ï¦è¡è»ï¦ï¦ï¦éï¦é³¶ï¦ï¦ï¦ææ¶ï¦ç±ï¦ ï¦¡é±å­ï¦¢ï¦£ï¦¤æï¦¥çç°ç°è¶è"
  ],
  [
    "e7a1",
    "ï¦¦é»é«¥é¹½æï¦§çèï¦¨ï¦©å¡ï¦ªï¦«å¶¸å½±ï¦¬æ ææ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿çç¯ççç°ï¦­çï¦®ççç©çºï¦¯ï¦°è±è© è¿ï¦±éï¦²éï¦³ï¦´ä¹åªï¦µåå¡æ³æ±­æ¿çç¿ç©¢è®èèï¦¶è£è©£è­½è±«ï¦·é³ï¦¸éé äºä¼ä¿å²åå¾å³åå¡¢å¢ºå¥§å¨å¯¤æï¦¹æææ¿æ¤æ¢§æ±æ¾³"
  ],
  [
    "e8a1",
    "çç¬çç­½èèª¤é°²é¼å±æ²ççéºæº«ç¥çç©©ç¸èåå£æç®çç°ç¿ééé¥æ¸¦ç¦çª©çªªè¥èè¸è¨å©å®å®æ¢¡æ¤æµ£ç©çç¬ç¢ç·©ç¿«èèèè±é®é æ°å¾æºææ±ªçå­å¨æ­ªç®å¤åµ¬å·ç¥çï¦ºï¦»å¥å¹å ¯å¤­å¦å§å¯¥ï¦¼ï¦½å¶¢ææææ¾ï¦¾æï¦¿æ©ï§ç¿ç¤ï§"
  ],
  [
    "e9a1",
    "çªçª¯ç¹ç¹èè°ï§è¯è¦è¬ éï§éé¥æ¾æ¬²æµ´ç¸è¤¥è¾±ä¿å­åååå¢å®¹åº¸ææ¦æ¶æ¹§æº¶çç¢ç¨ç¬è³è¸èè¸ééï§äºä½å¶åªååå³å®å¯å°¤æææ´ççççç¥ç¦ç¦¹ç´ç¾½èèèè¿ééµéªéé¨é©åå½§æ­æ±æ ¯çç¨¶éé äºï§æ©æ®æ¾çèè¸è"
  ],
  [
    "eaa1",
    "ééé²é»èé¬±äºçéååå¡ååå£åªå«å¯æ¨æ¿æ´æ²æ´¹æ¹²æºç°ç¿çèè¢è½é ï§é¢é¡é´æè¶éä½ååå±åå§å¨å°æ°ææ¸­ç²çç·¯èèè¦è¿èè¡è¤è¬ééé­ä¹³ä¾ååªï§å¯å©å­ºå®¥å¹¼å¹½åº¾æ æææææ¸æï§ææï§æ¥¡æ¥¢æ²¹æ´§ï§æ¸¸ï§"
  ],
  [
    "eba1",
    "æ¿¡ç¶ç·ï§çç±ï§çï§ï§ç¶­è¾è¸è£èªè«è«­è¸°è¹éé¾éºééé®ï§ï§å ï§æ¯èè²ï§ï§åå¥«å°¹ï§ï§æ½¤ç§è¤è´ï§ééï§ï§ï§ï§è¿æççµ¨èï§å æ©ææ®·èª¾éé±ä¹åæ·«è­é°é³é£®ææ³£éåæèºé·¹ä¾ååå®ææ¿æ¬æ¤æ¯çç£ç¾©è¤èè»è¡£èª¼"
  ],
  [
    "eca1",
    "è­°é«äºä»¥ä¼ï§ï§å¤·å§¨ï§å·²å¼å½æ¡ï§ ï§¡ï§¢ï§£ç¾ç¥ï§¤ç°çï§¥ç§»ï§¦èè³èè¡èï§§ï§¨è²½è²³éï§©ï§ªé£´é¤ï§«ï§¬ç·çç¿ç¿ç¿¼è¬äººä»åå°ï§­å½å å§»å¯å¼å¿æ¹®ï§®ï§¯çµªèµï§°èèªï§±é­é·ï§²ï§³ä¸ä½ä½¾å£¹æ¥æº¢é¸é°é¦¹ä»»å£¬å¦å§æï§´ï§µç¨ï§¶èè³å¥å"
  ],
  [
    "eda1",
    "ï§·ï§¸ï§¹ä»å©å­è¿ä»åºå¨å§å§¿å­å­å­æ£ææ»çç®çç·çµç£ç´«èèªè¨èèè«®è³éä½åºå¼æ«æ¨ç¼ç¸çµç¶½èéééµ²å­±æ£§æ®æ½ºçå²æ«æ½ç®´ç°ªè ¶éä¸ä»å å ´å¢»å£¯å¥¬å°å¸³åºå¼µææ²ææ¨æª£æ¬æ¼¿çï§ºççç« ç²§è¸èè§èè¬è£èèè£è´é¬é·"
  ],
  [
    "eea1",
    "éååå¨å®°æææ ½æ¢æ¸½æ»ç½ç¸¡è£è²¡è¼é½é½ç­ç®è«éä½ä½å²åå§åºæµæµæ¥®æ¨æ²®æ¸ççªç½ç®¸ç´µè§è¹èè·è©è²¯èºéé¸éé½å£åå«¡å¯ææµæ»´çï§»çç©ç¬ç±ç¸¾ç¿è»è¬«è³èµ¤è·¡è¹è¿ªè¿¹é©éä½ä½ºå³å¨å¸ååªå¡¡å¡¼å¥ å°å±å»ææ°æ æ®¿æ°æ¾±"
  ],
  [
    "efa1",
    "çç ç°ç¸çç²ç­ç®ç®­ç¯çºè©®è¼¾è½é¿éé¢é«é»é¡é¡«é¤åæªææµç¤ç«ç¯çµ¶å å²¾åºæ¼¸ç¹ç²éé®é»æ¥æºè¶ä¸äºäº­ååµåå§å®å¹åº­å»·å¾ææºæ¿æ´ææ¶æ¸æ¾æ¥¨æªæ­£æ±æ·æ·¨æ¸æ¹çç¡çç½çºçç¢ç¦ç¨ç©½ç²¾ç¶èè¨è«ªè²é­ééé¦éé éé"
  ],
  [
    "f0a1",
    "éé é¼å¶åå¼å ¤å¸å¼æææ¢¯æ¿ç¥­ç¬¬èèºè£½è«¸è¹éé¤éé½é¡é½ä¿ååå©å²å¼å½«æªææ©ææºæ¹ææ¢æ£æ§½æ¼æ½®ç§ç¥çªçªçºç¥ç¥ç§ç¨ çªç²ç³çµç¹°èè»è¤è©èª¿è¶èºé é­é£é»éé³¥æç°è¶³éå­å°åæçå§å®å¾æ°æ«æ£æ·ç®ç¨®çµç¶ç¸±è«"
  ],
  [
    "f1a1",
    "è¸ªè¸µé¾éä½åå·¦åº§æ«ç½ªä¸»ä½ä¾åå§èåªå¨å¾å¥å®å·å»ææ±æ±æ ªæ³¨æ´²æ¹æ¾ç·ç çç±ç´ç´¬ç¶¢èèè¨»èªèµ°èºè¼³é±éééé§ç«¹ç²¥ä¿åååå¯¯å³»ææ¨½æµæºæ¿¬çç¯ç«£è ¢é¡éµéé§¿èä¸­ä»²è¡éå½æ«æ¥«æ±èºå¢ææ¾æ¯çççç¹è¸è­è´ä¹åª"
  ],
  [
    "f2a1",
    "å«å°åå¿æææ¯æ¯æ¨æºææ³æ­¢æ± æ²æ¼¬ç¥ç ¥ç¥ç¥ç´è¢èè³èè·èèªï§¼è´è¶¾é²ç´ç¨ç¨·ç¹è·ååå¡µæ¯æ¢æææ¡­æ¦æ®æ´¥æº±çç¨ç¡çç¹ç¡ççç§¦ç¸ç¸è»è¯è¢è¨ºè³è»«è¾°é²é­é£é³éä¾å±å§ªå«å¸æ¡çç¾ç§©çªè£è­è³ªè·è¿­ææï§½å·æ½ç·è¼¯"
  ],
  [
    "f3a1",
    "é¶éå¾µæ²æ¾ä¸ä¾ååååµ¯å·®æ¬¡æ­¤ç£ç®ï§¾è¹è»é®ææ¾ççªé¯é¿é½ªæ°æ¾¯ç¦ç¨çç«ç°çºç²²çºè®è´é½é¤é¥å¹å¯æ¦æ­ç´®å­åå¡¹æææºæ¬ç«è®è®åå¡åµå±å¨¼å» å½°æ´æææ¶æ¢æ§æ»æ¼²çç¡çªè¹èèè¼åµå°å¯å¯¨å½©æ¡ç ¦ç¶µèè¡ééµåæµç­"
  ],
  [
    "f4a1",
    "è²¬åå¦»æ½èåï§¿åå°ºæ½æææ²æ¥æ»ç èè¹ éé»ä»ååå¤©å·ææ³æ·ºçç©¿èè¦è³¤è¸é·é§é¡é¡éå¸å²åå¾¹æ¤æ¾ç¶´è¼è½éµåå°æ²¾æ·»çç»ç°½ç±¤è©¹è«å å¦¾å¸æ·ççç«è«è²¼è¼å»³æ´æ·¸è½èè«éé¯ï¨åæ¿æ¶æ»¯ç· è«¦é®éé«åå¿å¨ææææ¢¢"
  ],
  [
    "f5a1",
    "æ¤æ¥æ¨µçç¦ç¡ç¤ç¤ç§ç¨èè¸èèèè²è¶é¢éé®ä¿åç­çèè§¸å¯¸å¿æé¨å¢å¡å¯µæ¤ææ ç¸½è°è¥éæ®å¬å´æå¢æ½æ¨æ¤æ¥¸æ¨æ¹«çºç§è»è©è«è¶¨è¿½éééééééé¨¶é°ä¸çç¥ç«ºç­ç¯ç¸®èè¹è¹´è»¸éæ¥æ¤¿çåºæ®é»åå¿ æ²è²è¡è¡·æ´èµè"
  ],
  [
    "f6a1",
    "è´åå¹å´å¨¶å°±çç¿ èèè­è¶£éé©é·²å´ä»å æ»æ¸¬å±¤ä¾å¤å¤å³å¹æ¥æ¢æ²»æ·ç¾çç´ç¡ç¨ç©ç·ç·»ç½®è´è©è¼éé¦³é½ååé£­è¦ªä¸ææ¼ä¾µå¯¢ææ²æµ¸çç §éé¼èç§¤ç¨±å¿«ä»å¤å¾å¢®å¦¥æ°æææ¶æ¥èµéé¦±é§å¬ååå¼ï¨æï¨æ¢æ«ææ¿æ¿¯ç¢ç¸è¨"
  ],
  [
    "f7a1",
    "é¸ååå¦å½ææ­çç­ç¶»èªå¥ªè«æ¢çè½è²ªå¡æ­æ¦»å®å¸æ¹¯ï¨è©åå°å¤ªæ ææ®æ±°æ³°ç¬èèè·é°é¢±ï¨ææ¾¤ææåååè¨ææ¡¶ï¨çç­çµ±éå æ§è¿è¤ªéé ¹å¸å¥å¦¬æéé¬ªæç¹éå¡å©å·´ææ­æºæ·æ³¢æ´¾ç¬ç¶ç ´ç½·è­è·é å¤åæ¿çç£è²©è¾¦é"
  ],
  [
    "f8a1",
    "éªå«å­æä½©åæææ²æµ¿çç½ç¨è¦è²å½­æ¾ç¹è¨æä¾¿åæçç¯ç·¨ç¿©éé­é¨è²¶åªå¹³æ°èè©å å¬å¹£å»¢å¼æèºè½ééä½åååååºåå¸æææ±æï¨æ³¡æµ¦ç±ç ²èè¯èè¡è²è¢è¤ééªé£½é®å¹æ´æççï¨ä¿µå½å½ªæææ¨æ¼ç¢ç¥¨è¡¨è±¹é£é£é©"
  ],
  [
    "f9a1",
    "åç¨æ¥è«·è±é¢¨é¦®å½¼æ«ç²ç®è¢«é¿éå¹å¼¼å¿æ³çç¢çç­è¾é¦ä¹é¼ä¸ä½å¦å¤å»æ°æ²³çè·è¦è³ééé°å£å­¸èè¬é¶´å¯æ¨ææ±æ±æ¼¢æ¾£çç½ç¿°ééééå²è½å½å«å¸å£åæª»æ¶µç·è¦éé·é¹¹ååçè¤é¤ééäº¢ä¼å§®å«¦å··æææ­æ¡æ²æ¸¯ç¼¸èèª"
  ],
  [
    "faa1",
    "ï¨ï¨é äº¥åå³åå¥å­©å®³ææ¥·æµ·ç£è¹è§£è©²è«§éé§­éª¸å¾æ ¸åå¹¸æèè¡äº«åå®ç¦éé¿é¤é¥é¦åå¢èè¨±æ²æ«¶ç»è»æ­éªé©å¥çèµ«é©ä¿å³´å¼¦æ¸ææ³«ç«çç¹ç¾ç©ççµçµ¢ç¸£è·è¡ï¨è³¢éé¡¯å­ç©´è¡é å«ä¿ åå¤¾å³½æ¾æµ¹ç¹èèè¢éé °äº¨ååå"
  ],
  [
    "fba1",
    "å½¢æ³æ»ççç¯çç©ç©èè¢è¡¡éé¢é£é¦¨å®å½æ æ§æ³èè¹é¯éä¹äºå¼å£å£ºå¥½å²µå¼§æ¶æææ§æ¯«æµ©æ·æ¹æ»¸æ¾æ¿ æ¿©ççç¥çç çç¥ç³ç¸è¡è¦è«è¿èèè´è­·è±ªé¬é é¡¥ææé·å©ææ··æ¸¾ç¿é­å¿½æç¬åå¼æ±æ³æ´ªçç´è¹è¨é´»ååå¬æ¨ºç«çµ"
  ],
  [
    "fca1",
    "ç¦ç¦¾è±è¯è©±è­è²¨é´ï¨æ´æ«ç¢ºç¢»ç©«ä¸¸åå¥å®¦å¹»æ£ææ­¡æ¥æ¡æ¸ç¥ç°ç´éé©©é°¥æ´»æ»ç¾è±éå°å¹å¾¨ææ¶æ°ææææ¦¥æ³æ¹æ»æ½¢çççç¯ç°§èèééé»å¯åå»»å¾æ¢ææ·æ¦ææªæ·®æ¾®ç°çªç¹ªè¾è´èèª¨è³åç²å®æ©«éå®åå­ææææ¢æ¶æ·"
  ],
  [
    "fda1",
    "ç»è´éµé©ä¾¯åååå¼ååå¸¿å¾æ½ç¦çéåå³å¡¤å£ççç»è°è¨æè¨å§æçè±ååæ¯å½å¾½æ®æçè«±è¼éº¾ä¼æºçç¦è§æ¤è­é·¸åå¶åæ´¶è¸é»ææ¬£ççåå±¹ç´è¨æ¬ æ¬½æ­å¸æ°æ´½ç¿èåååå«åå§¬å¬å¸æææ±ææ¦çç¹çºç§ç¦§ç¨ç¾²è©°"
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    "ãï¼ããï¼â§ï¼ï¼ï¼ï¼ï¸°â¦â¥ï¹ï¹ï¹Â·ï¹ï¹ï¹ï¹ï½âï¸±âï¸³â´ï¸´ï¹ï¼ï¼ï¸µï¸¶ï½ï½ï¸·ï¸¸ããï¸¹ï¸ºããï¸»ï¸¼ããï¸½ï¸¾ããï¸¿ï¹ããï¹ï¹ããï¹ï¹ï¹ï¹"
  ],
  [
    "a1a1",
    "ï¹ï¹ï¹ï¹ââââããâµâ²ï¼ï¼ï¼â»Â§ãâââ³â²ââââââ¡â â½â¼ã£âÂ¯ï¿£ï¼¿Ëï¹ï¹ï¹ï¹ï¹ï¹ï¹ï¹ ï¹¡ï¼ï¼ÃÃ·Â±âï¼ï¼ï¼â¦â§â âââ¡ï¹¢",
    4,
    "ï½â©âªâ¥â ââ¿ããâ«â®âµâ´âââââââââââââ¥â£ï¼"
  ],
  [
    "a240",
    "ï¼¼âï¹¨ï¼ï¿¥ãï¿ ï¿¡ï¼ï¼ ââï¹©ï¹ªï¹«ãããããã¡ãããÂ°ååååå¡å£å§ç©ç³â",
    7,
    "ââââââââ¼â´â¬â¤ââââââââââ­"
  ],
  [
    "a2a1",
    "â®â°â¯âââªâ¡â¢â£â¥â¤â±â²â³ï¼",
    9,
    "â ",
    9,
    "ã¡",
    8,
    "åååï¼¡",
    25,
    "ï½",
    21
  ],
  [
    "a340",
    "ï½ï½ï½ï½Î",
    16,
    "Î£",
    6,
    "Î±",
    16,
    "Ï",
    6,
    "ã",
    10
  ],
  [
    "a3a1",
    "ã",
    25,
    "ËËËËË"
  ],
  [
    "a3e1",
    "â¬"
  ],
  [
    "a440",
    "ä¸ä¹ä¸ä¸ä¹ä¹äºäºäººå¿å¥å«å åååååååä¸ä¸ä¸ä¸ä¸«ä¸¸å¡ä¹ä¹ä¹ä¹äºäº¡åååºååå£åå£«å¤å¤§å¥³å­å­å­å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼å¼æ"
  ],
  [
    "a4a1",
    "ä¸ä¸ä¸ä¸­ä¸°ä¸¹ä¹å°¹äºäºäºäºäºäº¢ä»ä»ä»ä»ä»ä»ä»ä»ä»ååå§å­å®å¬åå¶åååå»å¾å¿åå¹ååååååååå£¬å¤©å¤«å¤ªå¤­å­å°å°¤å°ºå±¯å·´å¹»å»¿å¼å¼å¿ææ¶æææ¯æææ¤æ¹æ¥æ°ææ¨æ¬ æ­¢æ­¹æ¯æ¯æ¯æ°æ°´ç«çªç¶ç»çççç¬çä¸"
  ],
  [
    "a540",
    "ä¸ä¸ä¸ä¸ä¸»ä¹ä¹ä¹ä»¥ä»ä»ä»ä»ä»ä»£ä»¤ä»ä»ååååå¬å¹åºå¸åå åååååä»ååå¡å å¯å®å»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»ååå¤"
  ],
  [
    "a5a1",
    "å¤®å¤±å¥´å¥¶å­å®å°¼å·¨å·§å·¦å¸å¸å¹³å¹¼å¼å¼å¼å¿ææææææ¥æ¦æ®æ¬æªæ«æ­æ­£æ¯æ°æ°æ°¸æ±æ±æ°¾ç¯çççç¦ççç¨ç©ç°ç±ç²ç³çç½ç®ç¿ç®çç¢ç³ç¤ºç¦¾ç©´ç«ä¸ä¸ä¹ä¹ä¹©äºäº¤äº¦äº¥ä»¿ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼ååååå¨"
  ],
  [
    "a640",
    "å±åå°åååååå£åå¡å å°å±åååååååååååååååå ååå³å°å¨å­å¬å¯å©å¤å¤å¤·å¤¸å¦å¥¸å¦å¥½å¥¹å¦å¦å­å­å®å®å®å®å¯ºå°å±¹å·å¸å¹¶å¹´"
  ],
  [
    "a6a1",
    "å¼å¼å¿å¿æææææ£æææ¶æ©æ¨æ¬æ­æ²æ³ææ½æ´æ±æµæ¬¡æ­¤æ­»æ°æ±æ±æ±æ±æ± æ±æ±æ±¡æ±æ±æ±ç°ççç¾ç«¹ç±³ç³¸ç¼¶ç¾ç¾½èèèèè³è¿èèèè£èªè³è¼èèèè®è²è¾è«è¡è¡è¡£è¥¿é¡ä¸²äº¨ä½ä½ä½ä½ä½ä¼´ä½ä½ä¼°ä½ä½ä¼½ä¼ºä¼¸ä½ä½ä¼¼ä½ä½£"
  ],
  [
    "a740",
    "ä½ä½ ä¼¯ä½ä¼¶ä½ä½ä½ä½ååååµå¶å·å¥å¤å©åªå¨å«å©åªå¬å£å³åµåå­åå¾å¦åå§ååå³åååå©åå¹å»å¸å®åµå¶å å¼åå±å«åå¬åªå°å¤å«åååå"
  ],
  [
    "a7a1",
    "ååå¾ååå»å£¯å¤¾å¦å¦å¦¨å¦å¦£å¦å¦å¦å¦¤å¦å¦å¦¥å­å­å­å­å®å®å®å°¬å±å±å°¿å°¾å²å²å²å²å·«å¸åºåºåºå»·å¼å¼å½¤å½¢å½·å½¹å¿å¿å¿å¿å¿±å¿«å¿¸å¿ªæææææææ¶ææ­ææ¼æ¾æ¹æ³ææ¯ææ®æææææ¹æ»æ¸æ±æ´æææææææææææ "
  ],
  [
    "a840",
    "æææ­¥æ¯æ±æ±æ²æ²æ²æ²æ²æ²æ±ªæ±ºæ²æ±°æ²æ±¨æ²æ²æ±½æ²æ±²æ±¾æ±´æ²æ±¶æ²æ²æ²æ²ç¶ç¼ç½ç¸ç¢ç¡ç çççç¬ç«ç·ç¸çç¯ç£ç§ç§ç¦¿ç©¶ç³»ç½èèèèèèè²è¯è"
  ],
  [
    "a8a1",
    "èèè¦è§è¨è°·è±è±è²èµ¤èµ°è¶³èº«è»è¾è¾°è¿è¿è¿è¿å·¡éé¢éªé¦é£éééé²é®é±éªé¬ä¸¦ä¹ä¹³äºäºäºäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾ä¾ä¾ä¾ä½°ä½µä¾ä½©ä½»ä¾ä½¾ä¾ä¾ä½ºåååå©å·å¶å¸å½å½å»å¸å·åºå°å®å¶åå¾å»ååååå¦å·å¸å¹åååå³åµ"
  ],
  [
    "a940",
    "åå¸ååå»å·åååå¼åå±å¶ååå¢å¨åå½ååºåå·åªå©å¡å¦å¤å¼å¤å¥å¥å¥å¥å¥å¦¾å¦»å§å¦¹å¦®å§å§å§å§å§å§å§å¦¯å¦³å§å§å­å­¤å­£å®å®å®å®å®å®å°å±å±"
  ],
  [
    "a9a1",
    "å±å²·å²¡å²¸å²©å²«å²±å²³å¸å¸å¸å¸å¸å¸å¹¸åºåºåºåºåºå»¶å¼¦å¼§å¼©å¾å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æææ¯æµææªææ¡æ§æ©æ«ææææ¿æ¾ææ¿ææææ¿ææ¹æææ«æææææ¨æ½æ¼æææææµææ±æææææ¬ææ¾æ§æ¼æºææææææææææ"
  ],
  [
    "aa40",
    "ææææ­æææ±ææ³æ·ææææ¯æ°æ¿ææ¾ææµæææ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°æ°æ³£æ³¨æ³³æ²±æ³æ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³æ³æ²¸æ³æ²¹æ³æ²®æ³æ³æ³±æ²¿æ²»æ³¡æ³æ³æ²¬æ³¯æ³æ³æ³ "
  ],
  [
    "aaa1",
    "çççççç¬ç­ç¸çç§ç©çççççç©ç¨çç«ç¥ç½çççççç²ç´ç¥ç½ç¤¾ç¥ç¥ç§ç§ç©ºç©¹ç«ºç³¾ç½ç¾ç¾èèºè¥è¢è±è¡è«è©è´èªè¯è¥è¾èè³èèè­è½èè¹è±è¬è¥è¯è¸è£è°è¾è·èè±åè¡¨è»è¿è¿è¿éµé¸é±é¶ééé·éééé¿é»é"
  ],
  [
    "ab40",
    "éé¹é¨ééäºäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿ä¿ä¿ä¿ä¾¶ä¿ä¿ä¿ä¿ä¾®ä¿ä¿ä¿ä¿ä¿ä¿ä¾·åååå åååååååååååååå»ååå¬åå¨ååå¸å¦å³ååå½åªå"
  ],
  [
    "aba1",
    "ååå¯å«å±å»å©å§å¿å¿ååå å£å¢åå®åå¥å¥å¥å¥å¥å§å§å§¿å§£å§¨å¨å§¥å§ªå§å§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±å±å±å±å³å³å··å¸å¸¥å¸å¹½åº åº¦å»ºå¼å¼­å½¥å¾å¾å¾å¾å¾å¾å¾æææ æ¥ææ¨ææ°æ¨æ¢æææ¬æ«æªæ¤æææææ¼æ­ææ®æ½ææ±æ·"
  ],
  [
    "ac40",
    "æ¯æ¬æ¾æ´æææ¿ææ«æ½æ¢æ¥æ­æ æ§æ¯ææ¨æ±æ¤æ·æ¿ææ±æææ¬æ¶æ¯æµæ©æ¯æææ´ææ¥æ¸æææ³æ°ææ¢æææ­ªæ®æ®æ®µæ¯æ¯æ°æ³æ´æ´²æ´ªæµæ´¥æ´æ´±æ´æ´"
  ],
  [
    "aca1",
    "æ´»æ´½æ´¾æ´¶æ´æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´æ´«ç«çºç³ç¬ç¯ç­ç¸ç®ç¤ç°ç²ç¯ç´ç©ç ç¡ç·çç»ç²ççç³çç­ççççç«ç¤ç¥ç¢ç£ç¸ççççççççç¹ç¸ççç¾ç¼ççç ç ç ç ç¥ç¥ç¥ç¥ç¦¹ç¦ºç§ç§ç§ç©¿çªç«¿ç«½ç±½ç´ç´ç´ç´ç´ç´ç´ç¼¸ç¾ç¾¿è"
  ],
  [
    "ad40",
    "èèèè¶èè¥èèèèè¡èèèè¤èè´è¢è§èèè£èè¦èè¥èèèèè±èèèèèèèè¯èèè¹è»èºè¡è¡«è¦è§è¨è¨è¨è²è² èµ´èµ³è¶´è»è»è¿°è¿¦è¿¢è¿ªè¿¥"
  ],
  [
    "ada1",
    "è¿­è¿«è¿¤è¿¨ééééééééééééé¢é©éé­é³é é¢¨é£é£é¦é¦ä¹äº³ååå£ä¿¯å¦å¥ä¿¸å©ååå¼ååååä¿ºååå¨ä¿±å¡åååä¿³ä¿®å­åªä¿¾å«åå¼å¤å¥å¢ååååååååååªå¿åååå¨ååå·å¼å¥å²ååºåå©å­å¡åå®åª"
  ],
  [
    "ae40",
    "å¦å§åå½åååååååå å¤å¥å¥å¥å¨å¨å¨å¨å¨å¨å§¬å¨ å¨£å¨©å¨¥å¨å¨å­«å±å®°å®³å®¶å®´å®®å®µå®¹å®¸å°å±å±å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾å¾å¾æ"
  ],
  [
    "aea1",
    "æ£æ¥æææ­æ©æ¯ææææææææææ³ææ¿ææ¾æ¯ææææææºææ½æªæ«æ¨ææææææææææææææææ¸ææææ ¡æ ¸æ¡æ¡æ¡æ ¹æ¡æ¡æ ©æ¢³æ æ¡æ¡æ ½æ´æ¡æ¡æ ¼æ¡æ ªæ¡æ æ æ¡æ®æ®æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶æ¶æ¶æµ¦æµ¸æµ·æµæ¶"
  ],
  [
    "af40",
    "æµ¬æ¶æµ®æµæµ´æµ©æ¶æ¶æµ¹æ¶æµ¥æ¶ççç¤çççç¹ç¹ç¼ç¹ç½ç¸ç·çç­çç®ç çªççççççç¾ççç²ç³ç½ç¼ç¹çç¸çç°çççç©çç ç¨ç©ç °ç §ç ¸ç ç ´ç ·"
  ],
  [
    "afa1",
    "ç ¥ç ­ç  ç ç ²ç¥ç¥ç¥ ç¥ç¥ç¥ç¥ç¥ç¥ç§¤ç§£ç§§ç§ç§¦ç§©ç§çªçªç«ç¬ç¬ç²ç´¡ç´ç´ç´ç´ ç´¢ç´ç´ç´ç´ç´ç´ç´ç´ç¼ºç½ç¾ç¿ç¿èèèèèè½è¿è±èè°èè­è´èè¸è³èè½èè¼è¯è­è¬èèèªè«è¨è¬è»è«èèèè¸èèèµè´èè²è¹è¶èèè±è¨è"
  ],
  [
    "b040",
    "èèèªèè¤è©èè£èè¡°è¡·è¢è¢è¡½è¡¹è¨è¨è¨è¨è¨è¨è¨è¨è¨è¨è¨è±è±ºè±¹è²¡è²¢èµ·èº¬è»è»è»è¾±ééè¿·éè¿ºè¿´éè¿½éè¿¸éé¡éé¢éééééééééé¢é£é¡"
  ],
  [
    "b0a1",
    "ééé¤ééé»é£¢é¦¬éª¨é«é¬¥é¬²é¬¼ä¹¾åºå½ååååååå¥å¶åååµå´å·ååå¯å­ååå°åªå¯åååååååå¿åå¾åæ¼ååªå¦ååå¡ååå±åååå¯å¤å¸å®åå¬å£å³ååååååå å å å å¤åºå å µå·å¹å¤ å¥¢å¨¶å©å©å©¦å©ªå©"
  ],
  [
    "b140",
    "å¨¼å©¢å©å©å©å­°å¯å¯å¯å¯å®¿å¯å°å°å°å± å±å±å´å´å´å´å´å´¢å´å´©å´å´å´¤å´§å´å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½å½¬å½©å½«å¾å¾å¾å¾å¾¡å¾ å¾æ¿æ£ææ æ¨ææ´æ¦æ½"
  ],
  [
    "b1a1",
    "ææ»æµææ¼æææææ¸ææææææ æ§æ²ææ¢æ¥æ·æ§ææªæ±æ©ææææ«æ¨ææææ¡æ¬ææææ»æ©æ¨æºæææææåæææææææ¬æææææææ¤æ¨æ¦ææ¹åææ¢æ¢¯æ¢¢æ¢æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢æ¢°æ¢æ£æ¢­æ¢æ¢æ¢æ¢æ¢¨æ¢æ¢¡æ¢æ¬²æ®º"
  ],
  [
    "b240",
    "æ¯«æ¯¬æ°«æ¶æ¶¼æ·³æ·æ¶²æ·¡æ·æ·¤æ·»æ·ºæ¸æ·æ·æ¶¯æ·æ¶®æ·æ·¹æ¶¸æ··æ·µæ·æ·æ¸æ¶µæ·æ·«æ·æ·ªæ·±æ·®æ·¨æ·æ·æ¶ªæ·¬æ¶¿æ·¦ç¹ççç½ç¯ç½ç½çççççççççççç¾çç ç¶"
  ],
  [
    "b2a1",
    "ç·çç¢ç¥ç¦ç¢ç°ççççµççççççç·ç¾ç¼ç¶ç¸çºç¡«ç¡ç¡ç¥¥ç¥¨ç¥­ç§»çªçªç¬ ç¬¨ç¬ç¬¬ç¬¦ç¬ç¬ç¬®ç²ç²ç²çµçµçµ±ç´®ç´¹ç´¼çµç´°ç´³çµç´¯çµç´²ç´±ç¼½ç¾ç¾ç¿ç¿ç¿èèèè¯èè£è«è©è°è¤èèµè·è¶è¹èèèè¸è¢èè½è«èèèèè è·è»è¼"
  ],
  [
    "b340",
    "èè§èå½ªèèè¶èèµèèè±è¯èè¡è¢è¢è¢«è¢è¢è¢è¢è¦è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨è¨è¨¢è±è±è²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»è»ééééé£éééééé éé¢ééé"
  ],
  [
    "b3a1",
    "é¨é­é½éééµé¦é£é§é­é©ééªéµé³é¸é°é´é¶é·é¬ééªé©ç« ç«é é é­é³¥é¹µé¹¿éº¥éº»å¢ååååååååæå±å²å´åµå©ååååå¥å»åå§å¼ååååååªååååå³å®åå¾å²åå»å¬å±å¾åå«ååå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "
  ],
  [
    "b440",
    "å©·åªå©¿åªåªåª§å­³å­±å¯å¯å¯å¯å°å°å°±åµåµå´´åµå·½å¹å¸½å¹å¹å¹¾å»å»å»å»å¼¼å½­å¾©å¾ªå¾¨ææ¡æ²æ¶æ ææ£æºææ°æ»æ´æ¨æ±ææ¶ææææææ£ææææ©æææ"
  ],
  [
    "b4a1",
    "ææ£ææ¡ææ­æ®æ¶æ´æªææææ¹ææ¦æ¢æ£æææ¯æ®æ°æ´æ¶æ¯ææºæ¾æ·æ¾æ¿æææ£ºæ£æ£ æ£æ£æ¤æ£æ£µæ£®æ£§æ£¹æ£æ£²æ££æ£æ£æ¤æ¤æ¤æ£æ£æ¥®æ£»æ¬¾æ¬ºæ¬½æ®æ®æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹æ¸¡æ¸²æ¹§æ¹æ¸ æ¸¥æ¸£æ¸æ¹æ¹æ¸¤æ¹æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹æ¸æ¸¾æ»"
  ],
  [
    "b540",
    "æºæ¸æ¹æ¹£æ¹æ¹²æ¹©æ¹ççç¦ç°ç¡ç¶ç®ççççç¶ç¥ç´ç©çºçªç³ç¢ç¥çµç¶ç´ç¯çç¦ç¨ç¥ç¦ç«çªç¢çç£çççç ç»ç¼ççç´ççç­ç¡ç¡¬ç¡¯ç¨ç¨ç¨ç¨ç¨çª"
  ],
  [
    "b5a1",
    "çªçªç«¥ç«£ç­ç­ç­ç­ç­ç­ç­ç­ç­ç­ç²ç²¥çµçµçµ¨çµç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³åç¿ç¿èèèèèèèèè¹èè¾èèè´èèè©èè¸èè èèèè¯è±è´èèè°èèè½è²èè¸èèèèèèèèèè­èèè¤èèè¡è£è£è¢±è¦è¦è¨»è© è©è©è¨¼è©"
  ],
  [
    "b640",
    "è©è©è©è©è¨´è¨ºè¨¶è©è±¡è²è²¯è²¼è²³è²½è³è²»è³è²´è²·è²¶è²¿è²¸è¶è¶è¶è·è·è·è·è·è·è·è·è»»è»¸è»¼è¾é®éµé±é¸é²é¶ééµéé¾é£é¥éééé£éééééééééé"
  ],
  [
    "b6a1",
    "ééééééé½éééé²ééééééé¯é²éé é é é£§é£ªé£¯é£©é£²é£­é¦®é¦­é»é»é»äºå­åµå²å³åå¾å¬å·å»å¯åå¿å·å½åå¦å¤å¢å£å¯åå¨åå¦ååååå£å¤å¯åå¡ååå¥åååå¡å¡å¡å¡å¡å¡å¡«å¡å¡­å¡å¡¢å¡å¡å¥§å«å«å«åª¾åª½åª¼"
  ],
  [
    "b740",
    "åª³å«åª²åµ©åµ¯å¹å¹¹å»å»å¼å½å¾¬å¾®æææææ³ææ¹æææææææ¾æ´æ§æææ·æ¡æ¢ææ¾ææªæ­æ½æ¬æææææ¶ææææ¬ææ°ææææææææææ¦æ¥­"
  ],
  [
    "b7a1",
    "æ¥æ¥·æ¥ æ¥æ¥µæ¤°æ¦æ¥æ¥¨æ¥«æ¥æ¥æ¥¹æ¦æ¥æ¥£æ¥æ­æ­²æ¯æ®¿æ¯æ¯½æº¢æº¯æ»æº¶æ»æºæºæ»æ»æº¥æºæº¼æººæº«æ»æºæºæ»æ»æºªæº§æº´ççç©ç¤çç§çç¬ç¦çç¥ççç¨ççºçç·çç¿ç¾ç¯çççççç¿çççç¶ç¸çç°çç²ç±çºç¿ç´ç³çççç«ç¦çç£"
  ],
  [
    "b840",
    "ç¹çªç¬çç¥ç¨ç¢ç®ç¢ç¢°ç¢ç¢ç¢ç¢ç¡¼ç¢ç¢ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨ç¨ç¨ ç¨ç¨ç¨çªçª ç­·ç¯ç­ ç­®ç­§ç²±ç²³ç²µç¶çµ¹ç¶ç¶ç¶çµç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤èèèèè±è°è¸è¥è®è³è«"
  ],
  [
    "b8a1",
    "è¹èºè¦èèèè·è½è±èµè¦è«èè¬èè¼èµè¡è£è©è­èèèèè¹èèèèè¾è»èèèèè¡è£è£è£è£è£è£è£¡è£è£è£è¦è§£è©«è©²è©³è©¦è©©è©°èªè©¼è©£èª è©±èªè©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²è²è³è³è³è³è²²è³è³è³è·¡è·è·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼è¼è»¾è¼"
  ],
  [
    "b940",
    "è¾è¾²éééééé¼éééééééé¾éééé¬éªé©éé·éé¸é½éé¾ééé¤éé´éééé¹é¿éééééééééé·é»é¹é¶éé´é¶é é é é é é é£¼é£´"
  ],
  [
    "b9a1",
    "é£½é£¾é¦³é¦±é¦´é«¡é³©éºé¼é¼é¼ å§å®å¥åå­ååååå±åå©å¢å³ååå±å­å¾åååå½åååååå·ååååå¶ååå¡µå¡¾å¢å¢å¢å¡¹å¢å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«å«å«å«£å­µå¯å¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯å°å±¢å¶å¶å¹å¹£å¹å¹å¹å»å»å¼å½å½°å¾¹æ"
  ],
  [
    "ba40",
    "æ¿ææ·æ¢æ£ææææµæªææææ¤æ¸ææºææ§æ´æ­æ»æ²æ¡æææ¢æ¨ææ¦æ¦¨æ¦æ§æ¦®æ§æ§æ¦æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§æ¦¦æ§æ¦£æ­æ­æ°³æ¼³æ¼æ»¾æ¼æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼æ¼¢"
  ],
  [
    "baa1",
    "æ»¿æ»¯æ¼æ¼±æ¼¸æ¼²æ¼£æ¼æ¼«æ¼¯æ¾æ¼ªæ»¬æ¼æ»²æ»æ»·ççç½çççç¾ççççç¤ç£çªç°ç­ççç§ççççç¡ç£çç½ç¿ç¡ç£ç¢ç¢§ç¢³ç¢©ç¢£ç¦ç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®ç®ç­µç®ç®ç®ç®ç®¸ç®ç®ç²¹ç²½ç²¾ç¶»ç¶°ç¶ç¶½ç¶¾ç¶ ç·ç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·ç·ç¶¬"
  ],
  [
    "bb40",
    "ç½°ç¿ ç¿¡ç¿èèèèèèèèè¿èè§èºèèèèèè¿èèèèè²èèè¸èèèè¼èèè¿èè»è¢è¥è´èèè·è©è£³è¤è£´è£¹è£¸è£½è£¨è¤è£¯èª¦èªèªèª£èªèª¡èªèª¤"
  ],
  [
    "bba1",
    "èªªèª¥èª¨èªèªèªèª§è±ªè²è²è³è³è³èµ«è¶è¶è·¼è¼è¼è¼è¼è¾£é ééé£ééé¢ééééééµé¸é·é´é¸ééééé»ééé¨é¼éé¡é¨é©é£é¥é¤ééééééé¼éé¶é é é¢¯é¢±é¤é¤é¤é¤é§éª¯éª°é«¦é­é­é³´é³¶é³³éº¼é¼»é½ååå»åµå¹ååååå"
  ],
  [
    "bc40",
    "åååååå°å²å®å»å¹å²å¿å´å©åååå´å¶å¯å°å¢å¢å¢å¢³å¢å¢®å¢©å¢¦å¥­å¬å«»å¬å«µå¬å¬å¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶å¹¢å¹å¹¡å»¢å»å»å»å»£å» å½å½±å¾·å¾µæ¶æ§æ®æææ"
  ],
  [
    "bca1",
    "æ¼æ°æ«æ¾æ§ææ«ææ¬ææ¤ææ®æ®æ©æ¯æ¹ææ²æææ°æ¥æææ©ææ®æ­æ«ææ¬ææ¢æ³æµæ·æ¸æ®æ«æ´æ±æ¨£æ¨æ§¨æ¨æ¨æ¨æ§½æ¨¡æ¨æ¨æ§³æ¨æ¨æ§­æ¨æ­æ­æ®¤æ¯æ¯æ¼¿æ½¼æ¾æ½æ½¦æ½æ¾æ½­æ½æ½¸æ½®æ¾æ½ºæ½°æ½¤æ¾æ½æ»æ½¯æ½ æ½çç¬ç±ç¨ççççç©çç"
  ],
  [
    "bd40",
    "ç¾çç¿ç ç©çç¤ç¦ç¡ç¢ççºç¤çççççç£ç£ç¢ºç£ç¢¾ç£ç¢¼ç£ç¨¿ç¨¼ç©ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯ç®´ç¯ç¯ç¯ç® ç¯ç³ç· ç·´ç·¯ç·»ç·ç·¬ç·ç·¨ç·£ç·ç·ç·©ç¶ç·ç·²ç·¹ç½µç½·ç¾¯"
  ],
  [
    "bda1",
    "ç¿©è¦èèèè èèèè½èè®è¬è­èèè£è¡èè¬è¥è¿èèè´è¶è è¦è¸è¨èèèèè¡è¡è¤è¤è¤è¤è¤è¤èª¼è«è«è«èªè«è«¸èª²è«è«èª¿èª°è«è«èª¶èª¹è«è±è±è±¬è³ è³è³¦è³¤è³¬è³­è³¢è³£è³è³ªè³¡èµ­è¶è¶£è¸«è¸è¸è¸¢è¸è¸©è¸è¸¡è¸èººè¼è¼è¼è¼©è¼¦è¼ªè¼è¼"
  ],
  [
    "be40",
    "è¼¥é©é®é¨é­é·é°é­é§é±éééééé»é·éªé¬é¤éé³é¼ééé°é²é­é±ééééé éééé ¡é «é é¢³é¤é¤é¤é¤é§é§é§é§é§é§é§é§éª·é«®é«¯é¬§é­é­é­·é­¯é´é´"
  ],
  [
    "bea1",
    "é´éº©éº¾é»å¢¨é½åååååååªåååå³åå«å¹å©å¤å¸åªå¨å¥å±å¯å¬å¢å¶å£å¢¾å£å£å¥®å¬å¬´å­¸å¯°å°å½æ²ææ©æææ¶æ¾æææ°ææææ»æ¼ææææææ¿æææ¾æ´æææ¹æææ¸æ¨½æ¨¸æ¨ºæ©æ©«æ©æ¨¹æ©æ©¢æ©¡æ©æ©æ¨µæ©æ©æ­æ­·æ°æ¿æ¾±æ¾¡"
  ],
  [
    "bf40",
    "æ¿æ¾¤æ¿æ¾§æ¾³æ¿æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç¾çççççç¹çççççç¨çç£çççç¢ççç´ç¸çºç§ç¥ç ççç¥ç£¨ç£ç£¬ç£§ç¦¦ç©ç©ç©ç©ç©çªºç¯ç°ç¯ç¯¤ç¯ç¯¡ç¯©ç¯¦ç³ç³ç¸"
  ],
  [
    "bfa1",
    "ç¸ç¸ç¸ç¸£ç¸ç¸ç¸ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è¨è³è©è¨è»èèèèèèè¨è©èèè­èªèèèèè¢èè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬è«è«§è«®è«¾è¬è¬è«·è«­è«³è«¶è«¼è±«è±­è²è³´è¹è¸±è¸´è¹è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé´éé é¶é¸é³é¯é¢é¼é«éé"
  ],
  [
    "c040",
    "éé¦é¡éé®éé»é§é¨éªéééééééééé¦éé °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤é¤é¤¡é¤é§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®é´é´£é´¦é´¨é´é´é»é»é¾é¾åªåå¡å²åµååååå"
  ],
  [
    "c0a1",
    "åå£å£å£å£å¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½å¾½ææææ¦ææ²æ´ææææ æ°æ¦æ¬æ±æ¢æ­æææææªæªæªæª¢æªæ«æª£æ©¾æªæªæª æ­æ®®æ¯æ°æ¿æ¿±æ¿æ¿ æ¿æ¿¤æ¿«æ¿¯æ¾æ¿¬æ¿¡æ¿©æ¿æ¿®æ¿°ç§çç®ç¦ç¥ç­ç¬ç´ç çµçç°ç²ç©ç°ç¦ç¨ççççªç³çªç°ç¬"
  ],
  [
    "c140",
    "ç§ç­ç¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©çª¿ç°ç°ç¯¾ç¯·ç°ç¯ ç³ ç³ç³ç³¢ç³ç³ç³ç¸®ç¸¾ç¹ç¸·ç¸²ç¹ç¸«ç¸½ç¸±ç¹ç¹ç¸´ç¸¹ç¹ç¸µç¸¿ç¸¯ç½ç¿³ç¿¼è±è²è°è¯è³èèèºèèè¿è½èè¾è¨èè±èª"
  ],
  [
    "c1a1",
    "èè¾èèèè¯èèè¨èè§èèè³èèè«è»èºèèè¤»è¤¶è¥è¤¸è¤½è¦¬è¬è¬è¬è¬è¬è¬ è¬è¬è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹è¹è¹è¹è½è¼¾è½è½è¼¿é¿é½ééééé¹é£ééééé¨éµéé¥ééé¾é¬éé°éééééééé±é¸éééé éé¡é¢¶é¤µé¨"
  ],
  [
    "c240",
    "é§¿é®®é®«é®ªé®­é´»é´¿éºé»é»é»é»é»é¼¾é½å¢åå®å£å£å¬¸å½æ£æ³æ´æ²æ¾ææºæ»æ·æ·ææ¦æª³æª¬æ«æª»æª¸æ«æª®æª¯æ­æ­¸æ®¯ççæ¿¾çæ¿ºççç»ç¼ç¾ç¸ç·çµç§ç¿ççç"
  ],
  [
    "c2a1",
    "çç½ç¿ç»ç¼ç¤ç¦®ç©¡ç©¢ç© ç«ç«ç°«ç°§ç°ªç°ç°£ç°¡ç³§ç¹ç¹ç¹ç¹ç¹¡ç¹ç¹ç½ç¿¹ç¿»è·è¶èèèèè©èèèè°èºè¹è¦è¯è¬è²è è¦è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´è¹è¹£è¹¦è¹¤è¹è¹è»è½è½éééé«é¬ééééé¢é³é®é¬é°éééééééé¢ééééé¤é£é¦"
  ],
  [
    "c340",
    "é­é¹é¡é¡é¡é¡é¡é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨é«é¬é¬é­é­é­é¯é¯é¯½é¯é¯éµéµéµ é» é¼é¼¬å³å¥å£å£å£¢å¯µé¾å»¬æ²æ·æ¶æµæææ ææ«¥æ«æ«æ«ççç¨çççççççç¢ç¸"
  ],
  [
    "c3a1",
    "çºç½çç£çççç¡çç¤ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾ç¹³ç¾¶ç¾¹ç¾¸èè©èèªèè¤è¥è·è»è è è¹è¾è¥ è¥è¥è¥è­è­è­è­è­è­è­è­è­è´è´è¹¼è¹²èºè¹¶è¹¬è¹ºè¹´è½è½è¾­ééé±é®é¡éééééééé¢ééé¤éé¨éé´é£éªé§é¡éé»é¡"
  ],
  [
    "c440",
    "é¡é¡é¢¼é¥é¥é¨é¨é¬é¯¨é¯§é¯é¯é¶éµ¡éµ²éµªéµ¬éºéºéºéº´å¸å¨å·å¶å´å¼å£¤å­å­å­½å¯¶å·æ¸æºææææ¦æ§æ«¬ç¾ç°ç²çç»çç¢ç¥ç¤¦ç¤ªç¤¬ç¤«ç«ç«¶ç±ç±ç±ç³¯ç³°è¾®ç¹½ç¹¼"
  ],
  [
    "c4a1",
    "çºç½èèè¦è»è¹èèºèèèèè è è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­è­«è´è´èºèºèºèºé´éééé½é¡é°é£é¥é¥é¦¨é¨«é¨°é¨·é¨µé°é°é¹¹éºµé»¨é¼¯é½é½£é½¡å·å¸åååå¤å±¬å·æ¼æ¾ææææ©æ«»æ¬æ«ºæ®²ççç§ççç©çç±çºçºç¾¼èè­èè £è ¢è ¡è è¥ªè¥¬è¦½è­´"
  ],
  [
    "c540",
    "è­·è­½è´èºèºèºè½è¾¯éºé®é³éµéºé¸é²é«é¢é¸é¹é²é¿é¡§é¡¥é¥é©é©é©é¨¾é«é­é­é°­é°¥é¶¯é¶´é·é¶¸éºé»¯é¼é½é½¦é½§å¼å»åååå­¿å·å·å½æ¿æ¤æ¬æ­¡çççç¤çç®ç¬"
  ],
  [
    "c5a1",
    "ç¦³ç± ç±è¾è½èè¥²è¥¯è§¼è®è´è´èºèºè½¡ééééé½é¾ééé¡«é¥é©é©é«é¬é±é°±é°¾é°»é·é·é¼´é½¬é½ªé¾åå·ææ£æ«æªæ¬æ¬çç«ç±¤ç±£ç±¥çºçºçºè¢è¸è¿è ±è®ééé£é é¤é¨é¡¯é¥é©é©é©é«é«é«é±é±é±é·¥éºé»´åå£©æ¬çç±ç²çç½ç¾è ¶è ¹è¡¢è®è®"
  ],
  [
    "c640",
    "è®è·è´ééªééééé¡°é©é¬¢é­é±é·¹é·ºé¹¼é¹½é¼é½·é½²å»³æ¬ç£ç±¬ç±®è »è§èº¡éé²é°é¡±é¥é«é¬£é»ç¤çè®é·éé©¢é©¥çºè®èºªéé½é¾é¼é±·é±¸é»·è±é¿é¸ç¨é©ªé¬±é¸é¸ç±²"
  ],
  [
    "c940",
    "ä¹ä¹åµååä¸ä¸ä¹äºåï¨å±®å½³ä¸åä¸ä¸®äºä»ä»ä»åå¼å¬å¹å å¤å¤¬å°å·¿æ¡æ®³æ¯æ°ç¿ä¸±ä¸¼ä»¨ä»ä»©ä»¡ä»ä»åååå¢å£å¤å¤¯å®å®å°å°»å±´å±³å¸åºåºå¿æææ°"
  ],
  [
    "c9a1",
    "æ°¶æ±æ°¿æ°»ç®ç°çç¦¸èéä¼ä¼ä¼¬ä»µä¼ä»±ä¼ä»·ä¼ä¼ä¼ä¼ä¼¢ä¼ä¼ä»´ä¼å±åååå¦å¢ååååå¡åå®åªå´å¤¼å¦å¥¼å¦å¥»å¥¾å¥·å¥¿å­å°å°¥å±¼å±ºå±»å±¾å·å¹µåºå¼å¼å½´å¿å¿å¿æææ¤æ¡æ¦æ¢ææ ææ¥æ¯æ®æ¾æ¹æ¸æ»æºæ¿æ¼æ³æ°æ±æ±æ±æ±æ±æ±æ±"
  ],
  [
    "ca40",
    "æ±ç±çç´çµççªç¿ç©µç½è¸è¼èè½è¿èè¥¾éééééé¢é¤é é£ä½ä¼»ä½¢ä½ä½ä½¤ä¼¾ä½§ä½ä½ä½ä½ä¼­ä¼³ä¼¿ä½¡åå¹ååå¡å­å®åå£å²ååå°å·åªååååå¥å"
  ],
  [
    "caa1",
    "å½ååå¨å¤åå®å§å¥ååååååå¤å¥å¦¦å¦å¦ å¦å¦å¦¢å¦å¦å¦§å¦¡å®å®å°¨å°ªå²å²å²å²å²å²å²å²å²å²å· å¸å¸åºåºåºåºåºå¼å¼å½¸å½¶å¿å¿å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æå¿´æºæææææææ±æ»æºæ°æææ·æ½æ²æ´æ·æ°æ´æ³æ²æµææ"
  ],
  [
    "cb40",
    "æææææææææ¯æ°æ°æ±¸æ±§æ±«æ²æ²æ²æ±±æ±¯æ±©æ²æ±­æ²æ²æ²æ±¦æ±³æ±¥æ±»æ²ç´çºç£ç¿ç½ççççºçççççççºç¹çççç¤½è´èèèèèèèèèèè"
  ],
  [
    "cba1",
    "èèèè±¸è¿è¾¿éé¡é¥éé§é é°é¨é¯é­ä¸³ä¾ä½¼ä¾ä½½ä¾ä¾ä½¶ä½´ä¾ä¾ä½·ä½ä¾ä½ªä¾ä½¹ä¾ä½¸ä¾ä¾ä¾ä¾ä¾ä¾ä¾ä½«ä½®åå¼å¾åµå²å³åå±å¼ååå¼åååå¿ååååå«åºå¾å¥å¬å´å¦åå¯å¡å åå£å§å¤å·å¹å¯å²å­å«å±å°å¶ååµå»å³å´å¢"
  ],
  [
    "cc40",
    "å¨å½å¤å¥å¦µå¦ºå§å§å¦²å§å§å¦¶å¦¼å§å§å¦±å¦½å§å§å¦´å§å­¢å­¥å®å®å±å±å²®å²¤å² å²µå²¯å²¨å²¬å²å²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸å¸å¸å¼¨å¼¢å¼£å¼¤å½å¾å½¾å½½å¿å¿¥æ­æ¦ææ²æ"
  ],
  [
    "cca1",
    "æ´æææ³æææ¬æ¢æææ®æææææææ½æ­æ´ææ¾æªæ¶ææ®æ³æ¯æ»æ©æ°æ¸æ½æ¨æ»ææ¼ææææ»æææææ½æææ¶æææ¬æææ¶æ»ææææ´æææºæææææ½ææ¸æ¹ææ¬¥æ®æ­¾æ¯æ°æ²æ³¬æ³«æ³®æ³æ²¶æ³æ²­æ³§æ²·æ³æ³æ²ºæ³æ³æ³­æ³²"
  ],
  [
    "cd40",
    "æ³æ³æ²´æ²æ²æ²æ³æ³æ´°æ³æ³æ²°æ³¹æ³æ³©æ³ççççççççççççªççççççççççç¤ç¡ç­ç¦ç¢ç ç¬ççç¨ç¿çç¾ççç¯ç³ç±ç°çµç¸ç¼ç¹ç»çº"
  ],
  [
    "cda1",
    "ç·ç¥ç¤¿ç§ç©¸ç©»ç«»ç±µç³½èµèè®è£è¸èµè­è è èè«èèèèµè§è®è¼èèºè´è¨è¡è©èè¤èè¶è¢è°è¯è­è®è±è¿è¿è¿è¿è¿è¿è¿é²é´é¯é³é°é¹é½é¼éºéä¿ä¿ä¿ä¾²ä¿ä¿ä¿ä¿ä¿ä¿ä¾»ä¾³ä¿ä¿ä¿ä¾ºä¿ä¾¹ä¿¬ååååå½å¼åååååºå¡å­å¥å"
  ],
  [
    "ce40",
    "åèå·å®åå¶ååå å°å¼å¢å¾å²åå°åµååå¤ååååååååå¥ååå£´å¤å¥å§¡å§å§®å¨å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§å§©å§³å§µå§ å§¾å§´å§­å®¨å±å³å³å³å³å³å³"
  ],
  [
    "cea1",
    "å³å³å³å³å³å³å³å³å³å³å³å³å³å³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åºåº£åº¥å¼å¼®å½å¾æ·æ¹ææ²æææææææææææ¤æææ¦æ®ææææææµæææ«æ¹æææ¸æ¶ææææºææ»æ°æææªæ¿æ¶æ¡æ²æµææ¦æ¢æ³æ«æºææ´æ¹æ®ææææ²ææº"
  ],
  [
    "cf40",
    "ææ»æ¸æææ·ææ«æ¤ææµææ³æ·æ¶æ®æ£ææ¹ææ§æ°æ²æ¼ææ­ææ®æ¦ææºææææªææ¬¨æ®æ®æ®¶æ¯æ¯æ¯ æ° æ°¡æ´¨æ´´æ´­æ´æ´¼æ´¿æ´æ´æ³æ´³æ´æ´æ´ºæ´æ´æ´æ´æµ"
  ],
  [
    "cfa1",
    "æ´æ´æ´·æ´æ´æµæ´æ´ æ´¬æ´æ´¢æ´æ´ç·çç¾ç±ç°ç¡ç´çµç©çççç¬ç°ç³ç®çç¤ç¨ç«ççªç¦ç£çççççç¹ç¶çµç´ç«ç¿çç¾ççç¸çç¬ç®ç®ççç§çªç¹ççççççç·ç»çºç§ç¨ç ç ç ç ç ç ç ç ç ç ç¥ç¥ç¥ç¥ç¥ç§ç§ç§ç§ç§çª"
  ],
  [
    "d040",
    "ç©¾ç«ç¬ç¬ç±ºç±¸ç±¹ç±¿ç²ç²ç´ç´ç´ç½ç¾ç¾ç¾¾èèèèè·èèè èèèèèè£èèèèèèèè¦èè¿è¡èèè¾è¹èè¨èèèºè«èè´è¬è¡è²èµèè»è¶è°èª"
  ],
  [
    "d0a1",
    "è¤è èºè³è­è·è´è¼è³è¡è¡è¡§è¡ªè¡©è§è¨è¨èµ²è¿£è¿¡è¿®è¿ é±é½é¿ééé¾éééééééééééååååå¢å°åä¿µä¿´å³å·å¬ä¿¶ä¿·ååå å§åµå¯å±åååååååååå¡åååååå¢åååå¦å¢ååå§å³å¤åå¿ååå«ååå±"
  ],
  [
    "d140",
    "åå»å·å¸å ååååååå ²åååºåå½å¼å¸å¶å¿ååå¹åå¤å¥å¨å¨å¨­å¨®å¨å¨å¨å¨å¨å¨³å­¬å®§å®­å®¬å°å±å±å³¬å³¿å³®å³±å³·å´å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§æææ§"
  ],
  [
    "d1a1",
    "ææ¢æææææææææææææææ²æææ¬æææ¶ææ¤æ¹æææ¼æ©ææ´ææææ­ææ³æææ¸ææææææææææææææææ æ æ¡æ ²æ ³æ »æ¡æ¡æ æ ±æ æ µæ «æ ­æ ¯æ¡æ¡æ ´æ æ æ æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­èæ®æ¯¦æ¯¤"
  ],
  [
    "d240",
    "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶æµæµ¢æµ­æµ¯æ¶æ¶æ·¯æµ¿æ¶æµæµ§æµ æ¶æµ°æµ¼æµæ¶æ¶æ´¯æµ¨æ¶æµ¾æ¶æ¶æ´æ¶æµ»æµ½æµµæ¶çççççç¼¹ç¢çççç çççççççç¡çç¸"
  ],
  [
    "d2a1",
    "ç·ç¶ççºç´ç¾ç¶ç³ç»çççç¥çç¼ç§ç£ç©ççççççççç¨ççç´çµç¡ççç°çç»ççç¿ç¶çºçççççççç£ççççç¢ç§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥ç¥ç¥ç¥ç¥ç¥ç¥ç§«ç§¬ç§ ç§®ç§­ç§ªç§ç§ç§çªçªçªçªçªçªçªç«ç¬"
  ],
  [
    "d340",
    "ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç¬ç²ç²ç²ç²ç²ç²ç²ç´ç´ç´ç´ç´ç´ç´ç´ç´ç´ç´ç½ç½¡ç½ç½ ç½ç½ç¾ç¾ç¿ç¿ç¿èè¾è¹èºè²è¹èµèè»èèè¯è¥è³è­èèèè¥èè¿èè¦èè¢"
  ],
  [
    "d3a1",
    "èèèèªèè¼èèè¤è è·è¯è©èèèèèè¬èè§èèèè¢è¨èèèèèèèèèèè¥èè¡è§èèèèèèè¡è¡è¡­è¡µè¡¶è¡²è¢è¡±è¡¿è¡¯è¢è¡¾è¡´è¡¼è¨è±è±è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»è»è¿¾è¿µéè¿¿è¿»éè¿¼è¿¶éé ééé£éé¥ééééé¤é"
  ],
  [
    "d440",
    "éééé¢éééé¼é££é«é¬¯ä¹¿å°åªå¡åå åååå²åååååå¢åååå©å«å£å¤ååå®å³åååå«å­å¬å®ååå­ååµå¶å¼ååå´åªåå¢å¶åµå°åå"
  ],
  [
    "d4a1",
    "åå²å¥åå¹åå­å»ååååå»å å¢å¶åå´å å­å½å å¸å å³åå å®å£å²å¥å¬å¡å å¼å å§å å å±å©å°å å å¥å© å©å©å©§å©å¨¸å¨µå©­å©å©å©¥å©¬å©å©¤å©å©å©å©å©å©å©åªå¨¾å©å¨¹å©å©°å©©å©å©å©å©å©å­²å­®å¯å¯å±å´å´å´å´å´ å´å´¨å´å´¦å´¥å´"
  ],
  [
    "d540",
    "å´°å´å´£å´å´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾å¾å¾ææææ¾æ°æºææææ¤ææææ±ææ·ææ¿ææææ²æ¥æææ½æ½ææ­æææ«ææ¯æææ®æ¯æµææ­æ®æ¼æ¤æ»æ"
  ],
  [
    "d5a1",
    "æ¸æææææ°æææ¥æ¡ææææ¢ææ¡¹æ¢æ¢æ¢æ¡­æ¡®æ¢®æ¢«æ¥æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢æ¡¼æ¡«æ¡²æ¢ªæ¢æ¡±æ¡¾æ¢æ¢æ¢æ¢ æ¢æ¢¤æ¡¸æ¡»æ¢æ¢æ¢æ¡½æ¬¶æ¬³æ¬·æ¬¸æ®æ®æ®æ®æ®æ°ªæ·æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·æ¸æ·æ· æ·æ·æ¶¾æ·¥æ·æ·æ·æ·´æ·æ¶½æ·­æ·°æ¶ºæ·æ·æ·æ·"
  ],
  [
    "d640",
    "æ·æ·²æ·æ·½æ·æ·æ·£æ¶»çºçç·çç´çç°çç³çç¼ç¿çççç¸ç¶çççç¾ç»ç¼ç¿çççççççç¿çççç¶ç¸çµççç½çççºç¼ç¿ççç´çç¤ç£ççç"
  ],
  [
    "d6a1",
    "çççççççç¹ç¯ç­ç±ç²ç´ç³ç½ç¥ç»çµç¡ç¡ç¡ç¡ç¡ç¡ç ¦ç¡ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçªçªç¬µç­ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬ç¬£ç²ç²ç²ç²£ç´µç´½ç´¸ç´¶ç´ºçµç´¬ç´©çµçµç´¾ç´¿çµç´»ç´¨ç½£ç¾ç¾ç¾ç¾ç¿ç¿ç¿ç¿ç¿ç¿ç¿ç¿è"
  ],
  [
    "d740",
    "èèèèèèè¥èèè­èè¬èè¡èè§èè¢èè¸è³èºè´è²è´èè£è¨èèºè³è¤è´èèèèèµèè©è½èèèèèªèè¾è¥è¯èèè°è¿è¦èè®è¶èèèè¿è·"
  ],
  [
    "d7a1",
    "èèèèºè°èè¹è³è¸èè´è»è¼èè½è¾è¡è¢è¢è¢¨è¢¢è¢ªè¢è¢è¢¡è¢è¢è¢§è¢è¢è¢è¢¤è¢¬è¢è¢è¢è¦è§è§è§è¨°è¨§è¨¬è¨è°¹è°»è±è±è±½è²¥èµ½èµ»èµ¹è¶¼è·è¶¹è¶¿è·è»è»è»è»è»è» è»¡é¤ééééé¡é¯éªé°é´é²é³éé«é¬é©éééééé¬é´é±é³é¸é¤é¹éª"
  ],
  [
    "d840",
    "é«é·é¨é®éºééé¼é­é«é±é¯é¿éªé é£¥é¦åååååå£ååååå¨ååååååååå¤å§åå¨å¥å­å·åå¢ååååµåå£åå¤å½åå¦å¿åå¡ååå ©å ·"
  ],
  [
    "d8a1",
    "å å å §å £å ¨åµå¡å ¥å å å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åªåªå©ºåª¢åªå©¸åª¦å©¼åª¥åª¬åªåª®å¨·åªåªåªåªåªåª©å©»å©½åªåªåªåªåªå¯ªå¯å¯å¯å¯å¯å¯å°å°°å´·åµåµ«åµåµå´¿å´µåµåµåµå´³å´ºåµå´½å´±åµåµå´¹åµå´¸å´¼å´²å´¶åµåµå¹å¹å½å¾¦å¾¥å¾«ææ¹ææ¢æææ"
  ],
  [
    "d940",
    "æ²ææææµææ¸æ¼æ¾ææææææ¿æææææ±æ°ææ¥æ¨æ¯æææ³ææ æ¶ææ²æµæ¡ææ¾æææææææææææ°æææ²æ§æªæ¤ææ¨æ¥ææææ®ææ"
  ],
  [
    "d9a1",
    "æ¼æ¬æ»ææ±æ¹æªæ²ææ¤æ£æ¤æ£æ¤ªæ£¬æ£ªæ£±æ¤æ£æ£·æ£«æ£¤æ£¶æ¤æ¤æ£³æ£¡æ¤æ£æ¤æ¥°æ¢´æ¤æ£¯æ£æ¤æ£¸æ£æ£½æ£¼æ£¨æ¤æ¤æ¤æ£æ£æ£æ£æ£¦æ£´æ£æ¤æ£æ£©æ¤æ¤¥æ£æ¬¹æ¬»æ¬¿æ¬¼æ®æ®æ®æ®æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹æ¹æ¸æ¹æºæ¸¼æ¸½æ¹æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸æ¸³æ¹æ¹æ¹æ¸»æ¸æ¸®æ¹"
  ],
  [
    "da40",
    "æ¹¨æ¹æ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹æ¹¹æ¹æ¹¦æ¸µæ¸¶æ¹ç çç¯ç»ç®ç±ç£ç¥ç¢ç²çç¨çºççççççççççç°ç¢ç±ç³ç§ç²ç­ç¦ç£çµçç®ç¬ç°ç«ç"
  ],
  [
    "daa1",
    "çç¡ç­ç±ç¤ç£çç©ç ç²ç»ç¯ç¯ç¬ç§çç¡ç¦ççç¤ççççççççççççççç¬ç¡ ç¡¤ç¡¥ç¡ç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡ç¡¢ç¥´ç¥³ç¥²ç¥°ç¨ç¨ç¨ç¨ç¨çªç«¦ç«¤ç­ç¬»ç­ç­ç­ç­ç­ç­ç­ç²¢ç²ç²¨ç²¡çµçµ¯çµ£çµçµçµ§çµªçµçµ­çµçµ«çµçµçµ©çµçµçµç¼¾ç¼¿ç½¥"
  ],
  [
    "db40",
    "ç½¦ç¾¢ç¾ ç¾¡ç¿èèèè¾èèèèèèè½èèºè¦è®è·è¸è¹èè¼è½è¿èµè»èè¹è£èè¨èè§è¤è¼è¶èèèè«è£è¿èèè¥èè¿è¡èèèèµèèèèèèèè³"
  ],
  [
    "dba1",
    "èèºèèèªèèè¬è®èè»èè¢èèè¾èè¢è¦èè£èèªèè«èè¬è©èè¨èè¡è¡è¡è¢ºè£è¢¹è¢¸è£è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£è¦è¦è¦è§è§è§è©è©è¨¹è©è©è©è©è©è©è©è©è©è©è©è©è±è²è²è²ºè²¾è²°è²¹è²µè¶è¶è¶è·è·è·è·è·è·è·è·è·è·è·è·è»¯è»·è»º"
  ],
  [
    "dc40",
    "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é­é´é¯éé¬éé¿é¼éé¹é»éééééé¡é¤éé¢é ééé¥ééé¦ééééé¿é½ééé§ééé¤ééééé»ééééé¾é"
  ],
  [
    "dca1",
    "ééééééé±é°é¬é°é®é é¢©é£«é³¦é»¹äºäºäº¶å½å¿åå®ååå´ååå°ååºå±ååå¶å¸ååºå¸å»å¼ååååååååååå©å¿ååååå¢ååå²ååååå¡å¡¨å¡¤å¡å¡å¡å¡¯å¡å¡å¡å¡å¡¥å¡å ½å¡£å¡±å£¼å«å«å«åªºåª¸åª±åªµåª°åª¿å«åª»å«"
  ],
  [
    "dd40",
    "åª·å«å«åª´åª¶å«åª¹åªå¯å¯å¯å°å°³åµ±åµ£åµåµ¥åµ²åµ¬åµåµ¨åµ§åµ¢å·°å¹å¹å¹å¹å¹å»å»å»å»å»å½å¾¯å¾­æ·æææ«ææ¶æ²æ®ææ¯ææ©ææ é¨æ£æ¥æ¤ææ±æ«ææææ æ¤"
  ],
  [
    "dda1",
    "æ³æææææ¹æ·æ¢æ£ææ¦æ°æ¨ææµæ¯ææææ¥æ§ææ§ææ®æ¡ææ¯æææææææææææ¸æ æ¥¦æ¥æ¤¸æ¥æ¥¢æ¥±æ¤¿æ¥æ¥ªæ¤¹æ¥æ¥æ¥æ¥ºæ¥æ¥æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥æ¥¯æ¥æ¥¶æ¥æ¥æ¥´æ¥æ¤»æ¥æ¤·æ¥æ¥æ¥æ¤²æ¥æ¤¯æ¥»æ¤¼æ­æ­æ­æ­æ­æ­æ®ï¨æ¯»æ¯¼"
  ],
  [
    "de40",
    "æ¯¹æ¯·æ¯¸æºæ»æ»æºæ»æºæºæºæº æº±æº¹æ»æ»æº½æ»æºæ»æº·æº°æ»æº¦æ»æº²æº¾æ»æ»æ»æºæºæºæºæº¤æº¡æº¿æº³æ»æ»æºæº®æº£çççç£ç ççç¢ç²ç¸çªç¡ççççç°ççç"
  ],
  [
    "dea1",
    "çççççççççç¼çç»çºçççççççççççççççççç¡ç¿ç¾ç½çç¹ç·æ¦ç¯ççç·ç¾ç¼ç¹ç¸çç»ç¶ç­çµç½ççµçççç çççç©ç§ççç­ç ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢ç¢¡ç¢ç¡¹ç¢ç¢ç¢ç¡»ç¥¼ç¦ç¥½ç¥¹ç¨ç¨ç¨ç¨ç¨ç¨ç¨¢ç¨"
  ],
  [
    "df40",
    "ç¨ç¨çª£çª¢çªç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ç¶ç¶ç¶çµ¿ç¶çµºç¶çµ»ç¶çµ¼ç¶ç¶ç¶çµ½ç¶ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿ç¿è¡è¤è è·èè©èè¢è²æ¡èè¶è§è¯"
  ],
  [
    "dfa1",
    "èè¡èèèèèèè±è¿èè¶è¹èèè¥èèèè§è°èè½èèè´è³èèèè·èºè´èºèè¸è²èè©èèè¯èè­èè°è¹èèèè¯èèè»èè¶è³è¨è¾èè«è èè®èèèè·èèºèèµèè¸èèèè¶èèè£è£è£è£è£è£è£è£è£è¦è¦è§è§¥è§¤"
  ],
  [
    "e040",
    "è§¡è§ è§¢è§è§¦è©¶èªè©¿è©¡è¨¿è©·èªèªè©µèªèªè©´è©ºè°¼è±è±è±¥è±¤è±¦è²è²è²è³èµ¨èµ©è¶è¶è¶è¶è¶è¶è¶è¶è¶è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼è»¿è¼è¼è¼è¼è¼è¼è¼éé¿"
  ],
  [
    "e0a1",
    "ééé½ééééééééé®é¯ééé°éºé¦é³é¥ééé®ééé­é¬éé é§é¯é¶é¡é°é±éé£éé²ééééé²ééééééééééºé½é¸éµé³é·é¸é²é é é é¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­é³ªé³­é³§éºé»½å¦ååå¨å³ååªåå¤åå¬å°å¯å£å "
  ],
  [
    "e140",
    "åååå©å«å°å¬å§åååå¼ååååååºååå¿å¹å¢å¡¼å¢å¢å¢å¢å¡¿å¡´å¢å¡ºå¢å¢å¢å¡¶å¢å¢å¡»å¢å¢å£¾å¥«å«å«®å«¥å«å«ªå«å«­å««å«³å«¢å« å«å«¬å«å«å«å«¨å«å­·å¯ "
  ],
  [
    "e1a1",
    "å¯£å±£å¶å¶åµ½å¶åµºå¶åµ·å¶å¶å¶åµ¾åµ¼å¶åµ¹åµ¿å¹å¹å¹å»å»å»å»å»å»å»å»å»å½å½å½¯å¾¶æ¬æ¨æææ±æ³æææ²æ¬ææ´ææºææ¥æ»æªæ¡ææ©æ§æ«æ«ææææ´æ¶æ²æ³æ½æµæ¦æ¦æææææææ ææ¿æ¿æ¬æ«ææ¥æ·æ³æ æ¡æ ææææ¢æ¦±æ¦¶æ§"
  ],
  [
    "e240",
    "æ¦ æ§æ¦æ¦°æ¦¬æ¦¼æ¦æ¦æ¦æ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§æ¦½æ¦¤æ§æ¦¹æ§æ¦æ§æ¦³æ¦æ¦ªæ¦¡æ¦æ§æ¦æ¦æ§æ¦µæ¦¥æ§æ­æ­æ­æ®æ®æ® æ¯æ¯æ¯¾æ»æ»µæ»±æ¼æ¼¥æ»¸æ¼·æ»»æ¼®æ¼æ½æ¼æ¼æ¼§æ¼æ¼»æ¼æ»­æ¼"
  ],
  [
    "e2a1",
    "æ¼¶æ½³æ»¹æ»®æ¼­æ½æ¼°æ¼¼æ¼µæ»«æ¼æ¼æ½æ¼æ»½æ»¶æ¼¹æ¼æ»¼æ¼ºæ¼æ¼æ¼æ¼æ¼¡çççççççç»ççççççççççççç¢ç³ç±çµç²ç§ç®çççç½ççççççççç¸çç¼ççç®çç¯ç¾çç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢ç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦ç¦ç¦ç¦ç¦ç¦ç¦"
  ],
  [
    "e340",
    "ç¦ç¦ç¦ç¦ç¨«ç©ç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ç®ç®ç®ç®ç®ç®ç®ç®ç®ç®ç®åç®ç®¤ç®ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·ç¶£ç¶ªç·ç·ç·ç¶ç·ç·ç·ç·ç·ç¶¯ç¶¹ç¶ç¶¼ç¶ç¶¦ç¶®ç¶©ç¶¡ç·ç½³ç¿¢ç¿£ç¿¥ç¿"
  ],
  [
    "e3a1",
    "è¤èèèèèèèèèèèè¤è¡èèºèèè¬è®è«è¹è´èèèªèè±èèè§è»è¢èèèèè©è¯è¨èèè¶èè èèèèè°èè¡è³è£è¨è«èè®èè¡èèèè¬èè¾èè è²èªè­è¼èèºè±èµèè¦è§è¸è¤èè°èè£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"
  ],
  [
    "e440",
    "è£°è£¬è£«è¦è¦¡è¦è¦è§©è§«è§¨èª«èªèªèªèªèªè°½è±¨è±©è³è³è³è¶è¸è¸è·¿è¸è·½è¸è¸è¸è¸è¸è·¾è¸è¸è¼è¼è¼è¼é£éé é¢éééé¤é¡ééºé²é¹é³é¥é¤é¶ééºé ééªé"
  ],
  [
    "e4a1",
    "é¦éé«é¹éé¿é£é®éééé¢é½éé¡ééééé§é¾éé©ééé­éé¡é¿éé½éºé¾éééé»ééé¿ééé é¢­é¢®é¤é¤é¤é¦é¦é§é¦¹é¦»é¦ºé§é¦½é§éª±é«£é«§é¬¾é¬¿é­ é­¡é­é³±é³²é³µéº§å¿åå°å¸ååå¶å¾ååå½åååå±å¯ååååµååååå"
  ],
  [
    "e540",
    "ååå³å½å¬å¾å¸åªåºåå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬å«¸å¬å«¹å¬å¬å¬å¬å±§å¶å¶å¶å¶å¶¢å¶å¶å¶ å¶å¶¡å¶å¶å¹©å¹å¹ å¹ç·³å»å»å»¡å½å¾²æææ¹æ±æ°æ¢æ"
  ],
  [
    "e5a1",
    "æææ¯æ­æææªæ¡ææ¦æ³æ­æ®æ°ææ ææææææææ£ææ¨æ±ææ¶æºæ¹æ»æ²æ³æµæ°æ©æ²æ·æªæ¯æ¨æ¨æ¨æ§¥æ§¸æ¨æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨æ¨æ§¾æ¨§æ§²æ§®æ¨æ§·æ§§æ©æ¨æ§¦æ§»æ¨æ§¼æ§«æ¨æ¨æ¨æ¨¥æ¨æ§¶æ¨¦æ¨æ§´æ¨æ­æ®¥æ®£æ®¢æ®¦æ°æ°æ¯¿æ°æ½æ¼¦æ½¾æ¾æ¿æ¾"
  ],
  [
    "e640",
    "æ¾æ¾æ¾æ½¢æ½æ¾æ½æ¾æ½¶æ½¬æ¾æ½æ½²æ½æ½æ½æ¾æ¾æ½æ¼æ½¡æ½«æ½½æ½§æ¾æ½æ¾æ½©æ½¿æ¾æ½£æ½·æ½ªæ½»ç²ç¯çç°ç çç©çµçç¥çç¤ç¡çªçç§ç³ççççççç ççç¡çç"
  ],
  [
    "e6a1",
    "ç¢çççççç½ççç¼ç¹ççç¾ç¥ççççç£çç¨çççççççççç£ç¢»ç£ç£ç£ç£ç£ç£ç£ç£ç£ç¦ç¦¡ç¦ ç¦ç¦¢ç¦æ­¶ç¨¹çª²çª´çª³ç®·ç¯ç®¾ç®¬ç¯ç®¯ç®¹ç¯ç®µç³ç³ç³ç³ç··ç·ç·ªç·§ç·ç·¡ç¸ç·ºç·¦ç·¶ç·±ç·°ç·®ç·ç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è£è"
  ],
  [
    "e740",
    "èèè¢èèèèèèèèèè¤è»èèè©èèèèèè§èè»è«èºèèè´èªè²èè·è«è³è¼èèªè©èè¾è¨èè®èè½èè¶è±è¦è§è¨è°è¯è¹èè è°èèè¯è¢"
  ],
  [
    "e7a1",
    "èè£è¤è·è¡è³èèèèè¡èèèè­èªèèèèè¯è¬èºè®èè¥èè»èµè¢è§è©è¡è¤è¤è¤è¤è¤è¤è¤è¤è¤è¤è¤è¤è¦¢è¦¤è¦£è§­è§°è§¬è«è«èª¸è«è«è«è«èª»è«èª¾è«è«è«è«èªºèª½è«è°¾è±è²è³¥è³è³è³¨è³è³è³§è¶ è¶è¶¡è¶è¸ è¸£è¸¥è¸¤è¸®è¸è¸è¸è¸è¸è¸¦è¸§"
  ],
  [
    "e840",
    "è¸è¸è¸è¸è¸è¸è¸è¼¬è¼¤è¼è¼è¼ è¼£è¼è¼é³é°é¯é§é«é¯é«é©éªé²é¦é®ééééééééééééé¶éé±ééé©éééé¯éé¨éééé¦éééé éé§éé"
  ],
  [
    "e8a1",
    "éµé¡éé´é¼é¬é«é®é°é¤é¢ééééééééééé é é ¦é ©é ¨é  é é §é¢²é¤é£ºé¤é¤é¤é¤é¤é§é§é§é§é§é§é§é§é§é§é§é§éª³é«¬é««é«³é«²é«±é­é­é­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´é´é³¹é³»é´é´é´éºé»é¼é¼ååååååå´å¡å°å å®"
  ],
  [
    "e940",
    "å³å¦å£å­å²åå·ååå£å¢½å£å¢¿å¢ºå£å¢¼å£å¬å¬å¬å¬¡å¬å¬å¬å¬å¬¨å¬å¬ å¬å¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½å¾¼ææ¨æææ´ææææº"
  ],
  [
    "e9a1",
    "æ¿æ¸æææææææ½ææææ³ææ³æ¿æ¼æ¢ææ¾æææææ½æ»æºææ£æ¨´æ©¦æ©æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©æ©æ¨¨æ©æ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©æ©¯æ©©æ© æ¨¼æ©æ©æ©æ©æ©æ©æ­æ­æ­æ®§æ®ªæ®«æ¯æ¯æ°æ°æ°æ¾­æ¿æ¾£æ¿æ¾¼æ¿æ¿æ½æ¿æ¾½æ¾æ¿æ¾¨çæ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"
  ],
  [
    "ea40",
    "æ¾¢æ¿æ¾«æ¿æ¾¯æ¾²æ¾°ççç¿ç¸ççççççççç½çç¼çççççç©ç¦ç§ç¬ç¥ç«çªç¿çç çççç¡ççç¯ç­ç±ç½ç³ç¼çµç²ç°ç»ç¦ççç¡ççç¢ç£çç"
  ],
  [
    "eaa1",
    "çç£ç£©ç£¥ç£ªç£ç££ç£ç£¡ç£¢ç£­ç£ç£ ç¦¤ç©ç©ç©çª¶çª¸çªµçª±çª·ç¯ç¯£ç¯§ç¯ç¯ç¯¥ç¯ç¯¨ç¯¹ç¯ç¯ªç¯¢ç¯ç¯«ç¯ç¯ç³ç³ç³ç³ç³ç¸ç¸¡ç¸ç¸ç¸ç¸ ç¸ç¸ç¸ç¸ç¸ç¸¢ç¸ç¸ç¸ç¸ç¸ç¸¥ç¸¤ç½ç½»ç½¼ç½ºç¾±ç¿¯èªè©è¬è±è¦è®è¹èµè«è°è¬è´è²è·è§è²èèèèèè«èèè¡è"
  ],
  [
    "eb40",
    "èèè¤èè¢èèèè£è¾èè±èè®èµèè§è èè¦èèè¥è¬è£è¥è¤èèèèèèèèèè¹èè£èèèèèèèèèè¤è¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤è§±è« "
  ],
  [
    "eba1",
    "è«¢è«²è«´è«µè«è¬è«¤è«è«°è«è«è«¡è«¨è«¿è«¯è«»è²è²è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹è¹è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»ééºé³éµé¶éééééé§ééééééºé¸é¼éé£éééé­éééééºé¥éé¹é·é´éé¤é¿é©é¹éµéªéé"
  ],
  [
    "ec40",
    "éé¾ééé»éé¼éé¾é¹éºé¶é¿éµé½é©éééééééé°é¸é µé ¯é ²é¤¤é¤é¤§é¤©é¦é§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®é®é®é­¼é­¾é­»é®é®é®é®é­ºé®"
  ],
  [
    "eca1",
    "é­½é®é´¥é´é´ é´é´é´©é´é´é´¢é´é´é´éºéºéºéº®éº­é»é»é»ºé¼é¼½å¦å¥å¢å¤å å©å´ååååååå¾åå¿åå£å£å£å£å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»ææµæ¼æ§æ æ¥æ¤æ¨ææ¯æ©æ£æ«æ¤æ¨æææ¶æææªæªæªæª¥æªæªæªæª¡æªæªæªæª"
  ],
  [
    "ed40",
    "æªæªæª¨æª¤æªæ©¿æª¦æªæªæªæªæ­æ®­æ°æ¿æ¾©æ¿´æ¿æ¿£æ¿æ¿­æ¿§æ¿¦æ¿æ¿²æ¿æ¿¢æ¿¨ç¡ç±ç¨ç²ç¤ç°ç¢ç³ç®ç¯çç²ç«ççªç­ç±ç¥ç¯çççççççççç¤ç©çµç«ç²ç·ç¶"
  ],
  [
    "eda1",
    "ç´ç±ç¨ç°ç£³ç£½ç¤ç£»ç£¼ç£²ç¤ç£¹ç£¾ç¤ç¦«ç¦¨ç©ç©ç©ç©ç©ç©çª¾ç«ç«ç°ç°ç¯²ç°ç¯¿ç¯»ç°ç¯´ç°ç¯³ç°ç°ç°ç°ç¯¸ç¯½ç°ç¯°ç¯±ç°ç°ç³¨ç¸­ç¸¼ç¹ç¸³é¡ç¸¸ç¸ªç¹ç¹ç¹ç¸©ç¹ç¸°ç¸»ç¸¶ç¹ç¸ºç½ç½¿ç½¾ç½½ç¿´ç¿²è¬è»èèèèèè¼è©èèèèèèè§èè èè£è»è¤èè"
  ],
  [
    "ee40",
    "è·è¼èè¡èºè¸èèèèèèèèè¢èèèè¹è¶èèèè¨è¾èªè­èè°è¬è¹èµè¼è®èèèèè·è¯èèè´è¶è¿è¸è½èè²è¤µè¤³è¤¼è¤¾è¥è¥è¤·è¥è¦­è¦¯è¦®è§²è§³è¬"
  ],
  [
    "eea1",
    "è¬è¬è¬è¬è¬è¬¢è¬è¬è¬è¬è¬è¬è¬è¬è¬è¬è±è±°è±²è±±è±¯è²è²è³¹èµ¯è¹è¹è¹è¹è¹è¹è½è½éé¾é¸éé¢éééé¡éé é¡éé¯é¤ééé¼ééé¶éééé é­éééªé¹ééééé±é·é»é¡éé£é§ééééééééé·é®é°é¬é éééééé¡é"
  ],
  [
    "ef40",
    "ééééé±é¡é¡é¡é¡é¡é¡é¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦é¦£é¦¡é¨é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨éª¾é«¾é«½é¬é«¼é­é®é®¨é®é®é®¦é®¡é®¥é®¤é®é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"
  ],
  [
    "efa1",
    "éµéµéµé´¾é´·éµé´½ç¿µé´­éºéºéºéº°é»é»é»»é»¿é¼¤é¼£é¼¢é½é¾ å±å­å®ååååååå¥°å¬¼å±©å±ªå·å¹­å¹®æææ­æ®æ±æªæ°æ«ææ©æ¿ææ½æ¸æææ¼ææææææ«æª¹æª½æ«¡æ«æªºæª¶æª·æ«æª´æª­æ­æ¯æ°çççççççæ¿¿çæ¿»ç¦æ¿¼æ¿·ççç¿ç¹çç½ç¶"
  ],
  [
    "f040",
    "ç¸ççµçç¾ç¶ç»ççççç¤çççççç¦ç½ç¬ççºç£¿ç¤ç¤ç¤ç¤ç¤ç¤ç¤ç¦­ç¦¬ç©ç°ç°©ç°ç° ç°ç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹ç¹ç¹ç¹£ç¹ç¹¢ç¹ç¹ç¹ ç¹ç¹ç¾µç¾³ç¿·ç¿¸èµèè"
  ],
  [
    "f0a1",
    "èèèè´èèèèè³èµè½èèè¿èèèèè±è¶èè¤è¸è·è¾è©è§è¦è¢èè«èªè¥èè³è¤èèèè­èè£è¤èèè è´è¨èè¥è¥è¥è¥è¥è¥è¥è¥è¬ªè¬§è¬£è¬³è¬°è¬µè­è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±è±µè²è²è²è³¾è´è´è´è¹è¹¢è¹ è¹è¹è¹è¹¥è¹§"
  ],
  [
    "f140",
    "è¹è¹è¹¡è¹è¹©è¹è½è½è½è½é¨éºé»é¾é¨é¥é§é¯éªéµééé·éééé§ééªéé¦éééééé±éé²é¤é¨é´é£é¥éééé³ééå·éééé£é¢é¥é¬é®é¨é«é¤éª"
  ],
  [
    "f1a1",
    "é¢é¥éééééºé¡é¡é¡é¢¸é¥é¤¼é¤ºé¨é¨é¨é¨é¨é¨é¨é¨é¨é¨é«é«é¬é¬é¬é¬©é¬µé­é­é­é¯é¯é¯é®¿é¯é®µé®¸é¯é®¶é¯é®¹é®½éµéµéµéµéµéµéµéµéµéµéµéµéµéµéµéºéºé»é¼é¼é¼é¼¥é¼«é¼ªé¼©é¼¨é½é½å´åµåå·å´å«å­å¦å§åªå¬å£å£å£å¤å¬½å¬¾å¬¿å·å¹°"
  ],
  [
    "f240",
    "å¾¿æ»æææææææææææ«§æ« æ«æ«æ«æ«æ«æ«æ«æ««æ«æ«æ«æ­ æ®°æ°çç§ç çç«ç¡ç¢ç£ç©çç¤ççªçççççç¥ç¦ç¤ç£ç¡ççç·ççç çççç±ç¤ç¤"
  ],
  [
    "f2a1",
    "ç¤¡ç¤ç¤ç¤ç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½ç½ç¾ç¾ç¾·ç¿½ç¿¾è¸èèè¤è¡è£è«è±è­èè¡è¨èèè¬è²è¸èèè£èèè°è¦è¯èè¢è èºè è¶è·è è è è è¼è è¿è è è¥¢è¥è¥è¥è¥¡è¥è¥è¥è¥è¦è¦·è¦¶è§¶è­è­è­è­è­è­è­è­è­"
  ],
  [
    "f340",
    "è­è­è­è­è±è±·è±¶è²è´è´è´è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»è½è½è½è½è½è¾´éé¿é°é­ééééééé¹é¬ééé©é¦ééé®é£éééééé§é½ééé¡é©é«é¬é¨é¦"
  ],
  [
    "f3a1",
    "é³é·é¶éééé¡é¡é¡é¡é¢¿é¢½é¢»é¢¾é¥é¥é¥é¦¦é¦§é¨é¨é¨¥é¨é¨¤é¨é¨¢é¨ é¨§é¨£é¨é¨é¨é«é¬é¬é¬é¬é¬·é¯ªé¯«é¯ é¯é¯¤é¯¦é¯¢é¯°é¯é¯é¯¬é¯é¯é¯¥é¯é¯¡é¯éµ·é¶é¶é¶é¶éµ±é¶éµ¸é¶é¶é¶éµ½éµ«éµ´éµµéµ°éµ©é¶éµ³éµ»é¶éµ¯éµ¹éµ¿é¶éµ¨éºéºé»é»¼é¼­é½é½é½é½é½é½å·å²"
  ],
  [
    "f440",
    "åµå³å££å­å·å·å»®å»¯å¿å¿æ¹ææææææ¨æ£æ¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç¼çµç¯ç·ç´ç±çç¸ç¿çºç¹çç»ç³çççç¨ç½ç¼çºç«çªç¾ç­ççççç²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"
  ],
  [
    "f4a1",
    "ç¦²ç©®ç©¬ç©­ç«·ç±ç±ç±ç±ç±ç³®ç¹»ç¹¾çºçºç¾ºç¿¿è¹èèèè¨è©è¢è¿èè¾èèè¶èèèèè½è è è è è è è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èºèºèºè½è½è½è½è½è½éééé·éµé²é³ééé»é ééé¾ééé¨éééµéé·éééééºéé¸éé¿"
  ],
  [
    "f540",
    "é¼éé¶éééé éé®é¯é¹é»é½é¾é¡ é¡¢é¡£é¡é£é£é¥é¥é¥é¥é¥é¥é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«é«é«é¬é¬é¬é°é°é¯·é°é°é¯¸é±é°é°é°é°é°é°é¶é¶é¶¤é¶é¶é¶é¶é¶"
  ],
  [
    "f5a1",
    "é¶ é¶é¶é¶ªé¶é¶¡é¶é¶¢é¶¨é¶é¶£é¶¿é¶©é¶é¶¦é¶§éºéºéºé»¥é»¤é»§é»¦é¼°é¼®é½é½ é½é½é½é¾åºå¹åååå½å¾å­å­å·å·å»±æ½ææ¬æ«¼æ¬æ«¸æ¬ççççççççççç¾ççªçç¤­ç¤±ç¤¯ç±ç±ç³²çºçºçºçºçºçºç½ç¾»è°èèèªè¦èè£èèè§è®è¡è è©èè¥"
  ],
  [
    "f640",
    "è ©è è è  è ¤è è «è¡è¥­è¥©è¥®è¥«è§ºè­¹è­¸è­è­ºè­»è´è´è¶¯èºèºè½è½è½éééé¹é¿é»é¶é©é½é¼é°é¹éªé·é¬éé±é¥é¤é£éµéºé¿é¡é¡¤é£é£é£é¥é¥é¨¹é¨½é©é©é©é©é¨º"
  ],
  [
    "f6a1",
    "é¨¿é«é¬é¬é¬é¬é¬ºé­é°«é°é°é°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·é·é·é¶¾é·é·é¶»é¶µé·é¶¹é¶ºé¶¬é·é¶±é¶­é·é¶³é·é¶²é¹ºéºé»«é»®é»­é¼é¼é¼é¼±é½é½¥é½¤é¾äº¹åååå¥±å­å­å·å·å»²æ¡æ æ¦æ¢æ¬æ¬æ¬æ°ççççççç©ç¿ççççç­ç­ç¤µç¦´ç©°ç©±ç±ç±ç±ç±ç±"
  ],
  [
    "f740",
    "ç³´ç³±çºç½ç¾èè«è´èµè³è¬è²è¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®è®è®è®è­¿è´èºèºèºèºèºèºèºè½ è½¢éééééééééééé¿é£é¡ªé¡©é£é¥é¥é©é©é©é©é©é©é©"
  ],
  [
    "f7a1",
    "é©é©é©é«é¬é¬«é¬»é­é­é±é±é°¿é±é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·é·é·é·é·é·é·é·é·é·©é·é·é·é·µé·é·éº¶é»°é¼µé¼³é¼²é½é½«é¾é¾¢å½åå£¨å£§å¥²å­å·è ¯å½ææææ©æ¥ææ«æ¬æ¬æ¬æ¯ççç¢çççç°çç±§ç±¦çºè¬èºèè¹è¼è±è»è¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"
  ],
  [
    "f840",
    "è®è®è®è®è±è´èºè½¤è½£é¼é¢ééééééé é©é©é¬é¬é¬ é±é±é±é±é±é±é±é±é±é±é·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»é»é»²é»³é¼é¼é¼¸é¼·é¼¶é½é½"
  ],
  [
    "f8a1",
    "é½±é½°é½®é½¯ååå­å±­æ­æ­æ®æ¬çç¡çç ç£çç¥çç¤¸ç¦·ç¦¶ç±ªçºç¾è­èè ¸è ·è µè¡è®è®èºèºèº èºé¾é½éé«é¨é©é¥ééééé¥é©é«é­é±£é±§é±¦é±¢é±é± é¸é·¾é¸é¸é¸é¸é¸é¸é¸é·¿é·½é¸éº é¼é½é½´é½µé½¶åæ®æ¸æ¬æ¬æ¬æ¬ç¢ç¦çªççç¤¹ç±©ç±«ç³¶çº"
  ],
  [
    "f940",
    "çºçºçºè è¡èèèè¥¹è¥ºè¥¼è¥»è§¿è®è®èº¥èº¤èº£é®é­é¯é±é³éé¡²é¥é±¨é±®é±­é¸é¸é¸é¸é¸é¸éº¡é»µé¼é½é½¸é½»é½ºé½¹åç¦ç±¯è ¼è¶²èº¦éé´é¸é¶éµé© é±´é±³é±±é±µé¸é¸é»¶é¼"
  ],
  [
    "f9a1",
    "é¾¤ç¨ç¥ç³·èªè ¾è ½è ¿è®è²èº©è»éé¡³é¡´é£é¥¡é¦«é©¤é©¦é©§é¬¤é¸é¸é½ææ¬ç§èèº¨éééé©©é©¨é¬®é¸ç©èè®éé±¹éº·çµé©«é±ºé¸ç©çªéº¤é½¾é½é¾ç¢é¹è£å¢»æç²§å«ºââ¦ââ â¬â£ââ©âââ¤âââªâ¡ââ§âââ¥âââ«â¢ââ¨ââââ­â®â°â¯â"
  ]
];
const require$$7 = [
  [
    "8740",
    "ä°ä°²ää¦ä¸ð§§äµ·ä³ð§²±ä³¢ð§³ã®ä¶ää±ä±ð¤¿ð£ð§ð¦ºð§ä±ðªäää²ð§±¬ä´äª¤ä¡ð¦¬£ç¥ð¥©ð¡©£ð£¸ð£½¡æå»"
  ],
  [
    "8767",
    "ç¶å¤ð¨®¹ã·´é´ð§¯¯å¯ð¡µåª¤ã¥ð©º°å«å®·å³¼æ®èð©¥ç¡çã¡µð¡µð£ð¦¡ã»¬"
  ],
  [
    "87a1",
    "ð¥£ã«µç«¼é¾ð¤¡ð¨¤ð£ªð ªð£äèé¾é¯ä¤°èå¢ééç§ç¨²æ æ¨©è¢çç¯æç¨¬åéã¦çð¥¶¹çé¿å³ä¤¯åä±ð£å ç©²ð§­¥è®ä®ð¦ºäð¥¶ç®®ð¢¼é¿ð¢ð¢ð¢é¿èð£»ä´é¿ä¡ðª·¿æç®é¿"
  ],
  [
    "8840",
    "ã",
    4,
    "ð ãð ð ããð ð¡¿¨ãð ããããð ããÄÃÇÃÄÃÄÃÅÃÇÃà¿¿ÃÌáº¾à¿¿ÃÌá»ÃÄÃ¡ÇÃ ÉÄÃ©ÄÃ¨Ä«Ã­ÇÃ¬ÅÃ³ÇÃ²Å«ÃºÇÃ¹ÇÇÇ"
  ],
  [
    "88a1",
    "ÇÃ¼à¿¿ÃªÌáº¿à¿¿ÃªÌá»ÃªÉ¡ââ"
  ],
  [
    "8940",
    "ðª©ð¡"
  ],
  [
    "8943",
    "æ"
  ],
  [
    "8946",
    "ä¸½æ»éµé"
  ],
  [
    "894c",
    "ð§µæä¼ä¼¨ä¾¨åå´åå¤å¡å¨å»åååå¢å£°å¤å¤å¤²å¤´å­¦å®å®å²åºæ»ææ¾æ æ¡¥æµç¼çµçº¤çº¬çººç»ç»ç»ç¼ç¼·èºèè¯è§è®¾è¯¢è½¦è½§è½®"
  ],
  [
    "89a1",
    "çç³¼ç·æ¥ç«å§"
  ],
  [
    "89ab",
    "éç¢¸éè¼"
  ],
  [
    "89b0",
    "è´è¶ð §§"
  ],
  [
    "89b5",
    "èé»ä³é·é¸ä°¾ð©·¶ð§é¸ðª³ã"
  ],
  [
    "89c1",
    "æºè¾ç"
  ],
  [
    "89c5",
    "ä¤é©¬éªé¾ç¦ð¨¬ð¡·ð ð¢«¦ä¸¤äºäºäºäº¿ä»«ä¼·ãä¾½ã¹ååã½ãã¥åå¤åå¼åäºå¹åå§ãå©ãå°ãåå£ã­ã²ãåå£å´å¹åå¯åå£å¨ãå¿ã¥ã¿åã"
  ],
  [
    "8a40",
    "ð§¶å¥"
  ],
  [
    "8a43",
    "ð ±ð ´ð¥«åð¢³ã§¬ð è¹ð¤¶¸ð©¥äð¨¾çºð¢°¸ã¨´äð¨ð¦§²ð¤·ªæð µ¼ð ¾´ð ³ð¡´æè¹¾ð ºð °ð ½¤ð¢²©ð¨ð¤"
  ],
  [
    "8a64",
    "ð µð©©ð¨©ä´ð¤º§ð¢³éª²ã©§ð©´ã¿­ãð¥ð©ð§£ð¢µéµ®é "
  ],
  [
    "8a76",
    "äð¦¥æ´å£ð¢µð¢¯ð¡·ã§»ð¡¯"
  ],
  [
    "8aa1",
    "ð¦ð¦ð§¦ æªð¥ð ±è¹¨ð¢¡ð¨­ð ±"
  ],
  [
    "8aac",
    "ä ð ©ã¿ºå¡³ð¢¶"
  ],
  [
    "8ab2",
    "ð¤ð ¼ð¦ð ½ð ¶å¹ä»äº"
  ],
  [
    "8abb",
    "äª´ð¢©¦ð¡èªé£µð ¶æ¹ã§¾ð¢µè·å¡æ¼ã¹"
  ],
  [
    "8ac9",
    "ðªð ¸ð¢«ð¢³"
  ],
  [
    "8ace",
    "ð¡ð£§ã¦ã¨ð¨ã¸ð¥¹ð¢åð ¼±ð¢²²ð© ã¼æ°½ð¤¸»"
  ],
  [
    "8adf",
    "ð§´ð¢ºð¢ðªð¨³ð ¹ºð °´ð¦ ç¾ð¡ð¢ ð¢¤¹ã»ð¥£ð ºð ¾ð ºªã¾ð ¼°ð µð¡ð ¹"
  ],
  [
    "8af6",
    "ð º«ð ®©ð µð¡ð¡½ã¿¹ð¢æ²ð ¾­"
  ],
  [
    "8b40",
    "ð£´ð§¹ð¢¯ð µ¾ð µ¿ð¢±ð¢±ã¨ð ºð¡ð ¼®ðª²ð¦­ð¨³ð¨¶ð¨³éªåèå¹"
  ],
  [
    "8b55",
    "ð©»é°¦éª¶ð§ð¢·®çè­è¬å°ð¦²è´ãåð¨½é¶ð »ºð ¸ð ¹·ð »»ãð¤·«ãð ³å¯ð¢µð¡ð ¸ð ¹¸ð¡¸ð¡ð¨ð¡ð ¹¹ð¤¹ð¢¶¤å©ð¡ð¡ð¡µð¡¶åð ¸"
  ],
  [
    "8ba1",
    "ð§ð¨ð ¾µð ¹»ð¥¾ãð ¾¶ð¡ð¥ðª½ð¤§ð¡ ºð¤·ð¨¼å¢å¨ãð¥½ç®²å­¨ä ä¬¬é¼§ä§§é°é®ð¥­´ð£½å»ã²åä¸¨å¤ð¡¯ð¯¡¸éð ä¹äº»ã¾å°£å½å¿ã£ºææµæ­ºæ°µæ°ºç¬ç«ä¸¬ç­ð¤£©ç½ç¤»ç³¹ç½ð¦ªã"
  ],
  [
    "8bde",
    "ð¦èèð¦ð¦¥åè¡¤è§ð§¢²è® è´éé¸é¿é¨ð¨¸é¦é¡µé£é£é¥£ð© é±¼é¸é»æ­¯ï¤ä¸·ð éæ·é¢"
  ],
  [
    "8c40",
    "å»æ·¾ð©±³é¾¦ã·è¢ð¤ç·å³µä¬ ð¥ãð¥´°æ¢ð¨¨²è¾§é¶çæçºð£ðªã²ð¡¦ä¬ç£¤çå®ð¨äæ©£ðªºä£èð ©¯ç¨ªð©¥ð¨«ªéçå¤ð¢¾é´çð¨§£é¾§çäº£ä¿°å¼ä¸¯ä¼é¾¨å´ç¶å¢å£ð¡¶¶åºåºå¿ð¢æ"
  ],
  [
    "8ca1",
    "ð£¹æ¤æ©ð£±£æ³¿"
  ],
  [
    "8ca7",
    "çð¤çã»ð¤¨å¬ç¹è®ð¥²¤ð¥çªç¯¬ç³ç¹¬è¸èé¾©è¢é¾ªèº¹é¾«è¿èé§ é¡é¾¬ð¨¶¹ð¡¿ä±ä¢å¨"
  ],
  [
    "8cc9",
    "é¡¨æ«ä¶å½"
  ],
  [
    "8cce",
    "èð¤¥»è¿ð§ä²ð¦µ´åµ»ð¦¬ð¦¾¾é¾­é¾®å®é¾¯æ§ç¹æ¹ç§ã¶äð£ð¢ää¶"
  ],
  [
    "8ce6",
    "å³ð£¬è«¹å±¸ã´ð£åµ¸é¾²çäð¤¬ð¡¸£ä±·ã¥¸ãð ¤ð¦±è«ä¾´ð ¹å¦¿è¬é¡ð©£ºå¼»"
  ],
  [
    "8d40",
    "ð ®"
  ],
  [
    "8d42",
    "ð¢ð¨¥­ää»ð©¹ã¼é¾³ðªµä¸ãä·ð¦±ä¼ð¨²ð§¿ä­ã£ð¥ä¡ää¶ä±»äµ¶äªã¿ð¤¬ã¡ää½ä­å´¾åµåµã·¼ã å¶¤å¶¹ã  ã ¸å¹åº½å¼¥å¾ã¤ã¤ã¤¿ã¥ææ½å³¥ã¦æ·æ¹æã¦¸æ¬ææ¥æã§¸å±"
  ],
  [
    "8da1",
    "ã¨æ¢æ»ææã©æå´å¡é¾ãªæãª½æ¿æã«²æã¬¢æã­æ¤æ ã­æ¡æ¢ã­²ã­±ã­»æ¤æ¥çæ¥¤æ¦æ¦ã®¼æ§ã¯æ©¥æ©´æ©±æªã¯¬æªã¯²æª«æªµæ«æ«¶æ®æ¯æ¯ªæ±µæ²ªã³æ´æ´æ´¦æ¶ã³¯æ¶¤æ¶±æ¸æ¸æ¸©æºð¨§æº»æ»¢æ»é½¿æ»¨æ»©æ¼¤æ¼´ãµð£½æ¾æ¾¾ãµªãµµç·å²ã¶ç¬ã¶ççç¯ç¿çð ¥äã±ð »"
  ],
  [
    "8e40",
    "ð£»å¾ð¦»ç¾ð¥ ãæ¦¢ð¨¯©å­´ç©ð¥£¡ð©ç©¥ç©½ð¥¦¬çª»çª°ç«ç«çð¦äç«ç«ç«ªä¯å²ð¥°ç¬ç­ç¬©ð¥ð¥³¾ç®¢ç­¯èð¥®´ð¦±¿ç¯è¡ç®ç®¸ð¥´ ã¶­ð¥±¥èç¯ºç°ç°µð¥³ç±ç²ð¤¢ç²¦æ½ð¤¸ç³ç³ç³¦ç±´ç³³ç³µç³"
  ],
  [
    "8ea1",
    "ç¹§äð¦¹çµð¦»çç¶ç¶«çµç¶³ç·ð¤ð¦©ç·¤ã´ç·µð¡¹ç·¥ð¨­ç¸ð¦¡ð¦ç¹®çºä«é¬ç¸§ç½ç½ç½ç¤¶ð¦é§¡ç¾ð¦ç¾£ð¡¡ð ¨äð£¦äð¨ºç¿ºð¦èèèè¨è¯ðªð¦³è»è¼è¡ð¢ä¦ð¦¦ð£·£ð¦¨æ¥è§ð¨©èèå¢°ð¢¶æ±¿ð¦ð¤¾¸æ§ð¡èð¡¡æ©ð¤©¥ð¤ªäºè©ð ¬ð¦©ð£µ¾ä¿¹ð¡½è¢è¢ð¦¬ð¤¦§ð£°ð¡³ð£·¸èªæ¤ð¯¦ä"
  ],
  [
    "8f40",
    "èèèð ¸ð¡´ãð£½ð£è»è¢èð£ºð¦¶£ð¦¬ð¦®ð£ã¶¿èå¬èäð¦¶¥è¬èèã¾ð¦»æ©èãð¦¹ð¢»¯èð¥¯¤è±ã·ä¤æª§èð£²µç¥è¨ð¦®ð¦¹·ð¦¹èèèä èè¤ð¥²äð¥³äè´å«²ð¦ºä§è³äæ¿è"
  ],
  [
    "8fa1",
    "ð¨¥ð¨»èð§èð¡ð§ð¯¦²äªè¨ãð¡¢¢å·ð§è¾è±ðª¸è®ð¢°§è±èè å¡è¬æ¡äè¡è¡ð§ ð£¶¹ð§¤è¡è¢äè¢´è¢µæè£ç·ð§è¦è¦è¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªçé¾èªð§©ç«©ð§¬ºð£¾äð§¬¸ç¼è¬è¬ð¥°ð¥¥è¬¿è­è­èª©ð¤©ºè®è®èª¯ð¡äè¡è²ð§µð§¶ð¯§ã¥ð§µè³ð§¶ð§¶½è´è´ð¡¤è³çè´ð¤³ã»èµ·"
  ],
  [
    "9040",
    "è¶©ð¨ð¡ð¤¦ã­¼ð¨¼ð§ç«§èº­èº¶è»éè¼è¼­ð¨¥ð¨è¾¥éðªð ©è¾³ä¤ªð¨§ð¨½ð£¶»å»¸ð£¢è¿¹ðªð¨¼ð¨ð¢¥ã¦ð¦»é·ð¨¼ð§ª¾é¡ð¨¬ð¨é¨ð¨éð¨¦é®é½é§ã«°é©éç²¬ð¨¤³ð¡ºéæ²éé¢ð¥¹é¹ð¨«ð£²ð¨¬ð¥"
  ],
  [
    "90a1",
    "ð ´±é¬é«ð¨«¡ð¨¯«çå«ð¨«¢ð¨«¥ä¥¥éð¨¯¬ð¨°¹ð¨¯¿é³éèº¼éé¦é¦é æ¿¶ä¹ð¢ºð¨ð¡¼ð£¸®ä§æ°é»éä¬é£ð¦»æé¶ç£µð¨« é½åä¦¡ð¦²¸ð ´ð¦ð©¯ð©¥ð¤«ð¡¤ð£é±èé¶ä¨ä½äð¤«©çµå­ééð©éå­ð©«éé¥åð£·ð£¼ééé±é¾ééé ð¥¬é®çð©³é¿éµð©ð§¥ºä«é ´é ³é¡é¡¦ã¬ð§µãµð °ð¤"
  ],
  [
    "9140",
    "ð¥é£é¢·é£é£ä«¿ð¦´§ð¡å°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡ð©¤é§µé¨é¨»é¨é©ð¥¥ãð©±ð©¯é« é«¢ð©¬é«´ä°é¬é¬­ð¨å´é¬´ð¦¦¨ã£ð£½é­é­ð©´¾å©ð¡¡£é®ð¤é°é¯¿é°ð©¹¨é·ð©¾·ðªðª«ðª¡ðª£ðªéµ¾é¶ðª´é¸æ¢"
  ],
  [
    "91a1",
    "é·ð¢ðªðª ð¡¤»ðª³é´¹ðª¹ðª´éºéºéºéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ã¾ð¨°«é¼é¼ä®é¤ð¦¶¢é¼é¼é¼¹ååé½é¦¸ð©é²è¿é½¢é½©ç«é¾çä®¾ð¤¥µð¤¦»ç·ð¤§¸ð¤ð¤©çð¨¯ð¡£ºç¦ð¨¥¾ð¨¸¶é©é³ð¨©é¬ééð¨¥¬ð¤¹çã»«ç²ç©çð¤³ð¤¸ç¾ð¡¯ç£ð¡¢¾ð£ã»ð¡¢ð¥¯ð¡¸ã¢ð¡»ð¡ ¹ã¡ð¡´ð¡£ð¥½ã£ð¡åð¤¨¥ð¡¾ð¡¨"
  ],
  [
    "9240",
    "ð¡ð¡¶èð£¦èèð¤¦ð§¥ð£¸±ð¥ð£»»ð§ä´ð£®ð©¦ð¦¼¦æ¹ã³ã°ã·§å¡¬ð¡¤¢æ äð£¿ð¤¡ð¤ð¤ð¦°¡ååð¦±åð ¿ð ®¨ð ¸éð¨¬éä»¸å«ã ð¤¶äº¼ð ¥ð ¿ä½ä¾ð¥å©¨ð «ð ã¦ð ð ãµä¼©ð ð¨º³ð µè«ð äº"
  ],
  [
    "92a1",
    "ååä¾¢ä¼ð¤¨ð£ºä½å®å¬åä¿ä¿¥åå¼ååååæ¹¶ð£ð£¸¹ð£º¿æµ²ð¡¢ð£ºå¨åð  äð £ð ð èµºð¨ªð åå¤ð ¡³å¡é®äºçð¤ð ° ð¤¦¬ð¡¤æ§ð ¸ç¹ã»ççççä®ð¤ª¼ð¤åãçð¤å´ð åð ¯åéé´é¦ååå¿ã¾å£åªð¨©ð¡ºð¡¯ð¡å¨¬å¦¸éå©¾å«å¨ð¥¥ð¡§³ð¡¡¡ð¤ãµæ´çå¨¡ð¥º"
  ],
  [
    "9340",
    "åªð¨¯ð é çð¡çä¥²éð¨§»é½ã å°å²å¹å¹ð¡¦ð¡¥¼ð£«®å»å­ð¡¤ð¡¤ãð¡¢ ãð¡¾ãèªð¨©ð¡¶ºð£²ð¨¦¨å¼å¼ð¡¤§ð¡«å©«ð¡»å­èð§½è¡ æ¾ð¢¡ ð¢«å¿ãº¸ð¢¯ð¢¾ð©ð¦½³æð ¾ð ð¢æææµð¢²ð¢´ð¤ð©"
  ],
  [
    "93a1",
    "æ±ð¤¥ð¢­ªã¨©ð¢¬¢ð£ð©£ªð¢¹¸æ·ðªæ¶æ±æð¤§£ð¢µ§æ¤ð¢²¡æ»æ«æ¥²ã¯´ð£ð£­ð¤¦ð£«åð£ ð¡£ð©¿æð£ð£³ã« äð¥ð¨¬¢ð¥ð¡¼ð¥ð¥¥ç£®ð£ð¡ ªð£´ã¤ð£ð£ð¤æð¦´¤æ«ä®æ°ð§¡°ð¡·«æ£ð£ð£¡æð¥¡²ã£ð£ ºð£¼ã®ð£¢ð£¾çã®æð¤ªæ¢¶æ ã¯æª¾ã¡£ð£ð¤æ¨³æ©æ«æ¬ð¡¤ææ¢æ©ã¯æ©ºæ­ð£¿ð£²é é²ð¨¯ªð¨«"
  ],
  [
    "9440",
    "éð¨ð¨§é§æ¶¥æ¼ð¤§¬æµ§ð£½¿ã¶æ¸ð¤¼å¨½æ¸å¡æ´¤ç¡ç»ð¤ð¤¶ç±çççð¤ð¤¥å¹ð¤ª¤ð «çºð£»¸ð£ð¤©ð¤¤ð¥¿¡ã¼ãº±ð¤«ð¨°£ð£¼µæ§ã»³çç¼éç·äð¦·ªäçã½£ð¤³ð¤´ã½çç³ðªã¬ç¨ð¨«ð¤¦«ð¤¦ã«»"
  ],
  [
    "94a1",
    "ã·ð¤©ã»¿ð¤§ð¤£³éºå²éð¨«£ð¡¡¤åð¥¡ð¥§ç¸ð£²ççç»ð¤ð£ã©ð¤£°ç¸çãº¿ð¤ªºð¤«äð¤ªð¦®éð¥ç ç¢ç¢ç£çç¥ð§ð¥£äç¦èç¦¥æ¨­ð£»ºç¨ºç§´ä®ð¡¦ä²éµç§±ð µð¤¦ð ð£¶ºð¡®ãå«ã°ãªð ð °ç«¢å©ð¢µð¥ª¯ð¥ªå¨ð ç£°å¨ªð¥¯ç«¾ä¹ç±ç±­äð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡°ç²ç±¼ç²®æª²ç·ç¸ç·ç½ð¦¡"
  ],
  [
    "9540",
    "ð¦ð§­ç¶ð¥ºäªð¦­µð ¤æð ð£åð¦ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µç¬ð¥¸é§¦èé©£æ¨ð£¿ã§¢ð¤§·ð¦­é¨ð¦ èð§§ð¦³äªè·äèèèð¦´é£ð¦©è¢è¥ð¦©èð¦¶§èð§åªä¿ð¡¡å¬«ð¡¢¡å«¤ð¡£è ð¯¦¼ð£¶è ­ð§¢å¨"
  ],
  [
    "95a1",
    "è¡®ä½è¢è¢¿è£¦è¥¥è¥ð¥è¥ð§ð§ð¨¯µð¨¯ð¨®ð¨§¹ãº­è£äµäã²è¨½è¨ð©å½é«ð¤æç©çð¡¡éµ­è²è³©ð§·å¦çå§°ä®ãè¸ªèº§ð¤°è¼°è½ä´æ±æ¾»ð¢¡ä¢æ½¹æºð¡é¯©ãµð¤¤¯é»éå±ä¤é»éð¨©ä¢ð¨«¼é§ð¨°ð¨°»è¥è¨«éé§ééð¨´´çã»ð¤£¿ð¤©ð¤ªã»§ð£¥éð¨»§ð¨¹¦ð¨¹¥ã»ð¤§­ð¤©¸ð£¿®çç«ã»¼éð©°"
  ],
  [
    "9640",
    "æ¡ä¨ð©ð¥éé¨ð¨¦ð¨°¦ð¨¬¯ð¦¾éºå¬è­©ä¤¼ç¹ð¤éé±é¤¸ð ¼¦å·ð¨¯ð¤ª²é ð©é¶ð©é¥äð¨­ð¤©§ð¨­¤é£ð¨©ã¼éªä¤¥èé¤»é¥ð§¬ã·½é¦ä­¯é¦ªé©ð¨­¥ð¥£æªé¨¡å«¾é¨¯ð©£±ä®ð©¥é¦¼ä®½ä®é½å¡²ð¡å ¢ð¤¦¸"
  ],
  [
    "96a1",
    "ð¡¨ç¡ð¢ð£¶¸æ£ãµ½éã¤§æð¢ð¢¥«æé±é±é±»é°µé°é­¿é¯ð©¸­é®ðªµðª¾é´¡ä²®ð¤é¸ä²°é´ðª´ðª­ðª³ð©¤¯é¶¥è½ð¦¸ð¦¿ð¦®è¼ä³ð¦¶¤ð¦ºð¦·°è è®ð¦¸ð£ð¦¤ç§¢ð£ð£ä¤­ð¤§ãµ¢éé¾éð ¿ç¢¹é·éä¿¤ãé¤ð¥ç ½ç¡ç¢¶ç¡ð¡ð£ð¤¥ãä½²æ¿æ¿ççåð¤µå»å£³åé´åç´ã¯ð¤¬ç«ð¦±ð¤¾å¬¨ð¡µð¨©"
  ],
  [
    "9740",
    "æå«å¨ä¼ð¤ã¬ä­»ð¨§¼é»é¸ð¡£ð ¼è²ð¦³ð¡ð¤ºð¢°¦ð¤å¦ð£¶·ð¦ç¶¨ð¦ð¦¤ð¤¦¹ð¤¦ð¨§ºé¥ç¢ã»©ç´ð¨­£ð¡¢ã»¡ð¤ª³æ«ç³ç»ã»ð¤¨¾ð¤ªð¡ð¤©¦ð §ð¡¤ð¤§¥çð¤¤ç¥ð¤¥¶éç¦éð ¾é±ð¨«ð¨¨éð¨¯§ð¥ä¤µð¨ªç«"
  ],
  [
    "97a1",
    "ð¤¥ð ³¿å¤ð ð ¯«ð ²¸åç§ð¡ºç·¾ð¡ð¤©ð¡¡ä®éãð¨«ð¤¦­å¦°ð¡¢¿ð¡¢ð§åª¡ã¢ð£µã°éå©¹ð¨ªð¡¡¢é´ã³ð ª´äªã¦å´ãµ©ãµð¡çµä»ð¨æ¸ð©¤ä«æµð§¹ç§æ²¯ã³ð£¿­ð£¸­æ¸æ¼ãµ¯ð µçã¼ãäã»ä¡±å§é®ä¤¾è½ð¨°ð¦¯å åãð¡ç¾ð¤¢ð¤©±ð¢¿£ð¡°ð¢½æ¢¹æ¥§ð¡ð£¥ð§¯´ð£ð¨ªð£ð£ºð¤²æ¨ð£­ð¦²·è¾ää"
  ],
  [
    "9840",
    "ð¦´¦ð¦µð¦²ð¦¿æ¼ð§è½ð¡ºè­ð¦²ð§ð¡å¦åªð¡³å©¡å©±ð¡¤ð¤¼ã­å§¯ð¡¼ãçéæð¤¥å©®å¨«ð¤æ¨«ð£»¹ð§¶ð¤ð¤çð¤ð¨§¡ä¾°ð¦´¨å³ð¤ð§¹ð¤½æ¨ð¤ð¡ç¦ç³ð¤©ã¶¥æ³ð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½ð¤©ð¡ç¶¤è¦"
  ],
  [
    "98a1",
    "åð£«ºð£ð å¾ð £ð ã¿¥ð¡¾ðª¶çð©åµ°çç³ð¨©ð© ä¿ç¿§ççð§«´ç¸ç¹ð¥¶ççãº©ð§¬é¬çµð¤£²ç¡è¶ã»çã»æ²¢å½çççã»¢ã»°ã»´ã»ºçã¼ã½çç­ç²çã½¼ççã¿çã¿ç´ã¿çºð¤½çå£è¦å¡©äçä¹æ¡äãçäªä¯å±ç¾çå£²ç ç¹ç ä¨ç ¹ç¡ç¡ç¡¦èð¥µç¤³æ ç¤²ä"
  ],
  [
    "9940",
    "äç¦ç¦è¾»ç¨è¾¼ä§çªä²çª¼è¹äç«ç«ää¸¡ç­¢ç­¬ç­»ç°ç°ä äºç±»ç²äç²¸äç³­è¾çð ³ç·ç·ç·ç·½ç¾®ç¾´çäè è¥ç¬¹è®è±èã·å´ç è·è©ä­èçªèèç èäã¬¹èèè"
  ],
  [
    "99a1",
    "äå ºè¼èä¥èä­è¥å¯èè¤èäè¦è¶èèè¿ä°èé©æ¦èçµè¤æ£èäè¾è¡è¸èè¸èä»è¯è°è ä·è²èè²è¯éèääè¢®è£¿è¤¤è¥è¦ð§¥§è¨©è¨¸èªèª´è±è³è³²è´äå¡è·ä­ä»®è¸ºååè¹±åµèº°ä ·è»è»¢è»¤è»­è»²è¾·è¿è¿è¿é³é§ä¢­é£ éä¤é¨éé«é±é®é¿"
  ],
  [
    "9a40",
    "é£é«é³é´é½ééé­ä¥ä¥éº¿éåéé­é¾ä¥ªéé¹é­é¢ä¦§é´é³ä§¥æ ä¨¤éä¨µé²éåä«¤æ¨é¢¹ä¬é£±å¡é¤é¤å´é¤é¤·é¥é¥é¥¢ä­°é§ä®é¨¼é¬çªé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯éµé°º"
  ],
  [
    "9aa1",
    "é»¾åé¶é¶½é·é·¼é¶è¾¶é¹»éº¬éº±éº½é»éé»¢é»±é»¸ç«é½ð ð ·ð  æ¤éå¦¬ð å¡éã¹ð ð ð ¶ð¡ºåç³ð «ð «ð ®¿åªð¯ »ð ¯åð ¯»ð °»ð ±ð ±¥ð ±¼æ§ð ²åºð ²µð ³ð ³­ð µ¯ð ¶²ð ·æ¥é°¯è¥ð ¸ð ¸ð »ð ¾ð ¼­ð ¹³å° ð ¾¼å¸ð¡ð¡ð¡¶æð¡»ð¡ð¡ãð¡¿ð¡ð¡¯ð¡»å¤è­ð¡£ð¡µð¡¶è®ð¡·ð¡ð¡ð¡ä¹¸ç»ð¡ ­ð¡¥ª"
  ],
  [
    "9b40",
    "ð¡¨­ð¡©ð¡°ªð¡±°ð¡²¬ð¡»æð¡»ð¡¼çæ¡ð¢æ§©ãð¢¼ð¢ð¢ºð¢ªð¢¡±ð¢¥è½ð¢¥§ð¢¦ð¢«è¦¥ð¢«¨è¾ ð¢¬é¸ð¢¬¿é¡éª½ð¢±"
  ],
  [
    "9b62",
    "ð¢²ð¢²·ð¥¯¨ð¢´ð¢´ð¢¶·ð¢¶ð¢¹ð¢½´ð¢¿ð£³ð£¦ð£ð£å¾±ææ¿ð§©¹ð£§ð£³çð¤¦ºçð£ð£çºð å¢µæ"
  ],
  [
    "9ba1",
    "æ¤ð£ª§ð§ð¥¿¢ð£¸ð£º¹ð§¾ð¢ä£äª¸ð¤ð¨ªð¤®ð¤ð¤»ð¤´ð¤ð¤©ð åð å¦ð¡º¨ã®¾ð£³¿ð¤ð¤åð¤´ã¦ð¤¯ð¨¨ð©§ã¢ð¢è­ð¨­é§ð¤ ð¤£»ð¤¨çð¤«ð ±¸å¥¥ð¤º¥ð¤¾ð ¹è»ð¥¬åå¿ç±ð¥ð¥ð£½ð¤ª§å¼ð¥ð¥®ð¦­éã³ð¥¿ð§²ð¥äð¥¢ð¥¦ð¥ð¤¤¿ð¥¡å¦ã»ð£æð¥¤ä¼ð¨¥ð¥ª®ð¥®ð¥°ð¡¶å¡çæ¾¶ð¦ð§°éð¦²ð¤¾è­¢ð¦ð¦"
  ],
  [
    "9c40",
    "åµð¦¯·è¼¶ð¦ð¡¤è«ªð¤§¶ð¦ð£¿¯ð¦ä¯ð¦¿ð¦µð¢é¥ð¥¡æå¨§ð¯£ä¾»å¹ð¤¡ð¦¼ä¹ªð¤¤´éæ¶ð¦²½ãè¥·ð¦ð¦¡®ð¦ð¦¡çð¦£ç­ð©ð ¨ð¦¤¦éð¦¤¹ç©é·°ð¦§ºé¨¦ð¦¨­ãð¦©ð ¡ç¦ð¦¨´ð¦­å´¬ð£èð¦®äð¦²¤ç»è¡¥ð¦¶®å¢¶"
  ],
  [
    "9ca1",
    "ãð¢ð§ð§ã±ð§ð§éð¢ºð§é°ð§¦ð¤§æ°¹éð§ð »¸è §è£µð¢¤¦ð¨³ð¡±æº¸ð¤¨ªð¡  ã¦¤ã¹å°ç§£ä¿æ¶ð©²­ð©¢¤è¥ð§ð§¡åäð¡ã¦¡ð£¯ð¨¨ð¡ç­è¦ð§§ð©¨å©§ä²·ð§¯ð¨¦«ð§§½ð§¨ð§¬ð§µ¦ð¤ºç­ç¥¾ð¨æ¾µðªæ¨ð¨å¢ð¦¸é¿æ ¶éð¨¯ð¨£ð¦¦µð¡­ð£¯ð¨å¶ð¨°°ð¨åé £ð¨¥å¶«ð¤¦æ¾æ§åð¤ª¥ð£¾ã°æ¶ð¨ð¨´ð¨®ð¡¾¡ð¨"
  ],
  [
    "9d40",
    "ð¨ð¨¯ð¨ð¨ð¨¯ð¨ãð¨¨ð¨ªä£ºæ¦ð¨¥ç éð¨¦¸ä²ð¨§§äð¨§¨ð¨­ð¨¯å§¸ð¨°è¼ð¨¿ð©¬ç­ð©ð©¼ã··ð©ð¤«è¿çåð©§ð©©ð©°ð©¸ð©²ð©£ð©¥ð©¥ªð©§ð©¨¨ð©¬ð©µð©¶çºð©»¸ð©¼£ä²¤éðªç¢ðª¿ä¶éðªä¶ð ²è¾¾å"
  ],
  [
    "9da1",
    "è¾ºð¢°è¾¹ð¤ªäç¹¿æ½æª±ä»ªã¤ð¨¬¬ð§¢ãºèºð¡µð¨¤ð¨­¬ð¨®ð§¨¾ð¦¯ã·«ð§ð£²·ð¥µð¥¥äºð¥ºð¦å¿ð ¹­è¸å­­ð£ºð¤²ææð¡¶ð¡¡»æ°å­ð¥±åð¥ã·ð©¶ä±½å¢åç½ð¥»å¥µð£µè°ä¸ð ¿ªð µð£ºèéµè´ç»é±çç¹éå²èè·å¥è²èè½åªç¥¢ååð ºãåå±æ±ð¨¢ã­ç´å°åºåå²ð ±ð ²å»ð¥ð ¹¶ð¢±¢"
  ],
  [
    "9e40",
    "ð º¢éº«çµåð¡µæé­åè³ç¶é¶æ¼æ¹æ¾å©ð¢­é±²ð¢º³åãð ¶§å§åååç¦è¸­ð¦¢ç±è¶è èè£è¶èð¡ä¬çð¤å®èð¦¢å»ð¢´ð§´¯ð¤£ð§µ³ð¦»ð§¶é°ð¡éð£³¼ðª©ð º¬ð »¹ç¦ð¡²¢äð¤¿ð§¿¹ð ¿«äº"
  ],
  [
    "9ea1",
    "é±æð¢¶ ä£³ð¤ ð©µ¼ð ¿¬ð ¸æ¢ð§£ð ¿­"
  ],
  [
    "9ead",
    "ð¦ð¡ç£çºéµä¸ä¸ã·å¬æ²²å§ã¬ã§å½ã¥ð¤å¢ð¤­®è­ååªð¥ªð ¥¹"
  ],
  [
    "9ec5",
    "ã©ð¢¥ç´ð©º¬ä´é¯­ð£³¾ð©¼°ä±ð¤¾©ð©ð©¿èð£¶¶ð§²ð¦³ð£ æ®ç´¥ð£»·ð£¸¬ã¨ªéåã¹´ãºä©ð çå«°ð º¶ç¡ºð§¼®å¢§ä¿å¼é®åµ´çðª´éºä³¡ç¹ã»æð£ð¤²"
  ],
  [
    "9ef5",
    "åð¡©å§ð¤¥£ð©¸å´ð§®ã­æ±éµ¼"
  ],
  [
    "9f40",
    "ç±é¬¹åð¡¬å±æð©ð¦µð§¤è­ð ´¨ð¦´¢ð¤«¢ð µ±"
  ],
  [
    "9f4f",
    "å¾ð¡¼å¶éð¡·éºéç¬é¬å³ç®£æ¨æµé«¿ç¯é¬ªç±¾é¬®ç±ç²é°ç¯¼é¬é¼é°ð¤¤¾é½å³å¯ä¿½éºä¿²å ã¸åå§åå¦·å¸éé¶«è½å©é´é¥éºå¬æ°"
  ],
  [
    "9fa1",
    "æ¤¬åé°é´ä°»éæ¦å¦çð¡­é§å³"
  ],
  [
    "9fae",
    "ééé"
  ],
  [
    "9fb2",
    "éð¨ºæ¿ð¦´£æ«åéçºæð ¼çç±°ð¥°¡ð£³½"
  ],
  [
    "9fc1",
    "ð¤¤çé®ä¸ªð ³è¾è¡"
  ],
  [
    "9fc9",
    "å±æ§å­åºåå·µä»æ°±ð ²ä¼¹åååè¶ã¾å¼ã³"
  ],
  [
    "9fdb",
    "æ­é¼é¾¥é®é ®é¢´éªºéº¨éºçºç¬"
  ],
  [
    "9fe7",
    "æ¯ºè ç½¸"
  ],
  [
    "9feb",
    "å ðªè¹·é½"
  ],
  [
    "9ff0",
    "è·è¹é¸è¸æð¨½è¸¨è¹µç«ð¤©·ç¨¾ç£æ³ªè©§ç"
  ],
  [
    "a040",
    "ð¨©é¼¦æ³èçðª²ç¡ð¯¡è´ç¢ç±è¬­çç±è³«ð¤ª»è¯å¾ºè¢ ä·"
  ],
  [
    "a055",
    "ð¡ »ð¦¸"
  ],
  [
    "a058",
    "è©¾ð¢"
  ],
  [
    "a05b",
    "æ½ç§é«éµé®é®èµ"
  ],
  [
    "a063",
    "è è³·ç¬é¡é®°ãç²ä°ç±é¥ð¦æä°éºæ½"
  ],
  [
    "a073",
    "åæ¯æ¦æ¹æã©æ¢åªð£µæ¤æ ã"
  ],
  [
    "a0a1",
    "åµð¨¯è¿ð¨¸¹"
  ],
  [
    "a0a6",
    "åð¡µç¤å²é¸ð ¼»ä¥"
  ],
  [
    "a0ae",
    "ç¾"
  ],
  [
    "a0b0",
    "ç³ð¥¼ç³ç¨­è¦è£çµçç²è¦èæè¢ð§èç°èç¤è¦ð¦çð¦»è©èèèè©è²­è­ç«ç¸èãµæ¦²è¶¦"
  ],
  [
    "a0d4",
    "è¦©ç¨æ¶¹èð¤ç§ã·ç¶æ¤æã³ç¢æ·"
  ],
  [
    "a0e2",
    "ç½±ð¨¬­çæ©ä­¾å ã°ð£³ð¥»ð§ð¥±ð¡¥ð¡¾ð©¤ð¦·ð§­å³ð¦­ð¨¨ð£·ð ®ð¦¡ð¤¼ä¢å¬ð¦é½éº¦ð¦«"
  ],
  [
    "a3c0",
    "â",
    31,
    "â¡"
  ],
  [
    "c6a1",
    "â ",
    9,
    "â´",
    9,
    "â°",
    9,
    "ä¸¶ä¸¿äºäº ååå«å¹å¸å©å¶å¤å®å·â¼³å¹¿å»´å½å½¡æ´æ çç¶è¾µé¶Â¨Ëã½ã¾ãããä»ãããã¼ï¼»ï¼½â½ã",
    23
  ],
  [
    "c740",
    "ã",
    58,
    "ã¡ã¢ã£ã¤"
  ],
  [
    "c7a1",
    "ã¥",
    81,
    "Ð",
    5,
    "ÐÐ",
    4
  ],
  [
    "c840",
    "Ð",
    26,
    "ÑÐ¶",
    25,
    "â§â¸â¹ãð ä¹ð åä"
  ],
  [
    "c8a1",
    "é¾°åé¾±ð§"
  ],
  [
    "c8cd",
    "ï¿¢ï¿¤ï¼ï¼ã±ââ¡ããâºâºâºâºâºâºâºâºâºâºâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»â»â»â»â»â»â»â»â»£"
  ],
  [
    "c8f5",
    "ÊÉÉÉÉµÅÃ¸ÅÊÉª"
  ],
  [
    "f9fe",
    "ï¿­"
  ],
  [
    "fa40",
    "ð éð ð£¿èäµç¯åµãð¤¥ð¨§¤éð¡§è®ð£³ç ¼ææð¤¤³ð¨¦ªð  ð¦®³ð¡ä¾«ð¢­åð¦´©ð§ªð£ð¤ª±ð¢å©ð ¾å¾¤ð ð æ»ð å½åãºåé¡¬ãèð¤¦¤ð å ð£´åªð ¯¿ð¢¼ð ¥ð¢°ð ð£³ð¡¦å®è½ð ³ð£²å²å¸"
  ],
  [
    "faa1",
    "é´´åååã³åð¤ª¦å³å¢åå­èæ¤¾ð£­å½»åå¦å¼åµååå¹åç°èå èð¦¬åð¨«åæ»ð£¾ð ¥ð£¿¬å³åð ¯¢æ³ð¡¦æ çæãºªã£ð¡¨çä¢å­å´ð¨«å¾å¿ð¡ð¡ç¦åð¨ªå å«å®ç§ð¥²ã½çååæ±ä¹å¾åãª«ð ®å ð£¿«ð¢¶£å¶ð ±·åç¹å«ææµå­ð¦­ð µ´ååå¤ä¦ð¡ð »ã¶´ð µ"
  ],
  [
    "fb40",
    "ð¨¦¼ð¢åä³­å¯çåå©åð¡£ð¤ºäð¤µæ³ð¡´å·æð£æ¤æ­ååç£±å±éå¾åå¯å­ð¨­¦ã£ð¡åð¤¥æ±®çåã±ð¦±¾å¦ð¡å ð¡ð¤£å ¦ð¤¯µå¡å¢ªã¡å£ å£ð¡¼å£»å¯¿åðªð¤¸éã¡å¤æ¢¦ãæ¹"
  ],
  [
    "fba1",
    "ð¡¾å¨¤åð¡èå§ð µð¦²ð¦´ªð¡å§ð¡»ð¡²ð¦¶¦æµ±ð¡ ¨ð¡å§¹ð¦¹åª«å©£ã¦ð¤¦©å©·ãåªç¥å«ð¦¾¡ð¢ã¶ð¡¤ã²ð¡¸åºåå­¶æå­¼ð§¨ää¡ð å¯æ ð¡¨´ð¥§ð ¥å¯³å®ä´å°ð¡­å°çå°ð¡²¥ð¦¬¨å±ä£å²å³©å³¯å¶ð¡·¹ð¡¸·å´å´åµð¡º¤å²ºå·è¼ã ­ð¤¤ð¢ð¢³èã ¶ã¯å¸®æªå¹µå¹ºð¤¼ð ³å¦äº·å»å¨ð¡±å¸å»´ð¨"
  ],
  [
    "fc40",
    "å»¹å»»ã¢ å»¼æ ¾éå¼ð ð¯¢ã«ä¢®ð¡ºå¼ºð¦¢ð¢å½ð¢±å½£é½ð¦¹®å½²éð¨¨¶å¾§å¶¶ãµð¥ð¡½ªð§¸ð¢¨éð ð¨¨©æ±æð¡¡·ã¥£ã·ã¹åð¢´ç¥±ã¹ææ¤æ³ð¤¦ð¤¦ð§©ç¤å¡åª æ¤è¤æð¯¢¦ð¦»æå´ð æå®ªð£¾·"
  ],
  [
    "fca1",
    "ð¢¡æð¨®ð©¥æã¤²ð¢¦ð¢£æ£æææð æð¡°æð¢¸æ¬ð¤§ã¨æ¸æ¸ð¡ð¡¼ææ¾ð¢¸¶é ð¤ð¥æ¡æ¥é»ã©¦æºã©ææ¼ð¤¨¨ð¤¨£ææ­æð£¾æµð¤¥ä¬·æäð¡ ©æ æ£å¿ð£æð£·ð£¸æð£¤ð£¥æð ¹µæ§ð¥¦æ³æ´ð¡¸½ð£±ð¨´ð£ð¥çð¢£·é¦¤æð¤ð¤¨¡ã¬«æ§ºð£ææ§æ¢ð¤ð©­æä©æ ¢æ¹é¼æ ð£¦ð¦¶ æ¡"
  ],
  [
    "fd40",
    "ð£¯æ§¡æ¨ð¨«æ¥³æ£ð£æ¤æ¤ã´²ã¨ð£¼ã®æ¬æ¥¡ð¨©ä¼æ¤¶æ¦ã®¡ð è£åæ§¹ð£ð¢ªæ©ð£æªã¯³æ±æ«ð©ã°æ¬ð ¤£ææ¬µæ­´ð¢æºµð£«ð µð¡¥ãå¡ð£­æ¯¡ð£»¼æ¯æ°·ð¢ð¤£±ð¦­æ±è¦æ±¹ð£¶¼äð£¶½ð¤¤ð¤¤ð¤¤"
  ],
  [
    "fda1",
    "ð£³ã¥ã³«ð ´²é®ð£¹ð¢ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶æµæ¹¼æ¼ð¤¥¿ð¤ð¦¹²è³ð¦½´åæ²æ¸è®ð¨¬¡æ¸¯ð£¸¯çð£¾ç§æ¹åªð£æ¿¸ãæ¾ð£¸°æ»ºð¡ð¤½äé°æ½æ½ãµæ½´ð©°ã´»æ¾ð¤æ¿ð¤ð¤ð¤¹ð£¿°ð£¾´ð¤¿åð¤ð¤ð¤ð¦çç¾ç§çççççäã·¨ç´çð¤·ç«çåªçç®å²ð¤¥çé¢ð¤ç¬ð¤ð¤¨§ð¤¨¢çºð¨¯¨ç½ç"
  ],
  [
    "fe40",
    "éçå¤éç¤éð¥ç®çð¤¥´æ¢½ççã¹ð£æ æ¼½ççªç«ð¤ £ð¨ «ä£­ð¨ ç¨ç®ççªð °ºð¦¨®ççð¤¢ð¡§ð¤¨¤æ£ãð¤¦·ð¤¦ð¤§»ç·çæ¤ð¤¨¦ç¹ð ã»çð¢¢­ç ð¨º²çç¤ç¶è¹ç¬ã°ç´é±æ¨¬çä¥ð¤ª"
  ],
  [
    "fea1",
    "ð¤ð¤©¹ð¨®å­ð¨°ð¡¢çð¡¦çç©çð¨»ð¡©å¯ð¨º¬éççç§ç®ð¤¾ã¼ð¤´çççç´çç¬ççç¯ç¶ð¦µçè¯ã¸ð¦¤ð¦¤ç¡ç¥ç·çð¦¾è¢ð¥ð¥½ð¡¸çç¦çæ¯ð¥ çð£¬ç¯ð¨¥¤ð¨¥¨ð¡ç´ç ð¡¶ð¤¨æ£ç¢¯ç£ç£é¥ç¤®ð¥ ç£ç¤´ç¢±ð§è¾¸è¢ð¨¬«ð¦ð¢ç¦è¤æ¤ç¦ð¥¡ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§¦ãº¨ç§ð©ç§"
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + Â¥ + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0;
      },
      encodeAdd: { "Â¥": 92, "â¾": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "Â¥": 92, "â¾": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "â¬": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer3 = safer_1.Buffer;
  streams = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer3.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer3.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
(function(module) {
  var Buffer3 = safer_1.Buffer;
  var bomHandling$1 = bomHandling, iconv = module.exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "ï¿½";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer3.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer3.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = requireEncodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key2 in codecDef)
            codecOptions[key2] = codecDef[key2];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling$1.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling$1.StripBOM(decoder, options);
    return decoder;
  };
  iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv.supportsStreams)
      return;
    var streams2 = requireStreams()(stream_module2);
    iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = require("stream");
  } catch (e) {
  }
  if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
  } else {
    iconv.encodeStream = iconv.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
})(lib);
var libExports = lib.exports;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(windows, "__esModule", { value: true });
windows.Windows = void 0;
var constants_1 = constants;
var drive_1 = __importDefault(drive);
var utils_1$1 = utils;
var iconv_lite_1 = __importDefault(libExports);
var Windows = (
  /** @class */
  function() {
    function Windows2() {
    }
    Windows2.run = function() {
      var drives = [];
      var buffer2 = utils_1$1.Utils.execute(constants_1.Constants.WINDOWS_COMMAND);
      var cp = utils_1$1.Utils.chcp();
      var encoding = "";
      switch (cp) {
        case "65000":
          encoding = "UTF-7";
          break;
        case "65001":
          encoding = "UTF-8";
          break;
        default:
          if (/^-?[\d.]+(?:e-?\d+)?$/.test(cp)) {
            encoding = "cp" + cp;
          } else {
            encoding = cp;
          }
      }
      buffer2 = iconv_lite_1.default.encode(iconv_lite_1.default.decode(buffer2, encoding), "UTF-8");
      var lines = buffer2.toString().split("\r\r\n");
      var newDiskIteration = false;
      var caption = "";
      var description = "";
      var freeSpace = 0;
      var size = 0;
      lines.forEach(function(value) {
        if (value !== "") {
          var tokens = value.split("=");
          var section = tokens[0];
          var data = tokens[1];
          switch (section) {
            case "Caption":
              caption = data;
              newDiskIteration = true;
              break;
            case "Description":
              description = data;
              break;
            case "FreeSpace":
              freeSpace = isNaN(parseFloat(data)) ? 0 : +data;
              break;
            case "Size":
              size = isNaN(parseFloat(data)) ? 0 : +data;
              break;
          }
        } else {
          if (newDiskIteration) {
            var used = size - freeSpace;
            var percent = "0%";
            if (size > 0) {
              percent = Math.round(used / size * 100) + "%";
            }
            var d = new drive_1.default(description, size, used, freeSpace, percent, caption);
            drives.push(d);
            newDiskIteration = false;
            caption = "";
            description = "";
            freeSpace = 0;
            size = 0;
          }
        }
      });
      return drives;
    };
    return Windows2;
  }()
);
windows.Windows = Windows;
Object.defineProperty(dist, "__esModule", { value: true });
dist.getDiskInfoSync = dist.getDiskInfo = void 0;
var darwin_1 = darwin;
var linux_1 = linux;
var windows_1 = windows;
var utils_1 = utils;
function getDiskInfo() {
  return new Promise(function(resolve, reject) {
    try {
      var platform2 = utils_1.Utils.detectPlatform();
      var drivesInfo = void 0;
      switch (platform2) {
        case "aix":
          reject(new Error("Platform not supported: " + platform2));
          break;
        case "android":
          reject(new Error("Platform not supported: " + platform2));
          break;
        case "darwin":
          drivesInfo = darwin_1.Darwin.run();
          resolve(drivesInfo);
          break;
        case "freebsd":
          drivesInfo = darwin_1.Darwin.run();
          resolve(drivesInfo);
          break;
        case "linux":
          drivesInfo = linux_1.Linux.run();
          resolve(drivesInfo);
          break;
        case "openbsd":
          drivesInfo = darwin_1.Darwin.run();
          resolve(drivesInfo);
          break;
        case "sunos":
          reject(new Error("Platform not supported: " + platform2));
          break;
        case "win32":
          drivesInfo = windows_1.Windows.run();
          resolve(drivesInfo);
          break;
        default:
          reject(new Error("Platform not recognized: " + platform2));
      }
    } catch (e) {
      reject(e);
    }
  });
}
dist.getDiskInfo = getDiskInfo;
function getDiskInfoSync() {
  var platform2 = utils_1.Utils.detectPlatform();
  var drivesInfo;
  switch (platform2) {
    case "aix":
      throw new Error("Platform not supported: " + platform2);
    case "android":
      throw new Error("Platform not supported: " + platform2);
    case "darwin":
      drivesInfo = darwin_1.Darwin.run();
      return drivesInfo;
    case "freebsd":
      drivesInfo = darwin_1.Darwin.run();
      return drivesInfo;
    case "linux":
      drivesInfo = linux_1.Linux.run();
      return drivesInfo;
    case "openbsd":
      drivesInfo = darwin_1.Darwin.run();
      return drivesInfo;
    case "sunos":
      throw new Error("Platform not supported: " + platform2);
    case "win32":
      drivesInfo = windows_1.Windows.run();
      return drivesInfo;
    default:
      throw new Error("Platform not recognized: " + platform2);
  }
}
dist.getDiskInfoSync = getDiskInfoSync;
class SystemInfoService {
  /**
   * Ä°Ålemci bilgilerini dÃ¶ndÃ¼rÃ¼r
   * @returns Ä°Ålemci bilgileri
   */
  async getCpuInfo() {
    const cpuInfo = os$a.cpus()[0];
    const cpuCores = os$a.cpus().length;
    const cpuThreads = os$a.cpus().length;
    return {
      model: cpuInfo.model,
      speed: `${cpuInfo.speed / 1e3} GHz`,
      cores: cpuCores,
      threads: cpuThreads
    };
  }
  /**
   * Bellek bilgilerini dÃ¶ndÃ¼rÃ¼r
   * @returns Bellek bilgileri
   */
  getMemoryInfo() {
    const totalMem = os$a.totalmem();
    const freeMem = os$a.freemem();
    return {
      total: `${(totalMem / 1024 / 1024 / 1024).toFixed(2)} GB`,
      free: `${(freeMem / 1024 / 1024 / 1024).toFixed(2)} GB`
    };
  }
  /**
   * Disk bilgilerini dÃ¶ndÃ¼rÃ¼r
   * @returns Disk bilgileri
   */
  async getDiskInfo() {
    let diskSpace = "Bilinmiyor";
    let diskFree = "Bilinmiyor";
    try {
      const disks = dist.getDiskInfoSync();
      const systemDisk = disks.find((disk) => disk.mounted === "C:") || disks[0];
      if (systemDisk) {
        diskSpace = `${Math.floor(systemDisk.blocks / (1024 * 1024 * 1024))} GB`;
        diskFree = `${Math.floor(systemDisk.available / (1024 * 1024 * 1024))} GB`;
      }
    } catch (error) {
      console.error("Disk bilgileri alÄ±namadÄ±:", error);
    }
    return {
      total: diskSpace,
      free: diskFree
    };
  }
  /**
   * Ä°Åletim sistemi bilgilerini dÃ¶ndÃ¼rÃ¼r
   * @returns Ä°Åletim sistemi bilgileri
   */
  getOsInfo() {
    return {
      os: `${os$a.type()} ${os$a.arch()}`,
      version: os$a.release(),
      networkName: os$a.networkInterfaces().Ethernet ? "Ethernet" : "Wi-Fi"
    };
  }
  /**
   * Ekran Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄÃ¼nÃ¼ dÃ¶ndÃ¼rÃ¼r
   * @returns Ekran Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄÃ¼
   */
  getScreenResolution() {
    let screenResolution = "Bilinmiyor";
    try {
      const primaryDisplay = screen.getPrimaryDisplay();
      const { width, height } = primaryDisplay.size;
      screenResolution = `${width}x${height}`;
    } catch (error) {
      console.error("Ekran Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄÃ¼ alÄ±namadÄ±:", error);
    }
    return screenResolution;
  }
  /**
   * Batarya seviyesini dÃ¶ndÃ¼rÃ¼r
   * @returns Batarya seviyesi
   */
  async getBatteryLevel() {
    let batteryLevel = 0;
    try {
      const batteryInfo = await si.battery();
      batteryLevel = batteryInfo.percent;
    } catch (error) {
      console.error("Batarya bilgisi alÄ±namadÄ±:", error);
    }
    return batteryLevel;
  }
  /**
   * Sistemin Ã§alÄ±Åma sÃ¼resini dÃ¶ndÃ¼rÃ¼r
   * @returns ÃalÄ±Åma sÃ¼resi
   */
  getUptime() {
    const uptime = os$a.uptime();
    const uptimeHours = Math.floor(uptime / 3600);
    const uptimeMinutes = Math.floor(uptime % 3600 / 60);
    return `${uptimeHours} saat ${uptimeMinutes} dakika`;
  }
  /**
   * TÃ¼m sistem bilgilerini dÃ¶ndÃ¼rÃ¼r
   * @returns TÃ¼m sistem bilgileri
   */
  async getAllSystemInfo() {
    const cpuInfo = await this.getCpuInfo();
    const memoryInfo = this.getMemoryInfo();
    const diskInfo = await this.getDiskInfo();
    const osInfo2 = this.getOsInfo();
    const screenResolution = this.getScreenResolution();
    const batteryLevel = await this.getBatteryLevel();
    const uptime = this.getUptime();
    return {
      cpu: cpuInfo.model,
      cpuSpeed: cpuInfo.speed,
      cpuCores: cpuInfo.cores,
      cpuThreads: cpuInfo.threads,
      ram: memoryInfo.total,
      freeRam: memoryInfo.free,
      os: osInfo2.os,
      version: osInfo2.version,
      networkName: osInfo2.networkName,
      batteryLevel,
      screenResolution,
      uptime,
      diskSpace: diskInfo.total,
      diskFree: diskInfo.free
    };
  }
}
class WingetService {
  constructor(app2) {
    __publicField(this, "isWindows");
    __publicField(this, "wingetAvailable", null);
    __publicField(this, "windowsTerminalAvailable");
    __publicField(this, "execAsync");
    __publicField(this, "updatingApps", /* @__PURE__ */ new Set());
    __publicField(this, "installingApps", /* @__PURE__ */ new Set());
    __publicField(this, "app");
    // Ãrnek uygulama verileri - winget Ã§alÄ±Åmazsa kullanÄ±lacak
    __publicField(this, "mockApps", [
      { name: "Visual Studio Code", version: "1.76.0", newVersion: "1.80.1" },
      { name: "Google Chrome", version: "115.0.1", newVersion: "" },
      { name: "Mozilla Firefox", version: "115.0", newVersion: "116.0" },
      { name: "Node.js", version: "18.15.0", newVersion: "20.5.1" },
      { name: "WinRAR", version: "6.10", newVersion: "6.23" },
      { name: "7-Zip", version: "22.01", newVersion: "" },
      { name: "Notepad++", version: "8.5.0", newVersion: "8.5.4" },
      { name: "VLC Media Player", version: "3.0.18", newVersion: "" },
      { name: "Adobe Acrobat Reader", version: "23.001.20143", newVersion: "23.003.20244" },
      { name: "Spotify", version: "1.2.8.923", newVersion: "1.2.9.743" },
      { name: "Discord", version: "1.0.9012", newVersion: "1.0.9016" },
      { name: "WhatsApp", version: "2.2320.2", newVersion: "" }
    ]);
    this.isWindows = platform() === "win32";
    this.windowsTerminalAvailable = platform() === "win32";
    this.execAsync = promisify$1(exec$h);
    this.app = app2;
  }
  /**
   * Winget komutunun Ã§alÄ±ÅÄ±p Ã§alÄ±ÅmadÄ±ÄÄ±nÄ± kontrol eder
   * @returns Winget'in kullanÄ±labilir olup olmadÄ±ÄÄ±
   */
  async checkWingetAvailability() {
    if (this.wingetAvailable !== null) {
      return this.wingetAvailable;
    }
    if (!this.isWindows) {
      console.warn("Winget only works on Windows OS");
      this.wingetAvailable = false;
      return false;
    }
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        console.warn("Winget availability check timed out");
        this.wingetAvailable = false;
        resolve(false);
      }, 3e3);
      try {
        const process2 = spawn$1("winget", ["--version"]);
        process2.on("error", (error) => {
          clearTimeout(timeout);
          console.warn("Winget not available:", error.message);
          this.wingetAvailable = false;
          resolve(false);
        });
        process2.on("close", (code) => {
          clearTimeout(timeout);
          this.wingetAvailable = code === 0;
          resolve(code === 0);
        });
      } catch (error) {
        clearTimeout(timeout);
        console.warn("Error checking winget availability:", error);
        this.wingetAvailable = false;
        resolve(false);
      }
    });
  }
  /**
   * YÃ¼klÃ¼ uygulamalarÄ±n listesini dÃ¶ndÃ¼rÃ¼r
   * @returns YÃ¼klÃ¼ uygulamalarÄ±n listesi
   */
  async getInstalledApps() {
    try {
      const result2 = await this.executeCommand("list", ["--source", "winget"]);
      const apps = this.parseInstalledAppsList(result2);
      return apps;
    } catch (error) {
      console.error("Winget getInstalledApps error:", error);
      if (error.message.includes("0x80070002") || error.message.includes("not found")) {
        throw new Error("Winget bulunamadÄ±. LÃ¼tfen winget'in yÃ¼klÃ¼ olduÄundan emin olun");
      }
      throw new Error(`Uygulama listesi alÄ±namadÄ±: ${error.message}`);
    }
  }
  /**
   * Winget ile uygulama arama
   * @param keyword Aranacak anahtar kelime
   * @returns Bulunan uygulamalarÄ±n listesi
   */
  async searchApps(keyword) {
    try {
      const result2 = await this.executeCommand("search", [keyword, "--source", "winget", "--accept-source-agreements"]);
      const apps = this.parseSearchResults(result2);
      return apps;
    } catch (error) {
      console.error("Winget searchApps error:", error);
      if (error.message.includes("0x80070002") || error.message.includes("not found")) {
        throw new Error("Winget bulunamadÄ±. LÃ¼tfen winget'in yÃ¼klÃ¼ olduÄundan emin olun");
      }
      throw new Error(`Uygulama aramasÄ± yapÄ±lamadÄ±: ${error.message}`);
    }
  }
  /**
   * Winget ile uygulama gÃ¼ncelleme
   * @param app GÃ¼ncellenecek uygulama (AppInfo objesi veya string olarak id)
   * @returns Ä°Ålem sonucu
   */
  async updateApp(app2) {
    try {
      if (!this.wingetAvailable) {
        await this.checkWingetAvailability();
        if (!this.wingetAvailable) {
          return {
            success: false,
            message: "Winget yÃ¼klÃ¼ deÄil veya eriÅilemiyor"
          };
        }
      }
      const appId = typeof app2 === "string" ? app2 : app2.id;
      if (!appId) {
        return {
          success: false,
          message: "GeÃ§ersiz uygulama ID. GÃ¼ncelleme yapÄ±lamadÄ±."
        };
      }
      console.log(`Updating app with ID: ${appId}`);
      if (this.updatingApps.has(appId)) {
        return {
          success: false,
          message: "Bu uygulama zaten gÃ¼ncelleniyor"
        };
      }
      this.updatingApps.add(appId);
      try {
        const installedApps = await this.getInstalledApps();
        const appExists = Array.isArray(installedApps) && installedApps.some((app22) => app22.id === appId);
        if (!appExists) {
          this.updatingApps.delete(appId);
          return {
            success: false,
            message: `${appId} uygulamasÄ± yÃ¼klÃ¼ deÄil ve gÃ¼ncellenemez`
          };
        }
        const result2 = await this.executeCommand("upgrade", [appId, "--source", "winget"]);
        if (result2.includes("successfully") || result2.includes("baÅarÄ±yla")) {
          console.log(`Successfully updated app: ${appId}`);
          this.updatingApps.delete(appId);
          return {
            success: true,
            message: `${appId} baÅarÄ±yla gÃ¼ncellendi`
          };
        } else if (result2.includes("No applicable update found") || result2.includes("gÃ¼ncelleÅtirme bulunamadÄ±") || result2.includes("is already installed") || result2.includes("zaten yÃ¼klÃ¼")) {
          console.log(`App is already up to date: ${appId}`);
          this.updatingApps.delete(appId);
          return {
            success: true,
            message: `${appId} zaten gÃ¼ncel`
          };
        } else if (!result2.includes("failed") && !result2.includes("error") && !result2.includes("hata")) {
          console.log(`App updated with custom message: ${appId}`);
          this.updatingApps.delete(appId);
          return {
            success: true,
            message: `${appId} gÃ¼ncellendi: ${result2.split("\n")[0]}`
          };
        } else if (result2.includes("Access denied") || result2.includes("access is denied") || result2.includes("EriÅim reddedildi") || result2.includes("yetkisiz")) {
          console.error(`Access denied error while updating app: ${appId}`, result2);
          this.updatingApps.delete(appId);
          return {
            success: false,
            message: `${appId} gÃ¼ncellenemedi: EriÅim reddedildi. YÃ¶netici olarak Ã§alÄ±ÅtÄ±rmayÄ± deneyin.`
          };
        } else if (result2.includes("No package found") || result2.includes("bulunamadÄ±") || result2.includes("not found")) {
          console.error(`Package not found error while updating app: ${appId}`, result2);
          this.updatingApps.delete(appId);
          return {
            success: false,
            message: `${appId} paketi kaynakta bulunamadÄ±.`
          };
        } else {
          console.error(`Error updating app: ${appId}`, result2);
          this.updatingApps.delete(appId);
          const errorLine = result2.split("\n").find(
            (line) => line.includes("failed") || line.includes("error") || line.includes("hata") || line.includes("baÅarÄ±sÄ±z")
          );
          return {
            success: false,
            message: `${appId} gÃ¼ncellenemedi: ${errorLine || result2.split("\n")[0]}`
          };
        }
      } catch (error) {
        console.error(`Exception when updating app ${appId}:`, error);
        this.updatingApps.delete(appId);
        let errorMessage = error.message || "Bilinmeyen bir hata oluÅtu";
        if (errorMessage.includes("0x80070002") || errorMessage.includes("not found")) {
          errorMessage = "Winget bulunamadÄ±. LÃ¼tfen winget'in yÃ¼klÃ¼ olduÄundan emin olun";
        } else if (errorMessage.includes("0x8007139f")) {
          errorMessage = "Bu iÅlem iÃ§in yÃ¶netici izinleri gerekli";
        } else if (errorMessage.includes("NetworkError") || errorMessage.includes("network")) {
          errorMessage = "AÄ hatasÄ±: LÃ¼tfen internet baÄlantÄ±nÄ±zÄ± kontrol edin";
        }
        return {
          success: false,
          message: `Hata: ${errorMessage}`
        };
      }
    } catch (error) {
      console.error("updateApp error:", error);
      return {
        success: false,
        message: `Hata: ${error.message || "Bilinmeyen bir hata oluÅtu"}`
      };
    }
  }
  /**
   * SeÃ§ili uygulamalarÄ± gÃ¼ncelleme
   * @param apps GÃ¼ncellenecek uygulama listesi
   * @returns GÃ¼ncelleme sonuÃ§larÄ±
   */
  async update(apps) {
    try {
      if (!Array.isArray(apps) || apps.length === 0) {
        return [{
          id: "batch",
          success: false,
          message: "GÃ¼ncellenecek uygulama listesi boÅ veya geÃ§ersiz"
        }];
      }
      const results = [];
      for (const app2 of apps) {
        const result2 = await this.updateApp(app2);
        const appId = typeof app2 === "string" ? app2 : app2.id;
        results.push({
          id: appId || "unknown",
          ...result2
        });
      }
      return results;
    } catch (error) {
      console.error("Batch update error:", error);
      return [{
        id: "batch",
        success: false,
        message: `Toplu gÃ¼ncelleme hatasÄ±: ${error.message || "Bilinmeyen bir hata oluÅtu"}`
      }];
    }
  }
  /**
   * Winget ile uygulama yÃ¼kleme
   * @param appId UygulamanÄ±n ID'si
   * @returns Ä°Ålem sonucu
   */
  async installApp(appId) {
    try {
      if (!this.wingetAvailable) {
        throw new Error("Winget yÃ¼klÃ¼ deÄil.");
      }
      console.log(`Installing app with ID: ${appId}`);
      if (this.installingApps.has(appId)) {
        return { success: false, message: "Bu uygulama zaten yÃ¼kleniyor" };
      }
      this.installingApps.add(appId);
      try {
        const installedApps = await this.getInstalledApps();
        const alreadyInstalled = installedApps.some((app2) => app2.id === appId);
        if (alreadyInstalled) {
          this.installingApps.delete(appId);
          return {
            success: false,
            message: `${appId} uygulamasÄ± zaten yÃ¼klÃ¼`
          };
        }
        const result2 = await this.executeCommand("install", [appId, "--source", "winget", "--accept-source-agreements", "--accept-package-agreements"]);
        if (result2.includes("successfully") || result2.includes("baÅarÄ±yla")) {
          console.log(`Successfully installed app: ${appId}`);
          this.installingApps.delete(appId);
          return {
            success: true,
            message: `${appId} baÅarÄ±yla yÃ¼klendi`
          };
        } else if (result2.includes("is already installed") || result2.includes("zaten yÃ¼klÃ¼")) {
          console.log(`App is already installed: ${appId}`);
          this.installingApps.delete(appId);
          return {
            success: true,
            message: `${appId} zaten yÃ¼klÃ¼`
          };
        } else if (!result2.includes("failed") && !result2.includes("error")) {
          console.log(`App installed with custom message: ${appId}`);
          this.installingApps.delete(appId);
          return {
            success: true,
            message: `${appId} yÃ¼klendi: ${result2.split("\n")[0]}`
          };
        } else {
          console.error(`Error installing app: ${appId}`, result2);
          this.installingApps.delete(appId);
          return {
            success: false,
            message: `${appId} yÃ¼klenemedi: ${result2.split("\n")[0]}`
          };
        }
      } catch (error) {
        console.error(`Exception when installing app ${appId}:`, error);
        this.installingApps.delete(appId);
        return {
          success: false,
          message: `Hata: ${error.message || "Bilinmeyen bir hata oluÅtu"}`
        };
      }
    } catch (error) {
      console.error("installApp error:", error);
      return {
        success: false,
        message: `Hata: ${error.message || "Bilinmeyen bir hata oluÅtu"}`
      };
    }
  }
  /**
   * Mock veri Ã¼reten yardÄ±mcÄ± metod
   * @returns Ãrnek uygulama listesi
   */
  generateMockData() {
    return this.mockApps.map((app2) => {
      const id = app2.name.replace(/\s+/g, ".").toLowerCase();
      return {
        ...app2,
        id
        // UygulamanÄ±n gÃ¼ncelleme durumunu korumak iÃ§in burada deÄiÅiklik yapmÄ±yoruz
      };
    });
  }
  async executeCommand(command, args = []) {
    try {
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          const result2 = await new Promise((resolve, reject) => {
            console.log(`Executing winget command: winget ${command} ${args.join(" ")}`);
            const childProcess = spawn$1("winget", [command, ...args], {
              shell: true
            });
            let stdout = "";
            let stderr = "";
            childProcess.stdout.on("data", (data) => {
              const chunk = data.toString();
              stdout += chunk;
              console.log(`[winget stdout]: ${chunk}`);
            });
            childProcess.stderr.on("data", (data) => {
              const chunk = data.toString();
              stderr += chunk;
              console.error(`[winget stderr]: ${chunk}`);
            });
            childProcess.on("close", (code) => {
              console.log(`Winget command exited with code ${code}`);
              if (code !== 0) {
                const errorMessage = stderr || `Winget komutu ${code} kodu ile baÅarÄ±sÄ±z oldu`;
                const errorDetail = {
                  command: `winget ${command} ${args.join(" ")}`,
                  exitCode: code,
                  stdout,
                  stderr
                };
                console.error("Winget command failed:", errorDetail);
                if (stderr.includes("0x80070002") || stderr.includes("not found")) {
                  reject(new Error("Winget bulunamadÄ±. LÃ¼tfen winget'in yÃ¼klÃ¼ olduÄundan emin olun"));
                } else if (stderr.includes("0x8007139f")) {
                  reject(new Error("Bu iÅlem iÃ§in yÃ¶netici izinleri gerekli olabilir"));
                } else if (stderr.includes("NetworkError") || stderr.includes("network")) {
                  reject(new Error("AÄ hatasÄ±: LÃ¼tfen internet baÄlantÄ±nÄ±zÄ± kontrol edin"));
                } else if (stderr.includes("Failed to update package")) {
                  reject(new Error("Paket gÃ¼ncellenirken hata oluÅtu: GÃ¼ncelleme engellenmiÅ veya paket kilitli olabilir"));
                } else {
                  reject(new Error(errorMessage));
                }
              } else {
                if (!stdout.trim()) {
                  console.warn("Winget command returned empty output");
                  resolve("Komut baÅarÄ±yla Ã§alÄ±ÅtÄ± fakat Ã§Ä±ktÄ± Ã¼retmedi");
                } else if (stdout.includes("failed") || stdout.includes("error")) {
                  console.warn("Winget command output contains error indicators:", stdout);
                  resolve(stdout);
                } else {
                  resolve(stdout);
                }
              }
            });
            childProcess.on("error", (err) => {
              console.error("Winget process error:", err);
              reject(new Error(`Winget komutu Ã§alÄ±ÅtÄ±rÄ±lamadÄ±: ${err.message}`));
            });
            const timeout = setTimeout(() => {
              childProcess.kill();
              console.error("Winget command timed out after 30 seconds");
              reject(new Error("Winget komutu zaman aÅÄ±mÄ±na uÄradÄ±. Ä°Ålem iptal edildi."));
            }, 3e4);
            childProcess.on("close", () => clearTimeout(timeout));
          });
          return result2;
        } catch (error) {
          if (attempt === 3) {
            console.error(`Winget command failed after 3 attempts: ${error.message}`);
            throw error;
          }
          const delay = attempt * 2e3;
          console.log(`Winget komutu baÅarÄ±sÄ±z oldu, ${attempt}/3 yeniden deneniyor (${delay}ms sonra)...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
      throw new Error("Beklenmeyen bir hata oluÅtu");
    } catch (error) {
      console.error("Winget executeCommand error:", error);
      throw error;
    }
  }
  parseInstalledAppsList(result2) {
    try {
      console.log("Parsing winget list output:", result2.slice(0, 200) + "...");
      const lines = result2.split("\n");
      let startIndex = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes("Name") && lines[i].includes("Id") && lines[i].includes("Version")) {
          startIndex = i + 2;
          break;
        }
      }
      if (startIndex === 0) {
        console.warn("Winget output header not found, using default parsing logic");
        startIndex = 2;
      }
      const dataLines = lines.slice(startIndex);
      const apps = dataLines.map((line) => line.trim()).filter((line) => line.length > 0).map((line) => {
        try {
          const parts = line.split(/\s{2,}/);
          if (parts.length < 3) {
            console.warn("Invalid winget output line format:", line);
            return null;
          }
          return {
            name: parts[0] || "Unknown App",
            id: parts[1] || "",
            version: parts[2] || "",
            newVersion: parts[3] || ""
          };
        } catch (lineError) {
          console.warn("Error parsing winget output line:", line, lineError);
          return null;
        }
      }).filter((app2) => app2 !== null);
      console.log(`Successfully parsed ${apps.length} applications`);
      return apps;
    } catch (parseError) {
      console.error("Error parsing winget output:", parseError);
      console.log("Returning mock data due to parsing error");
      return this.generateMockData();
    }
  }
  parseSearchResults(result2) {
    try {
      console.log("Parsing winget search output:", result2.slice(0, 200) + "...");
      const lines = result2.split("\n");
      let startIndex = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes("Name") && lines[i].includes("Id") && lines[i].includes("Version")) {
          startIndex = i + 2;
          break;
        }
      }
      if (startIndex === 0) {
        console.warn("Winget search output header not found, using default parsing logic");
        startIndex = 2;
      }
      const dataLines = lines.slice(startIndex);
      const apps = dataLines.map((line) => line.trim()).filter((line) => line.length > 0).map((line) => {
        try {
          const parts = line.split(/\s{2,}/);
          if (parts.length < 2) {
            console.warn("Invalid winget search output line format:", line);
            return null;
          }
          return {
            name: parts[0] || "Unknown App",
            id: parts[1] || "",
            version: parts[2] || "",
            installed: false
            // VarsayÄ±lan olarak yÃ¼klÃ¼ deÄil
          };
        } catch (lineError) {
          console.warn("Error parsing winget search output line:", line, lineError);
          return null;
        }
      }).filter((app2) => app2 !== null);
      console.log(`Successfully parsed ${apps.length} search results`);
      return apps;
    } catch (parseError) {
      console.error("Error parsing winget search output:", parseError);
      console.log("Returning mock data due to parsing error");
      return this.mockApps.filter((app2) => app2.name.toLowerCase().includes("")).map((app2) => ({
        ...app2,
        id: app2.name.replace(/\s+/g, ".").toLowerCase(),
        installed: false
      }));
    }
  }
}
class IpcHandlerService {
  constructor() {
    __publicField(this, "systemInfoService");
    __publicField(this, "wingetService");
    this.systemInfoService = new SystemInfoService();
    this.wingetService = new WingetService();
  }
  /**
   * TÃ¼m IPC iÅleyicilerini kaydeder
   */
  registerHandlers() {
    this.registerSystemInfoHandlers();
    this.registerWingetHandlers();
  }
  /**
   * Sistem bilgileriyle ilgili IPC iÅleyicilerini kaydeder
   */
  registerSystemInfoHandlers() {
    ipcMain.handle("getSystemInfo", async () => {
      return await this.systemInfoService.getAllSystemInfo();
    });
  }
  /**
   * Winget ile ilgili IPC iÅleyicilerini kaydeder
   */
  registerWingetHandlers() {
    ipcMain.handle("get-installed-apps", async () => {
      try {
        const installedApps = await this.wingetService.getInstalledApps();
        return installedApps;
      } catch (error) {
        console.error("IPC handler get-installed-apps error:", error);
        return { error: error.message || "Uygulama listesi alÄ±nÄ±rken bir hata oluÅtu" };
      }
    });
    ipcMain.handle("search-apps", async (_event, keyword) => {
      try {
        const searchResults = await this.wingetService.searchApps(keyword);
        return searchResults;
      } catch (error) {
        console.error("IPC handler search-apps error:", error);
        return { error: error.message || "Uygulama aramasÄ± yapÄ±lÄ±rken bir hata oluÅtu" };
      }
    });
    ipcMain.handle("update-app", async (_event, appId) => {
      try {
        const result2 = await this.wingetService.updateApp(appId);
        return { success: true, message: result2 };
      } catch (error) {
        console.error("IPC handler update-app error:", error);
        return {
          success: false,
          message: error.message || "Uygulama gÃ¼ncellenirken bir hata oluÅtu",
          details: error.stack
        };
      }
    });
    ipcMain.handle("install-app", async (_event, appId) => {
      try {
        const result2 = await this.wingetService.installApp(appId);
        return { success: true, message: result2 };
      } catch (error) {
        console.error("IPC handler install-app error:", error);
        return {
          success: false,
          message: error.message || "Uygulama yÃ¼klenirken bir hata oluÅtu",
          details: error.stack
        };
      }
    });
  }
}
createRequire(import.meta.url);
const __dirname = path$3.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$3.join(__dirname, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$3.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$3.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$3.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  win = new BrowserWindow({
    width: 1200,
    height: 830,
    resizable: true,
    icon: path$3.join(process.env.VITE_PUBLIC, "icon.svg"),
    webPreferences: {
      preload: path$3.join(__dirname, "preload.mjs")
    }
  });
  const ipcHandlerService = new IpcHandlerService();
  ipcHandlerService.registerHandlers();
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$3.join(RENDERER_DIST, "index.html"));
  }
}
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
app.whenReady().then(createWindow);
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
